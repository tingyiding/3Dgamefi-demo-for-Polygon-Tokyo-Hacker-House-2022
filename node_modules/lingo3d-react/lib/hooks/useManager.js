import React, { useContext, useLayoutEffect } from "react";
import useDiffProps from "./useDiffProps";
import { useMemoOnce } from "@lincode/hooks";
import { forceGet } from "@lincode/utils";
import { Reactive } from "@lincode/reactivity";
import processDefaults from "../Props/utils/processDefaults";
export const ParentContext = React.createContext(undefined);
const handleStore = new WeakMap();
const makeHandleMap = () => new Map();
export const applyChanges = (manager, changed, removed) => {
    var _a, _b;
    const handleMap = forceGet(handleStore, manager, makeHandleMap);
    for (const [key, value] of changed) {
        (_a = handleMap.get(key)) === null || _a === void 0 ? void 0 : _a.cancel();
        if (value instanceof Reactive) {
            handleMap.set(key, value.get(v => manager[key] = v));
            continue;
        }
        manager[key] = value;
    }
    if (!removed.length)
        return;
    const defaults = processDefaults(manager.constructor.defaults);
    for (const key of removed) {
        (_b = handleMap.get(key)) === null || _b === void 0 ? void 0 : _b.cancel();
        manager[key] = defaults[key];
    }
};
const appendedSet = new WeakSet();
export default (p, ref, ManagerClass) => {
    const { children, ...props } = p;
    const parent = useContext(ParentContext);
    const manager = useMemoOnce(() => {
        const manager = new ManagerClass();
        if (parent) {
            parent.append(manager);
            appendedSet.add(manager);
        }
        return manager;
    }, manager => {
        const handleMap = handleStore.get(manager);
        if (handleMap)
            for (const handle of handleMap.values())
                handle.cancel();
        manager.dispose();
    });
    useLayoutEffect(() => {
        if (!parent || appendedSet.has(manager))
            return;
        parent.append(manager);
        appendedSet.add(manager);
    }, [parent]);
    const [changed, removed] = useDiffProps(props);
    applyChanges(manager, changed, removed);
    useLayoutEffect(() => {
        if (!ref)
            return;
        if (typeof ref === "function")
            ref(manager);
        else
            ref.current = manager;
    }, [ref]);
    return manager;
};
