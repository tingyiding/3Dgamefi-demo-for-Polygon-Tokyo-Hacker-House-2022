import {
  getBVHMap
} from "./chunk-W3OBF4EK.js";
import {
  box3,
  line3,
  vector3,
  vector3_,
  vector3__
} from "./chunk-NPOYVG57.js";
import {
  getEditorActive,
  getWorldPosition_default,
  getWorldQuaternion_default,
  onBeforeRender
} from "./chunk-J7HA7FW3.js";
import {
  createEffect,
  event_default
} from "./chunk-NXCTIVNA.js";
import "./chunk-57VJUUAA.js";
import "./chunk-XA4H47DG.js";

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/bvh/bvhCameraLoop.js
var bvhCameraSet = /* @__PURE__ */ new Set();
var [emitBeforeCameraLoop, onBeforeCameraLoop] = event_default();
createEffect(function() {
  const bvhArray = getBVHMap();
  if (!bvhArray.length) {
    const handle2 = onBeforeRender(emitBeforeCameraLoop);
    return () => {
      handle2.cancel();
    };
  }
  const handle = onBeforeRender(() => {
    emitBeforeCameraLoop();
    for (const cam of bvhCameraSet) {
      const capsuleRadius = 0.5;
      cam.updateMatrixWorld();
      const direction = cam.getWorldDirection(vector3__);
      const { start, end } = line3;
      end.copy(start.copy(cam.position));
      box3.makeEmpty();
      box3.expandByPoint(start);
      box3.min.addScalar(-capsuleRadius);
      box3.max.addScalar(capsuleRadius);
      const triPoint = vector3;
      const capsulePoint = vector3_;
      let distance = 0;
      let depth = 0;
      for (const boundsTree of bvhArray)
        boundsTree.shapecast({
          intersectsBounds: (box) => box.intersectsBox(box3),
          intersectsTriangle: (tri) => {
            distance = tri.closestPointToSegment(line3, triPoint, capsulePoint);
            if (distance < capsuleRadius) {
              depth = capsuleRadius - distance;
              start.addScaledVector(direction, depth);
              end.addScaledVector(direction, depth);
            }
          }
        });
      const deltaVector = start.sub(cam.position);
      const offset = Math.max(0, deltaVector.length() - 1e-5);
      deltaVector.normalize().multiplyScalar(offset);
      cam.position.add(deltaVector);
    }
  });
  return () => {
    handle.cancel();
  };
}, [getBVHMap]);

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/enableBVHCamera.js
function setVisible(visible) {
  var _a;
  const target = this.targetState.get();
  if (target && target._visible === void 0)
    target.outerObject3d.visible = visible;
  for (const child of this.camera.children)
    if (((_a = child.userData.manager) == null ? void 0 : _a._visible) === void 0)
      child.visible = visible;
}
function enableBVHCamera_default() {
  if (this.done)
    return;
  const cam = this.camera;
  bvhCameraSet.add(cam);
  this.then(() => bvhCameraSet.delete(cam));
  this.createEffect(() => {
    const target = this.targetState.get();
    if (!target)
      return;
    let tooCloseOld = true;
    setVisible.call(this, !tooCloseOld);
    let first = true;
    const handle = onBeforeCameraLoop(() => {
      const origin = getWorldPosition_default(this.outerObject3d);
      const camPos = getWorldPosition_default(this.object3d);
      const dist = camPos.distanceTo(origin);
      cam.position.lerp(camPos, first ? 1 : 0.1);
      const ratio = first ? 1 : cam.position.distanceTo(origin) / dist;
      cam.position.lerpVectors(origin, camPos, ratio);
      cam.quaternion.copy(getWorldQuaternion_default(this.object3d));
      const tooClose = getEditorActive() ? false : ratio < 0.35;
      tooClose !== tooCloseOld && setVisible.call(this, !tooClose);
      tooCloseOld = tooClose;
      first = false;
    });
    return () => {
      handle.cancel();
    };
  }, [this.targetState.get]);
}
export {
  enableBVHCamera_default as default
};
//# sourceMappingURL=enableBVHCamera-MHUMQMX2.js.map
