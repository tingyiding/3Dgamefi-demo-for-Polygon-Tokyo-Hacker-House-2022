import {
  vector3
} from "./chunk-NPOYVG57.js";
import {
  EventLoopItem,
  appendableRoot,
  eventLoopDefaults,
  eventLoopSchema,
  getAntiAlias,
  getDefaultLight,
  getDefaultLightScale,
  getRenderer
} from "./chunk-MO2ISMHQ.js";
import {
  getCameraRendered,
  getEditorActive,
  getResolution,
  getVR,
  getWorldPosition_default,
  onBeforeRender,
  setResolution
} from "./chunk-J7HA7FW3.js";
import {
  Events_default,
  createEffect,
  createNestedEffect,
  debounce,
  event_default,
  store,
  throttle
} from "./chunk-NXCTIVNA.js";
import {
  Group,
  LinearToneMapping,
  NoToneMapping
} from "./chunk-57VJUUAA.js";
import {
  __publicField
} from "./chunk-XA4H47DG.js";

// node_modules/lingo3d/lib/states/useExposure.js
var [setExposure, getExposure] = store(1);

// node_modules/lingo3d/lib/states/usePBR.js
var [setPBR, getPBR] = store(false);

// node_modules/lingo3d/lib/states/useSecondaryCamera.js
var [setSecondaryCamera, getSecondaryCamera] = store(void 0);

// node_modules/lingo3d/lib/engine/renderLoop/VRButton.js
var VRButton = {
  createButton(renderer, options) {
    if (options) {
      console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
    }
    const button = document.createElement("button");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "ENTER VR";
      button.onmouseenter = function() {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = function() {
        button.style.opacity = "0.5";
      };
      button.onclick = function() {
        if (currentSession === null) {
          const sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
          navigator.xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function showVRNotAllowed(exception) {
      disableButton();
      console.warn("Exception when trying to call xr.isSessionSupported", exception);
      button.textContent = "VR NOT ALLOWED";
    }
    function stylizeElement(element) {
      element.style.position = "absolute";
      element.style.bottom = "20px";
      element.style.padding = "12px 6px";
      element.style.border = "1px solid #fff";
      element.style.borderRadius = "4px";
      element.style.background = "rgba(0,0,0,0.1)";
      element.style.color = "#fff";
      element.style.font = "normal 13px sans-serif";
      element.style.textAlign = "center";
      element.style.opacity = "0.5";
      element.style.outline = "none";
      element.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      button.id = "VRButton";
      button.style.display = "none";
      stylizeElement(button);
      navigator.xr.isSessionSupported("immersive-vr").then(function(supported) {
        supported ? showEnterVR() : showWebXRNotFound();
        if (supported && VRButton.xrSessionIsGranted) {
          button.click();
        }
      }).catch(showVRNotAllowed);
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  },
  xrSessionIsGranted: false,
  registerSessionGrantedListener() {
    if ("xr" in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent))
        return;
      navigator.xr.addEventListener("sessiongranted", () => {
        VRButton.xrSessionIsGranted = true;
      });
    }
  }
};
VRButton.registerSessionGrantedListener();

// node_modules/lingo3d/lib/states/useAutoMount.js
var [setAutoMount, getAutoMount] = store(false);

// node_modules/lingo3d/lib/events/onEditorMountChange.js
var [_emitEditorMountChange, onEditorMountChange] = event_default();
var emitEditorMountChange = debounce(_emitEditorMountChange, 0, "trailing");

// node_modules/lingo3d/lib/states/usePixelRatio.js
var [setPixelRatio, getPixelRatio] = store(void 0);

// node_modules/lingo3d/lib/states/usePixelRatioComputed.js
var [setPixelRatioComputed, getPixelRatioComputed] = store(1);
createEffect(() => {
  var _a;
  setPixelRatioComputed((_a = getPixelRatio()) != null ? _a : getAntiAlias() === "SSAA" ? devicePixelRatio > 1 ? 1.5 : 1 : 1);
}, [getAntiAlias, getPixelRatio]);

// node_modules/lingo3d/lib/engine/renderLoop/renderSetup.js
var rootContainer = document.createElement("div");
Object.assign(rootContainer.style, {
  position: "absolute",
  left: "0px",
  top: "0px",
  width: "100%",
  height: "100%"
});
var container = document.createElement("div");
Object.assign(container.style, {
  position: "absolute",
  left: "0px",
  top: "0px",
  width: "100%"
});
rootContainer.appendChild(container);
getSecondaryCamera((cam) => container.style.height = cam ? "50%" : "100%");
var containerBounds = [container.getBoundingClientRect()];
var useResize = (el) => {
  createNestedEffect(() => {
    const handleResize = () => {
      containerBounds[0] = container.getBoundingClientRect();
      setResolution(el === document.body ? [window.innerWidth, window.innerHeight] : [el.clientWidth, el.clientHeight]);
    };
    handleResize();
    const handleResizeDebounced = debounce(handleResize, 100, "both");
    window.addEventListener("resize", handleResizeDebounced);
    const handle = onEditorMountChange(handleResizeDebounced);
    return () => {
      window.removeEventListener("resize", handleResize);
      handle.cancel();
    };
  }, []);
};
createEffect(() => {
  const autoMount = getAutoMount();
  if (!autoMount)
    return;
  if (typeof autoMount === "string") {
    const el = document.querySelector(autoMount);
    if (!el)
      return;
    el.prepend(rootContainer);
    useResize(el);
    return () => {
      el.removeChild(rootContainer);
    };
  }
  if (autoMount === true) {
    document.body.prepend(rootContainer);
    useResize(document.body);
    return () => {
      document.body.removeChild(rootContainer);
    };
  }
  autoMount.prepend(rootContainer);
  useResize(autoMount);
  return () => {
    autoMount.removeChild(rootContainer);
  };
}, [getAutoMount]);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  const canvas = renderer.domElement;
  rootContainer.prepend(canvas);
  Object.assign(canvas.style, { position: "absolute", left: "0px", top: "0px" });
  return () => {
    rootContainer.removeChild(canvas);
  };
}, [getRenderer]);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  const [w, h] = getResolution();
  renderer.setSize(w, h);
  renderer.setPixelRatio(getPixelRatioComputed());
}, [getRenderer, getResolution, getPixelRatioComputed]);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  renderer.shadowMap.enabled = true;
}, [getRenderer]);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  renderer.physicallyCorrectLights = getPBR();
}, [getRenderer, getPBR]);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  const defaultLight = getDefaultLight();
  const exposure = typeof defaultLight === "string" && defaultLight !== "default" ? getExposure() * getDefaultLightScale() * (defaultLight === "studio" ? 2 : 1) : getExposure();
  renderer.toneMapping = exposure !== 1 ? LinearToneMapping : NoToneMapping;
  renderer.toneMappingExposure = exposure;
}, [getExposure, getRenderer, getDefaultLight, getDefaultLightScale]);
createEffect(() => {
  if (getVR() !== "webxr")
    return;
  const renderer = getRenderer();
  if (!renderer)
    return;
  renderer.xr.enabled = true;
  const button = VRButton.createButton(renderer);
  container.appendChild(button);
  button.ontouchstart = () => {
    var _a;
    return (_a = button.onclick) == null ? void 0 : _a.call(button, new MouseEvent("click"));
  };
  return () => {
    renderer.xr.enabled = false;
    container.removeChild(button);
  };
}, [getVR, getRenderer]);

// node_modules/lingo3d/lib/states/usePickingMode.js
var [setPickingMode, getPickingMode] = store("mouse");

// node_modules/lingo3d/lib/interface/IMouse.js
var MouseEventPayload = class {
  constructor(clientX = 0, clientY = 0, x = 0, y = 0, z = 0, xNorm = 0, yNorm = 0) {
    __publicField(this, "clientX");
    __publicField(this, "clientY");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "z");
    __publicField(this, "xNorm");
    __publicField(this, "yNorm");
    this.clientX = clientX;
    this.clientY = clientY;
    this.x = x;
    this.y = y;
    this.z = z;
    this.xNorm = xNorm;
    this.yNorm = yNorm;
  }
};
var LingoMouseEvent = class extends MouseEventPayload {
  constructor(clientX, clientY, x, y, z, xNorm, yNorm, point, distance) {
    super(x, y, z, clientX, clientY, xNorm, yNorm);
    __publicField(this, "point");
    __publicField(this, "distance");
    this.point = point;
    this.distance = distance;
  }
};
var mouseSchema = {
  ...eventLoopSchema,
  onClick: Function,
  onRightClick: Function,
  onMouseMove: Function,
  onMouseDown: Function,
  onMouseUp: Function,
  onMousePress: Function
};
var mouseDefaults = {
  ...eventLoopDefaults,
  onClick: void 0,
  onRightClick: void 0,
  onMouseMove: void 0,
  onMouseDown: void 0,
  onMouseUp: void 0,
  onMousePress: void 0
};

// node_modules/lingo3d/lib/states/useSelectionBlockMouse.js
var [setSelectionBlockMouse, getSelectionBlockMouse] = store(true);

// node_modules/lingo3d/lib/display/utils/clientToWorld.js
var clientToWorld_default = (ev, forceMouse) => {
  const rect = containerBounds[0];
  const clientX = ev.clientX - rect.x;
  const clientY = ev.clientY - rect.y;
  if (getPickingMode() === "camera" && !forceMouse)
    return new MouseEventPayload(clientX, clientY);
  const xNorm = clientX / rect.width * 2 - 1;
  const yNorm = -(clientY / rect.height) * 2 + 1;
  const camera = getCameraRendered();
  vector3.set(xNorm, yNorm, 0.5);
  vector3.unproject(camera);
  const cameraPosition = getWorldPosition_default(camera);
  vector3.sub(cameraPosition).normalize();
  const { x, y, z } = cameraPosition.add(vector3.multiplyScalar(5));
  return new MouseEventPayload(clientX, clientY, x, y, z, xNorm, yNorm);
};

// node_modules/lingo3d/lib/api/mouse.js
var mouseEvents = new Events_default();
var downTime = 0;
var downX = 0;
var downY = 0;
var rightClick = false;
container.addEventListener("contextmenu", (e) => {
  e.preventDefault();
  rightClick = true;
});
container.addEventListener("touchstart", (e) => {
  e.preventDefault();
});
mouseEvents.on("down", (e) => {
  downTime = Date.now();
  downX = e.clientX;
  downY = e.clientY;
});
mouseEvents.on("up", (e) => {
  const upTime = Date.now();
  const deltaTime = upTime - downTime;
  const deltaX = Math.abs(e.clientX - downX);
  const deltaY = Math.abs(e.clientY - downY);
  downTime = upTime;
  downX = e.clientX;
  downY = e.clientY;
  if (deltaTime < 300 && deltaX < 5 && deltaY < 5)
    mouseEvents.emit(rightClick ? "rightClick" : "click", e);
  rightClick = false;
});
var computeMouse = throttle(clientToWorld_default, 0, "leading");
container.addEventListener("pointermove", (ev) => {
  mouseEvents.emit("move", computeMouse(ev));
});
var down = false;
container.addEventListener("pointerdown", (ev) => {
  down = true;
  const payload = computeMouse(ev);
  mouseEvents.emit("down", payload);
  mouseEvents.emit("move", payload);
});
var handleUp = (ev) => {
  down && mouseEvents.emit("up", computeMouse(ev));
  down = false;
};
container.addEventListener("pointerup", handleUp);
container.addEventListener("pointercancel", handleUp);
container.addEventListener("pointerleave", handleUp);
var Mouse = class extends EventLoopItem {
  constructor() {
    super(new Group());
    __publicField(this, "onClick");
    __publicField(this, "onRightClick");
    __publicField(this, "onMouseMove");
    __publicField(this, "onMouseDown");
    __publicField(this, "onMouseUp");
    __publicField(this, "onMousePress");
    let currentPayload = { clientX: 0, clientY: 0 };
    const [setDown, getDown] = store(false);
    this.createEffect(() => {
      const cb = this.onMousePress;
      if (!getDown() || !cb)
        return;
      const handle = onBeforeRender(() => cb(currentPayload));
      return () => {
        handle.cancel();
      };
    }, [getDown]);
    this.createEffect(() => {
      if (getEditorActive() && getSelectionBlockMouse())
        return;
      const handle0 = mouseEvents.on("move", (e) => {
        var _a;
        (_a = this.onMouseMove) == null ? void 0 : _a.call(this, e);
        currentPayload = e;
      });
      const handle1 = mouseEvents.on("click", (e) => {
        var _a;
        (_a = this.onClick) == null ? void 0 : _a.call(this, e);
        currentPayload = e;
      });
      const handle2 = mouseEvents.on("rightClick", (e) => {
        var _a;
        (_a = this.onRightClick) == null ? void 0 : _a.call(this, e);
        currentPayload = e;
      });
      const handle3 = mouseEvents.on("down", (e) => {
        var _a;
        (_a = this.onMouseDown) == null ? void 0 : _a.call(this, e);
        currentPayload = e;
        setDown(true);
      });
      const handle4 = mouseEvents.on("up", (e) => {
        var _a;
        (_a = this.onMouseUp) == null ? void 0 : _a.call(this, e);
        currentPayload = e;
        setDown(false);
      });
      return () => {
        handle0.cancel();
        handle1.cancel();
        handle2.cancel();
        handle3.cancel();
        handle4.cancel();
      };
    }, [getEditorActive, getSelectionBlockMouse]);
  }
};
__publicField(Mouse, "componentName", "mouse");
__publicField(Mouse, "defaults", mouseDefaults);
__publicField(Mouse, "schema", mouseSchema);
var mouse = new Mouse();
appendableRoot.delete(mouse);
var mouse_default = mouse;

export {
  setExposure,
  getExposure,
  setPBR,
  getPBR,
  setSecondaryCamera,
  getSecondaryCamera,
  setAutoMount,
  getAutoMount,
  emitEditorMountChange,
  setPixelRatio,
  getPixelRatio,
  getPixelRatioComputed,
  container,
  LingoMouseEvent,
  setSelectionBlockMouse,
  getSelectionBlockMouse,
  setPickingMode,
  clientToWorld_default,
  mouseEvents,
  Mouse,
  mouse_default
};
//# sourceMappingURL=chunk-NMHDQJPG.js.map
