import {
  LingoMouseEvent,
  container,
  getSelectionBlockMouse,
  mouseEvents
} from "./chunk-NMHDQJPG.js";
import {
  box3,
  frustum,
  matrix4,
  ray,
  vector3,
  vector3_1,
  vector3_half
} from "./chunk-NPOYVG57.js";
import {
  cannonContactBodies,
  cannonContactMap,
  loadCannon_default,
  loadTexture_default,
  scene_default
} from "./chunk-VAFQCDDA.js";
import {
  EventLoopItem,
  appendableRoot,
  eventLoopDefaults,
  eventLoopSchema,
  getRenderer,
  hideSchema,
  onSceneGraphChange
} from "./chunk-MO2ISMHQ.js";
import {
  HEIGHT,
  WIDTH,
  getCameraRendered,
  getResolution,
  getSelection,
  getWorldPosition_default,
  getWorldQuaternion_default,
  mainCamera_default,
  onAfterRender,
  onBeforeRender,
  scaleDown,
  scaleUp
} from "./chunk-J7HA7FW3.js";
import {
  Cancellable,
  Disposable,
  Reactive,
  applyMixins,
  assertExhaustive,
  createEffect,
  createNestedEffect,
  createRef,
  debounce,
  event_default,
  forceGet,
  pull,
  pull2,
  push,
  reset,
  store,
  throttle
} from "./chunk-NXCTIVNA.js";
import {
  AddEquation,
  AdditiveBlending,
  AnimationClip,
  AnimationMixer,
  Bone,
  Box3,
  BufferGeometry,
  Clock,
  Color,
  DepthTexture,
  DoubleSide,
  Float32BufferAttribute,
  Group,
  HalfFloatType,
  LoopOnce,
  LoopRepeat,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshNormalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  NearestFilter,
  NoBlending,
  NormalBlending,
  NumberKeyframeTrack,
  ObjectSpaceNormalMap,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  PropertyBinding,
  RGBADepthPacking,
  Ray,
  Raycaster,
  RepeatWrapping,
  ShaderMaterial,
  SrcAlphaFactor,
  TangentSpaceNormalMap,
  UniformsUtils,
  UnsignedShortType,
  Vector2,
  Vector3,
  VideoTexture,
  WebGLRenderTarget
} from "./chunk-57VJUUAA.js";
import {
  __publicField
} from "./chunk-XA4H47DG.js";

// node_modules/@lincode/math/lib/index.js
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var Point3d = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
};
var rad2Deg = 180 / Math.PI;
var deg2Rad = Math.PI / 180;
var distance = (x0, y0, x1, y1) => {
  return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);
};
var distance3d = (x0, y0, z0, x1, y1, z1) => {
  return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2);
};
var rotatePoint = (pt, origin, theta) => {
  const rad = theta * deg2Rad;
  const deltaX = pt.x - origin.x;
  const deltaY = pt.y - origin.y;
  const rotatedX = deltaX * Math.cos(rad) - deltaY * Math.sin(rad);
  const rotatedY = deltaX * Math.sin(rad) + deltaY * Math.cos(rad);
  return new Point(rotatedX + origin.x, rotatedY + origin.y);
};
var endPoint = (x, y, theta, dist) => {
  const rad = theta *= deg2Rad;
  return new Point(x + dist * Math.cos(rad), y + dist * Math.sin(rad));
};

// node_modules/lingo3d/lib/display/utils/vec2Point.js
var vec2Point = (vec) => new Point3d(vec.x * scaleUp, vec.y * scaleUp, vec.z * scaleUp);
var point2Vec = (point) => new Vector3(point.x * scaleDown, point.y * scaleDown, point.z * scaleDown);

// node_modules/lingo3d/lib/api/core/PositionedItem.js
var PositionedItem = class extends EventLoopItem {
  get x() {
    return this.outerObject3d.position.x * scaleUp;
  }
  set x(val) {
    this.outerObject3d.position.x = val * scaleDown;
  }
  get y() {
    return this.outerObject3d.position.y * scaleUp;
  }
  set y(val) {
    this.outerObject3d.position.y = val * scaleDown;
  }
  get z() {
    return this.outerObject3d.position.z * scaleUp;
  }
  set z(val) {
    this.outerObject3d.position.z = val * scaleDown;
  }
  getWorldPosition() {
    return vec2Point(getWorldPosition_default(getObject3d(this)));
  }
};
var isPositionedItem = (item) => item instanceof EventLoopItem && "getWorldPosition" in item;

// node_modules/lingo3d/lib/states/useSelectionLocked.js
var [setSelectionLocked, getSelectionLocked] = store(false);

// node_modules/lingo3d/lib/states/useSelectionTarget.js
var [_setSelectionTarget, getSelectionTarget] = store(void 0);
var setSelectionTarget = (target) => {
  !getSelectionLocked() && _setSelectionTarget(target);
};

// node_modules/lingo3d/lib/states/useMultipleSelection.js
var [setMultipleSelection, getMultipleSelection] = store(false);

// node_modules/lingo3d/lib/states/useMultipleSelectionTargets.js
var [setMultipleSelectionTargets, getMultipleSelectionTargets] = store([]);
var pushMultipleSelectionTargets = push(setMultipleSelectionTargets, getMultipleSelectionTargets);
var pullMultipleSelectionTargets = pull2(setMultipleSelectionTargets, getMultipleSelectionTargets);
var resetMultipleSelectionTargets = reset(setMultipleSelectionTargets, getMultipleSelectionTargets);
var multipleSelectionGroupManagers = /* @__PURE__ */ new WeakSet();

// node_modules/lingo3d/lib/events/onSelectionTarget.js
var [_emitSelectionTarget, onSelectionTarget] = event_default();
var emitSelectionTarget = debounce((target, rightClick) => !getSelectionLocked() && _emitSelectionTarget({ target, rightClick }), 0, "trailing");
getCameraRendered(() => emitSelectionTarget());
createEffect(() => {
  const target = getSelectionTarget();
  if (!target)
    return;
  const handle = onSceneGraphChange(() => {
    !target.outerObject3d.parent && emitSelectionTarget();
  });
  return () => {
    handle.cancel();
  };
}, [getSelectionTarget]);

// node_modules/lingo3d/lib/states/useTransformControlsDragging.js
var [setTransformControlsDragging, getTransformControlsDragging] = store(false);

// node_modules/lingo3d/lib/events/onSelectionRecompute.js
var [emitSelectionRecompute, onSelectionRecompute] = event_default();

// node_modules/lingo3d/lib/states/useSelectionFrozen.js
var [setSelectionFrozen, getSelectionFrozen] = store([/* @__PURE__ */ new Set()]);
var addSelectionFrozen = (item) => {
  const [frozenSet] = getSelectionFrozen();
  frozenSet.add(item);
  setSelectionFrozen([frozenSet]);
  emitSelectionRecompute();
};
var clearSelectionFrozen = () => {
  const [frozenSet] = getSelectionFrozen();
  frozenSet.clear();
  setSelectionFrozen([frozenSet]);
  emitSelectionRecompute();
};

// node_modules/lingo3d/lib/display/core/StaticObjectManager/raycast.js
var raycaster = new Raycaster();
var selectionCandidates = /* @__PURE__ */ new Set();
var getSelectionCandidates = debounce(() => {
  const [frozenSet] = getSelectionFrozen();
  selectionCandidates.clear();
  scene_default.traverse((c) => {
    const { manager } = c.userData;
    manager && !frozenSet.has(manager) && selectionCandidates.add(getObject3d(manager));
  });
}, 0, "trailing");
var raycast = (x, y, candidates) => {
  raycaster.setFromCamera({ x, y }, getCameraRendered());
  return raycaster.intersectObjects([...candidates])[0];
};
var pickable = (name, candidates, then) => mouseEvents.on(name, (e) => {
  if (!candidates.size)
    return;
  const result = raycast(e.xNorm, e.yNorm, candidates);
  if (!result)
    return;
  const point = vec2Point(result.point);
  const distance2 = result.distance * scaleUp;
  then(result.object.userData.manager, new LingoMouseEvent(e.clientX, e.clientY, e.x, e.y, e.z, e.xNorm, e.yNorm, point, distance2));
});
var clickSet = /* @__PURE__ */ new Set();
var mouseDownSet = /* @__PURE__ */ new Set();
var mouseUpSet = /* @__PURE__ */ new Set();
var mouseOverSet = /* @__PURE__ */ new Set();
var mouseOutSet = /* @__PURE__ */ new Set();
var mouseMoveSet = /* @__PURE__ */ new Set();
var enableMouseEvents = () => {
  const handle = new Cancellable();
  handle.watch(pickable("click", clickSet, (obj, e) => {
    var _a;
    return (_a = obj.onClick) == null ? void 0 : _a.call(obj, e);
  }));
  handle.watch(pickable("down", mouseDownSet, (obj, e) => {
    var _a;
    return (_a = obj.onMouseDown) == null ? void 0 : _a.call(obj, e);
  }));
  handle.watch(pickable("up", mouseUpSet, (obj, e) => {
    var _a;
    return (_a = obj.onMouseUp) == null ? void 0 : _a.call(obj, e);
  }));
  let moveSet = /* @__PURE__ */ new Set();
  let moveSetOld = /* @__PURE__ */ new Set();
  handle.watch(pickable("move", mouseOverSet, (obj, e) => {
    moveSet.add(obj);
    obj.outerObject3d.userData.eMove = e;
  }));
  handle.watch(pickable("move", mouseOutSet, (obj, e) => {
    moveSet.add(obj);
    obj.outerObject3d.userData.eMove = e;
  }));
  handle.watch(pickable("move", mouseMoveSet, (obj, e) => {
    moveSet.add(obj);
    obj.outerObject3d.userData.eMove = e;
  }));
  handle.watch(mouseEvents.on("move", () => {
    var _a, _b, _c;
    for (const obj of moveSet) {
      if (!moveSetOld.has(obj))
        (_a = obj.onMouseOver) == null ? void 0 : _a.call(obj, obj.outerObject3d.userData.eMove);
      (_b = obj.onMouseMove) == null ? void 0 : _b.call(obj, obj.outerObject3d.userData.eMove);
    }
    for (const obj of moveSetOld)
      if (!moveSet.has(obj))
        (_c = obj.onMouseOut) == null ? void 0 : _c.call(obj, obj.outerObject3d.userData.eMove);
    moveSetOld = moveSet;
    moveSet = /* @__PURE__ */ new Set();
  }));
  return handle;
};
createEffect(() => {
  const selection = getSelection() && getCameraRendered() === mainCamera_default;
  const multipleSelection = getMultipleSelection();
  const firstMultipleSelection = createRef(true);
  createNestedEffect(() => {
    !multipleSelection && (firstMultipleSelection.current = true);
  }, [multipleSelection]);
  if (selection && !getTransformControlsDragging()) {
    const handle2 = new Cancellable();
    getSelectionCandidates();
    handle2.watch(onSceneGraphChange(getSelectionCandidates));
    handle2.watch(onSelectionRecompute(() => (getSelectionCandidates(), emitSelectionTarget())));
    handle2.watch(mouseEvents.on("click", () => emitSelectionTarget()));
    let rightClick = false;
    handle2.watch(mouseEvents.on("rightClick", () => {
      rightClick = true;
      queueMicrotask(() => {
        if (!rightClick)
          return;
        rightClick = false;
        emitSelectionTarget(void 0, true);
      });
    }));
    handle2.watch(pickable(["click", "rightClick"], selectionCandidates, (target) => {
      emitSelectionTarget(target, rightClick);
      rightClick = false;
    }));
    handle2.watch(onSelectionTarget(({ target, rightClick: rightClick2 }) => {
      if (multipleSelection) {
        if (!isPositionedItem(target) || rightClick2)
          return;
        if (firstMultipleSelection.current) {
          const currentTarget = getSelectionTarget();
          isPositionedItem(currentTarget) && pushMultipleSelectionTargets(currentTarget);
        }
        firstMultipleSelection.current = false;
        if (getMultipleSelectionTargets().includes(target))
          pullMultipleSelectionTargets(target);
        else
          pushMultipleSelectionTargets(target);
        return;
      }
      resetMultipleSelectionTargets();
      setSelectionTarget(rightClick2 ? target : target === getSelectionTarget() ? void 0 : target);
    }));
    if (!multipleSelection && !getSelectionBlockMouse())
      handle2.watch(enableMouseEvents());
    return () => {
      handle2.cancel();
    };
  }
  if (selection)
    return;
  resetMultipleSelectionTargets();
  setSelectionTarget(void 0);
  const handle = enableMouseEvents();
  return () => {
    handle.cancel();
  };
}, [getSelection, getSelectionBlockMouse, getTransformControlsDragging, getCameraRendered, getMultipleSelection]);

// node_modules/three/examples/jsm/math/OBB.js
var a = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var b = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var R = [[], [], []];
var AbsR = [[], [], []];
var t = [];
var xAxis = new Vector3();
var yAxis = new Vector3();
var zAxis = new Vector3();
var v1 = new Vector3();
var size = new Vector3();
var closestPoint = new Vector3();
var rotationMatrix = new Matrix3();
var aabb = new Box3();
var matrix = new Matrix4();
var inverse = new Matrix4();
var localRay = new Ray();
var OBB = class {
  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {
    this.center = center;
    this.halfSize = halfSize;
    this.rotation = rotation;
  }
  set(center, halfSize, rotation) {
    this.center = center;
    this.halfSize = halfSize;
    this.rotation = rotation;
    return this;
  }
  copy(obb2) {
    this.center.copy(obb2.center);
    this.halfSize.copy(obb2.halfSize);
    this.rotation.copy(obb2.rotation);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  getSize(result) {
    return result.copy(this.halfSize).multiplyScalar(2);
  }
  clampPoint(point, result) {
    const halfSize = this.halfSize;
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    result.copy(this.center);
    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
    result.add(xAxis.multiplyScalar(x));
    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
    result.add(yAxis.multiplyScalar(y));
    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
    result.add(zAxis.multiplyScalar(z));
    return result;
  }
  containsPoint(point) {
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
  }
  intersectsBox3(box32) {
    return this.intersectsOBB(obb.fromBox3(box32));
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsOBB(obb2, epsilon = Number.EPSILON) {
    a.c = this.center;
    a.e[0] = this.halfSize.x;
    a.e[1] = this.halfSize.y;
    a.e[2] = this.halfSize.z;
    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);
    b.c = obb2.center;
    b.e[0] = obb2.halfSize.x;
    b.e[1] = obb2.halfSize.y;
    b.e[2] = obb2.halfSize.z;
    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        R[i][j] = a.u[i].dot(b.u[j]);
      }
    }
    v1.subVectors(b.c, a.c);
    t[0] = v1.dot(a.u[0]);
    t[1] = v1.dot(a.u[1]);
    t[2] = v1.dot(a.u[2]);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;
      }
    }
    let ra, rb;
    for (let i = 0; i < 3; i++) {
      ra = a.e[i];
      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];
      if (Math.abs(t[i]) > ra + rb)
        return false;
    }
    for (let i = 0; i < 3; i++) {
      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];
      rb = b.e[i];
      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb)
        return false;
    }
    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb)
      return false;
    return true;
  }
  intersectsPlane(plane) {
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
    const d = plane.normal.dot(this.center) - plane.constant;
    return Math.abs(d) <= r;
  }
  intersectRay(ray2, result) {
    this.getSize(size);
    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
    matrix.setFromMatrix3(this.rotation);
    matrix.setPosition(this.center);
    inverse.copy(matrix).invert();
    localRay.copy(ray2).applyMatrix4(inverse);
    if (localRay.intersectBox(aabb, result)) {
      return result.applyMatrix4(matrix);
    } else {
      return null;
    }
  }
  intersectsRay(ray2) {
    return this.intersectRay(ray2, v1) !== null;
  }
  fromBox3(box32) {
    box32.getCenter(this.center);
    box32.getSize(this.halfSize).multiplyScalar(0.5);
    this.rotation.identity();
    return this;
  }
  equals(obb2) {
    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
  }
  applyMatrix4(matrix2) {
    const e = matrix2.elements;
    let sx = v1.set(e[0], e[1], e[2]).length();
    const sy = v1.set(e[4], e[5], e[6]).length();
    const sz = v1.set(e[8], e[9], e[10]).length();
    const det = matrix2.determinant();
    if (det < 0)
      sx = -sx;
    rotationMatrix.setFromMatrix4(matrix2);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    rotationMatrix.elements[0] *= invSX;
    rotationMatrix.elements[1] *= invSX;
    rotationMatrix.elements[2] *= invSX;
    rotationMatrix.elements[3] *= invSY;
    rotationMatrix.elements[4] *= invSY;
    rotationMatrix.elements[5] *= invSY;
    rotationMatrix.elements[6] *= invSZ;
    rotationMatrix.elements[7] *= invSZ;
    rotationMatrix.elements[8] *= invSZ;
    this.rotation.multiply(rotationMatrix);
    this.halfSize.x *= sx;
    this.halfSize.y *= sy;
    this.halfSize.z *= sz;
    v1.setFromMatrixPosition(matrix2);
    this.center.add(v1);
    return this;
  }
};
var obb = new OBB();

// node_modules/three/examples/jsm/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var Pass = class {
  constructor() {
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry = new BufferGeometry();
_geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var FullScreenQuad = class {
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
};

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  constructor(shader, textureID) {
    super();
    this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
};

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    if (renderTarget === void 0) {
      const size2 = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    if (CopyShader === void 0) {
      console.error("THREE.EffectComposer relies on CopyShader");
    }
    if (ShaderPass === void 0) {
      console.error("THREE.EffectComposer relies on ShaderPass");
    }
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size2 = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
};
var _camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry2 = new BufferGeometry();
_geometry2.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry2.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));

// node_modules/lingo3d/lib/states/useSelectiveBloomComposer.js
var [setSelectiveBloomComposer, getSelectiveBloomComposer] = store(void 0);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  const selectiveBloomComposer = new EffectComposer(renderer);
  selectiveBloomComposer.renderToScreen = false;
  setSelectiveBloomComposer(selectiveBloomComposer);
}, [getRenderer]);
createEffect(() => {
  const selectiveBloomComposer = getSelectiveBloomComposer();
  if (!selectiveBloomComposer)
    return;
  const [w, h] = getResolution();
  selectiveBloomComposer.setSize(w, h);
  selectiveBloomComposer.setPixelRatio(1);
}, [getSelectiveBloomComposer, getResolution]);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/selectiveBloomPass/renderSelectiveBloom.js
var bloomPtr = [false];
var addBloom = (target) => {
  target.userData.bloom = true;
  bloomPtr[0] = true;
};
var deleteBloom = (target) => {
  target.userData.bloom = false;
};
var sceneBackground;
var darkenRecursive = (children) => {
  for (const child of children) {
    if (child.userData.bloom) {
      child.renderOrder = 1;
      continue;
    }
    if (!child.visible)
      continue;
    darkenRecursive(child.children);
    child.material && (child.material.colorWrite = false);
    child.renderOrder = 0;
  }
};
var darken = () => {
  darkenRecursive(scene_default.children);
  if (scene_default.background) {
    sceneBackground = scene_default.background;
    scene_default.background = null;
  }
};
var restoreRecursive = (child) => child.material && (child.material.colorWrite = true);
var restore = () => {
  scene_default.traverse(restoreRecursive);
  sceneBackground && (scene_default.background = sceneBackground);
};
var renderSelectiveBloom_default = () => {
  var _a;
  darken();
  (_a = getSelectiveBloomComposer()) == null ? void 0 : _a.render();
  restore();
};

// node_modules/lingo3d/lib/display/utils/getCenter.js
var cache = /* @__PURE__ */ new WeakMap();
var getCenter_default = (object) => {
  if (cache.has(object))
    return cache.get(object).clone();
  const result = object instanceof Bone ? getWorldPosition_default(object) : box3.setFromObject(object).getCenter(new Vector3());
  cache.set(object, result.clone());
  onAfterRender(() => cache.delete(object), true);
  return result;
};

// node_modules/lingo3d/lib/display/utils/worldToClient.js
var cache2 = /* @__PURE__ */ new WeakMap();
var worldToClient_default = (object3d) => {
  if (cache2.has(object3d))
    return cache2.get(object3d);
  const center = getCenter_default(object3d);
  const camera = getCameraRendered();
  center.project(camera);
  const x = (center.x * 0.5 + 0.5) * container.clientWidth;
  const y = (center.y * -0.5 + 0.5) * container.clientHeight;
  const result = { x, y };
  cache2.set(object3d, result);
  onAfterRender(() => cache2.delete(object3d), true);
  return result;
};

// node_modules/three/examples/jsm/shaders/SSRShader.js
var SSRShader = {
  defines: {
    MAX_STEP: 0,
    PERSPECTIVE_CAMERA: true,
    DISTANCE_ATTENUATION: true,
    FRESNEL: true,
    INFINITE_THICK: false,
    SELECTIVE: false
  },
  uniforms: {
    "tDiffuse": { value: null },
    "tNormal": { value: null },
    "tMetalness": { value: null },
    "tDepth": { value: null },
    "cameraNear": { value: null },
    "cameraFar": { value: null },
    "resolution": { value: new Vector2() },
    "cameraProjectionMatrix": { value: new Matrix4() },
    "cameraInverseProjectionMatrix": { value: new Matrix4() },
    "opacity": { value: 0.5 },
    "maxDistance": { value: 180 },
    "cameraRange": { value: 0 },
    "thickness": { value: 0.018 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,
  fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	`
};
var SSRDepthShader = {
  defines: {
    "PERSPECTIVE_CAMERA": 1
  },
  uniforms: {
    "tDepth": { value: null },
    "cameraNear": { value: null },
    "cameraFar": { value: null }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,
  fragmentShader: `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`
};
var SSRBlurShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "resolution": { value: new Vector2() },
    "opacity": { value: 0.5 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
};

// node_modules/three/examples/jsm/postprocessing/SSRPass.js
var SSRPass = class extends Pass {
  constructor({ renderer, scene, camera, width, height, selects, bouncing = false, groundReflector }) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.groundReflector = groundReflector;
    this.opacity = SSRShader.uniforms.opacity.value;
    this.output = 0;
    this.maxDistance = SSRShader.uniforms.maxDistance.value;
    this.thickness = SSRShader.uniforms.thickness.value;
    this.tempColor = new Color();
    this._selects = selects;
    this.selective = Array.isArray(this._selects);
    Object.defineProperty(this, "selects", {
      get() {
        return this._selects;
      },
      set(val) {
        if (this._selects === val)
          return;
        this._selects = val;
        if (Array.isArray(val)) {
          this.selective = true;
          this.ssrMaterial.defines.SELECTIVE = true;
          this.ssrMaterial.needsUpdate = true;
        } else {
          this.selective = false;
          this.ssrMaterial.defines.SELECTIVE = false;
          this.ssrMaterial.needsUpdate = true;
        }
      }
    });
    this._bouncing = bouncing;
    Object.defineProperty(this, "bouncing", {
      get() {
        return this._bouncing;
      },
      set(val) {
        if (this._bouncing === val)
          return;
        this._bouncing = val;
        if (val) {
          this.ssrMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
        } else {
          this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        }
      }
    });
    this.blur = true;
    this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(this, "distanceAttenuation", {
      get() {
        return this._distanceAttenuation;
      },
      set(val) {
        if (this._distanceAttenuation === val)
          return;
        this._distanceAttenuation = val;
        this.ssrMaterial.defines.DISTANCE_ATTENUATION = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    this._fresnel = SSRShader.defines.FRESNEL;
    Object.defineProperty(this, "fresnel", {
      get() {
        return this._fresnel;
      },
      set(val) {
        if (this._fresnel === val)
          return;
        this._fresnel = val;
        this.ssrMaterial.defines.FRESNEL = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    this._infiniteThick = SSRShader.defines.INFINITE_THICK;
    Object.defineProperty(this, "infiniteThick", {
      get() {
        return this._infiniteThick;
      },
      set(val) {
        if (this._infiniteThick === val)
          return;
        this._infiniteThick = val;
        this.ssrMaterial.defines.INFINITE_THICK = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    const depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    depthTexture.minFilter = NearestFilter;
    depthTexture.magFilter = NearestFilter;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthTexture,
      depthBuffer: true
    });
    this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.blurRenderTarget = this.ssrRenderTarget.clone();
    this.blurRenderTarget2 = this.ssrRenderTarget.clone();
    if (SSRShader === void 0) {
      console.error("THREE.SSRPass: The pass relies on SSRShader.");
    }
    this.ssrMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRShader.defines, {
        MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height)
      }),
      uniforms: UniformsUtils.clone(SSRShader.uniforms),
      vertexShader: SSRShader.vertexShader,
      fragmentShader: SSRShader.fragmentShader,
      blending: NoBlending
    });
    this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssrMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssrMaterial.defines.SELECTIVE = this.selective;
    this.ssrMaterial.needsUpdate = true;
    this.ssrMaterial.uniforms["tMetalness"].value = this.metalnessRenderTarget.texture;
    this.ssrMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
    this.ssrMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssrMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssrMaterial.uniforms["thickness"].value = this.thickness;
    this.ssrMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.metalnessOnMaterial = new MeshBasicMaterial({
      color: "white"
    });
    this.metalnessOffMaterial = new MeshBasicMaterial({
      color: "black"
    });
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRBlurShader.defines),
      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
      vertexShader: SSRBlurShader.vertexShader,
      fragmentShader: SSRBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.blurMaterial2 = new ShaderMaterial({
      defines: Object.assign({}, SSRBlurShader.defines),
      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
      vertexShader: SSRBlurShader.vertexShader,
      fragmentShader: SSRBlurShader.fragmentShader
    });
    this.blurMaterial2.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
    this.blurMaterial2.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRDepthShader.defines),
      uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),
      vertexShader: SSRDepthShader.vertexShader,
      fragmentShader: SSRDepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: SrcAlphaFactor,
      blendDst: OneMinusSrcAlphaFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: SrcAlphaFactor,
      blendDstAlpha: OneMinusSrcAlphaFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.prevRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.metalnessRenderTarget.dispose();
    this.ssrRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.blurRenderTarget2.dispose();
    this.normalMaterial.dispose();
    this.metalnessOnMaterial.dispose();
    this.metalnessOffMaterial.dispose();
    this.blurMaterial.dispose();
    this.blurMaterial2.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    if (this.groundReflector) {
      this.groundReflector.visible = false;
      this.groundReflector.doRender(this.renderer, this.scene, this.camera);
      this.groundReflector.visible = true;
    }
    renderer.render(this.scene, this.camera);
    if (this.groundReflector)
      this.groundReflector.visible = false;
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0);
    if (this.selective) {
      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);
    }
    this.ssrMaterial.uniforms["opacity"].value = this.opacity;
    this.ssrMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.ssrMaterial.uniforms["thickness"].value = this.thickness;
    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget);
    if (this.blur) {
      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2);
    }
    switch (this.output) {
      case SSRPass.OUTPUT.Default:
        if (this.bouncing) {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        } else {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        }
        break;
      case SSRPass.OUTPUT.SSR:
        if (this.blur)
          this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
        else
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        if (this.bouncing) {
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
        }
        break;
      case SSRPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Metalness:
        this.copyMaterial.uniforms["tDiffuse"].value = this.metalnessRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderMetalness(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.traverseVisible((child) => {
      child._SSRPassBackupMaterial = child.material;
      if (this._selects.includes(child)) {
        child.material = this.metalnessOnMaterial;
      } else {
        child.material = this.metalnessOffMaterial;
      }
    });
    renderer.render(this.scene, this.camera);
    this.scene.traverseVisible((child) => {
      child.material = child._SSRPassBackupMaterial;
    });
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);
    this.ssrMaterial.needsUpdate = true;
    this.beautyRenderTarget.setSize(width, height);
    this.prevRenderTarget.setSize(width, height);
    this.ssrRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.metalnessRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.blurRenderTarget2.setSize(width, height);
    this.ssrMaterial.uniforms["resolution"].value.set(width, height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
    this.blurMaterial2.uniforms["resolution"].value.set(width, height);
  }
};
SSRPass.OUTPUT = {
  "Default": 0,
  "SSR": 1,
  "Beauty": 3,
  "Depth": 4,
  "Normal": 5,
  "Metalness": 7
};

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/ssrPass.js
var ssrPtr = [false];
var ssrSelects = [];
var addSSR = (target) => {
  if (target.userData.ssr)
    return;
  target.userData.ssr = true;
  ssrSelects.push(target);
  ssrPtr[0] = true;
};
var deleteSSR = (target) => {
  if (!target.userData.ssr)
    return;
  target.userData.ssr = false;
  pull(ssrSelects, target);
};
var ssrPass = new SSRPass({
  renderer: void 0,
  scene: scene_default,
  camera: getCameraRendered(),
  width: WIDTH,
  height: HEIGHT,
  groundReflector: null,
  selects: ssrSelects
});
var ssrPass_default = ssrPass;
getRenderer((renderer) => renderer && (ssrPass.renderer = renderer));
getCameraRendered((camera) => ssrPass.camera = camera);

// node_modules/three/examples/jsm/postprocessing/OutlinePass.js
var OutlinePass = class extends Pass {
  constructor(resolution, scene, camera, selectedObjects) {
    super();
    this.renderScene = scene;
    this.renderCamera = camera;
    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];
    this.visibleEdgeColor = new Color(1, 1, 1);
    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);
    this.edgeGlow = 0;
    this.usePatternTexture = false;
    this.edgeThickness = 1;
    this.edgeStrength = 3;
    this.downSampleRatio = 2;
    this.pulsePeriod = 0;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    const resx = Math.round(this.resolution.x / this.downSampleRatio);
    const resy = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
    this.renderTargetMaskBuffer.texture.generateMipmaps = false;
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.side = DoubleSide;
    this.depthMaterial.depthPacking = RGBADepthPacking;
    this.depthMaterial.blending = NoBlending;
    this.prepareMaskMaterial = this.getPrepareMaskMaterial();
    this.prepareMaskMaterial.side = DoubleSide;
    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);
    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
    this.renderTargetDepthBuffer.texture.generateMipmaps = false;
    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);
    this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;
    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);
    this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
    this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;
    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);
    this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
    this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
    const MAX_EDGE_THICKNESS = 4;
    const MAX_EDGE_GLOW = 4;
    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
    this.separableBlurMaterial1.uniforms["texSize"].value.set(resx, resy);
    this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
    this.separableBlurMaterial2.uniforms["texSize"].value.set(Math.round(resx / 2), Math.round(resy / 2));
    this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;
    this.overlayMaterial = this.getOverlayMaterial();
    if (CopyShader === void 0)
      console.error("THREE.OutlinePass relies on CopyShader");
    const copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.fsQuad = new FullScreenQuad(null);
    this.tempPulseColor1 = new Color();
    this.tempPulseColor2 = new Color();
    this.textureMatrix = new Matrix4();
    function replaceDepthToViewZ(string, camera2) {
      const type = camera2.isPerspectiveCamera ? "perspective" : "orthographic";
      return string.replace(/DEPTH_TO_VIEW_Z/g, type + "DepthToViewZ");
    }
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose();
    this.renderTargetDepthBuffer.dispose();
    this.renderTargetMaskDownSampleBuffer.dispose();
    this.renderTargetBlurBuffer1.dispose();
    this.renderTargetBlurBuffer2.dispose();
    this.renderTargetEdgeBuffer1.dispose();
    this.renderTargetEdgeBuffer2.dispose();
  }
  setSize(width, height) {
    this.renderTargetMaskBuffer.setSize(width, height);
    this.renderTargetDepthBuffer.setSize(width, height);
    let resx = Math.round(width / this.downSampleRatio);
    let resy = Math.round(height / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
    this.renderTargetBlurBuffer1.setSize(resx, resy);
    this.renderTargetEdgeBuffer1.setSize(resx, resy);
    this.separableBlurMaterial1.uniforms["texSize"].value.set(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
    this.renderTargetBlurBuffer2.setSize(resx, resy);
    this.renderTargetEdgeBuffer2.setSize(resx, resy);
    this.separableBlurMaterial2.uniforms["texSize"].value.set(resx, resy);
  }
  changeVisibilityOfSelectedObjects(bVisible) {
    const cache4 = this._visibilityCache;
    function gatherSelectedMeshesCallBack(object) {
      if (object.isMesh) {
        if (bVisible === true) {
          object.visible = cache4.get(object);
        } else {
          cache4.set(object, object.visible);
          object.visible = bVisible;
        }
      }
    }
    for (let i = 0; i < this.selectedObjects.length; i++) {
      const selectedObject = this.selectedObjects[i];
      selectedObject.traverse(gatherSelectedMeshesCallBack);
    }
  }
  changeVisibilityOfNonSelectedObjects(bVisible) {
    const cache4 = this._visibilityCache;
    const selectedMeshes = [];
    function gatherSelectedMeshesCallBack(object) {
      if (object.isMesh)
        selectedMeshes.push(object);
    }
    for (let i = 0; i < this.selectedObjects.length; i++) {
      const selectedObject = this.selectedObjects[i];
      selectedObject.traverse(gatherSelectedMeshesCallBack);
    }
    function VisibilityChangeCallBack(object) {
      if (object.isMesh || object.isSprite) {
        let bFound = false;
        for (let i = 0; i < selectedMeshes.length; i++) {
          const selectedObjectId = selectedMeshes[i].id;
          if (selectedObjectId === object.id) {
            bFound = true;
            break;
          }
        }
        if (bFound === false) {
          const visibility = object.visible;
          if (bVisible === false || cache4.get(object) === true) {
            object.visible = bVisible;
          }
          cache4.set(object, visibility);
        }
      } else if (object.isPoints || object.isLine) {
        if (bVisible === true) {
          object.visible = cache4.get(object);
        } else {
          cache4.set(object, object.visible);
          object.visible = bVisible;
        }
      }
    }
    this.renderScene.traverse(VisibilityChangeCallBack);
  }
  updateTextureMatrix() {
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (this.selectedObjects.length > 0) {
      renderer.getClearColor(this._oldClearColor);
      this.oldClearAlpha = renderer.getClearAlpha();
      const oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      if (maskActive)
        renderer.state.buffers.stencil.setTest(false);
      renderer.setClearColor(16777215, 1);
      this.changeVisibilityOfSelectedObjects(false);
      const currentBackground = this.renderScene.background;
      this.renderScene.background = null;
      this.renderScene.overrideMaterial = this.depthMaterial;
      renderer.setRenderTarget(this.renderTargetDepthBuffer);
      renderer.clear();
      renderer.render(this.renderScene, this.renderCamera);
      this.changeVisibilityOfSelectedObjects(true);
      this._visibilityCache.clear();
      this.updateTextureMatrix();
      this.changeVisibilityOfNonSelectedObjects(false);
      this.renderScene.overrideMaterial = this.prepareMaskMaterial;
      this.prepareMaskMaterial.uniforms["cameraNearFar"].value.set(this.renderCamera.near, this.renderCamera.far);
      this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
      this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
      renderer.setRenderTarget(this.renderTargetMaskBuffer);
      renderer.clear();
      renderer.render(this.renderScene, this.renderCamera);
      this.renderScene.overrideMaterial = null;
      this.changeVisibilityOfNonSelectedObjects(true);
      this._visibilityCache.clear();
      this.renderScene.background = currentBackground;
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.tempPulseColor1.copy(this.visibleEdgeColor);
      this.tempPulseColor2.copy(this.hiddenEdgeColor);
      if (this.pulsePeriod > 0) {
        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;
        this.tempPulseColor1.multiplyScalar(scalar);
        this.tempPulseColor2.multiplyScalar(scalar);
      }
      this.fsQuad.material = this.edgeDetectionMaterial;
      this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
      this.edgeDetectionMaterial.uniforms["texSize"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
      this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
      this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.separableBlurMaterial1;
      this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
      this.separableBlurMaterial1.uniforms["direction"].value = OutlinePass.BlurDirectionX;
      this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
      renderer.setRenderTarget(this.renderTargetBlurBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
      this.separableBlurMaterial1.uniforms["direction"].value = OutlinePass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.separableBlurMaterial2;
      this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
      this.separableBlurMaterial2.uniforms["direction"].value = OutlinePass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetBlurBuffer2);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
      this.separableBlurMaterial2.uniforms["direction"].value = OutlinePass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.overlayMaterial;
      this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
      this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
      this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
      this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
      this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
      this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
      this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;
      if (maskActive)
        renderer.state.buffers.stencil.setTest(true);
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
      renderer.autoClear = oldAutoClear;
    }
    if (this.renderToScreen) {
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = readBuffer.texture;
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    }
  }
  getPrepareMaskMaterial() {
    return new ShaderMaterial({
      uniforms: {
        "depthTexture": { value: null },
        "cameraNearFar": { value: new Vector2(0.5, 0.5) },
        "textureMatrix": { value: null }
      },
      vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;
					vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
					projTexCoord = textureMatrix * worldPosition;

				}`,
      fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`
    });
  }
  getEdgeDetectionMaterial() {
    return new ShaderMaterial({
      uniforms: {
        "maskTexture": { value: null },
        "texSize": { value: new Vector2(0.5, 0.5) },
        "visibleEdgeColor": { value: new Vector3(1, 1, 1) },
        "hiddenEdgeColor": { value: new Vector3(1, 1, 1) }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
    });
  }
  getSeperableBlurMaterial(maxRadius) {
    return new ShaderMaterial({
      defines: {
        "MAX_RADIUS": maxRadius
      },
      uniforms: {
        "colorTexture": { value: null },
        "texSize": { value: new Vector2(0.5, 0.5) },
        "direction": { value: new Vector2(0.5, 0.5) },
        "kernelRadius": { value: 1 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float weightSum = gaussianPdf(0.0, kernelRadius);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float w = gaussianPdf(uvOffset.x, kernelRadius);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
    });
  }
  getOverlayMaterial() {
    return new ShaderMaterial({
      uniforms: {
        "maskTexture": { value: null },
        "edgeTexture1": { value: null },
        "edgeTexture2": { value: null },
        "patternTexture": { value: null },
        "edgeStrength": { value: 1 },
        "edgeGlow": { value: 1 },
        "usePatternTexture": { value: 0 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
  }
};
OutlinePass.BlurDirectionX = new Vector2(1, 0);
OutlinePass.BlurDirectionY = new Vector2(0, 1);

// node_modules/lingo3d/lib/states/useOutlineColor.js
var [setOutlineColor, getOutlineColor] = store("#ffffff");

// node_modules/lingo3d/lib/states/useOutlineHiddenColor.js
var [setOutlineHiddenColor, getOutlineHiddenColor] = store(void 0);

// node_modules/lingo3d/lib/states/useOutlinePattern.js
var [setOutlinePattern, getOutlinePattern] = store(void 0);

// node_modules/lingo3d/lib/states/useOutlinePulse.js
var [setOutlinePulse, getOutlinePulse] = store(0);

// node_modules/lingo3d/lib/states/useOutlineStrength.js
var [setOutlineStrength, getOutlineStrength] = store(3);

// node_modules/lingo3d/lib/states/useOutlineThickness.js
var [setOutlineThickness, getOutlineThickness] = store(1);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/outlinePass.js
var outlinePtr = [false];
var outlineSelects = [];
var addOutline = (target) => {
  if (target.userData.outline)
    return;
  target.userData.outline = true;
  outlineSelects.push(target);
  outlinePtr[0] = true;
};
var deleteOutline = (target) => {
  if (!target.userData.outline)
    return;
  target.userData.outline = false;
  pull(outlineSelects, target);
};
var outlinePass = new OutlinePass(new Vector2(), scene_default, getCameraRendered(), outlineSelects);
var outlinePass_default = outlinePass;
getCameraRendered((camera) => outlinePass.renderCamera = camera);
createEffect(() => {
  var _a;
  const color = getOutlineColor();
  const hiddenColor = (_a = getOutlineHiddenColor()) != null ? _a : color;
  outlinePass.visibleEdgeColor = new Color(color);
  outlinePass.hiddenEdgeColor = new Color(hiddenColor);
}, [getOutlineColor, getOutlineHiddenColor]);
createEffect(() => {
  const url = getOutlinePattern();
  if (!url)
    return;
  outlinePass.patternTexture = loadTexture_default(url);
  outlinePass.usePatternTexture = true;
  return () => {
    outlinePass.usePatternTexture = false;
  };
}, [getOutlinePattern]);
getOutlinePulse((pulse) => outlinePass.pulsePeriod = pulse * 1e-3);
getOutlineStrength((strength) => outlinePass.edgeStrength = strength);
getOutlineThickness((thickness) => outlinePass.edgeThickness = thickness);

// node_modules/lingo3d/lib/display/core/mixins/AnimationMixin/AnimationManager.js
var targetMixerMap = /* @__PURE__ */ new WeakMap();
var mixerActionMap = /* @__PURE__ */ new WeakMap();
var mixerHandleMap = /* @__PURE__ */ new WeakMap();
var dt = 1 / 60;
var AnimationManager = class extends Disposable {
  constructor(nameOrClip, target) {
    super();
    __publicField(this, "clip");
    __publicField(this, "name");
    __publicField(this, "mixer");
    __publicField(this, "action");
    this.mixer = forceGet(targetMixerMap, target, () => new AnimationMixer(target));
    if (typeof nameOrClip === "string")
      this.name = nameOrClip;
    else {
      this.name = nameOrClip.name;
      this.loadClip(nameOrClip);
    }
  }
  retarget(target) {
    const newClip = this.clip.clone();
    const targetName = target.name + ".";
    newClip.tracks = newClip.tracks.filter((track) => track.name.startsWith(targetName));
    return new AnimationManager(newClip, target);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.stop();
    return this;
  }
  get duration() {
    var _a, _b;
    return (_b = (_a = this.clip) == null ? void 0 : _a.duration) != null ? _b : 0;
  }
  loadClip(clip) {
    this.clip = clip;
    this.action = this.mixer.clipAction(clip);
  }
  setTracks(data) {
    const tracks = Object.entries(data).map(([property, frames]) => new NumberKeyframeTrack("." + property, Object.keys(frames).map((t2) => Number(t2)), Object.values(frames)));
    this.clip && this.mixer.uncacheClip(this.clip);
    this.loadClip(new AnimationClip(this.name, -1, tracks));
  }
  play({ crossFade = 0.25, repeat = true, onFinish } = {}) {
    var _a, _b;
    const [prevAction, prevRepeat] = (_a = mixerActionMap.get(this.mixer)) != null ? _a : [];
    if ((prevAction == null ? void 0 : prevAction.isRunning()) && this.action === prevAction) {
      repeat !== prevRepeat && prevAction.setLoop(repeat ? LoopRepeat : LoopOnce, Infinity);
      return;
    }
    (_b = mixerHandleMap.get(this.mixer)) == null ? void 0 : _b.cancel();
    const handle = this.watch(onBeforeRender(() => this.mixer.update(dt)));
    mixerHandleMap.set(this.mixer, handle);
    const { action } = this;
    if (!action)
      return;
    if (prevAction && crossFade) {
      action.time = 0;
      action.enabled = true;
      action.crossFadeFrom(prevAction, crossFade, true);
    } else
      this.mixer.stopAllAction();
    mixerActionMap.set(this.mixer, [action, repeat]);
    action.setLoop(repeat ? LoopRepeat : LoopOnce, Infinity);
    action.clampWhenFinished = true;
    const handleFinish = () => onFinish == null ? void 0 : onFinish();
    this.mixer.addEventListener("finished", handleFinish);
    handle.then(() => this.mixer.removeEventListener("finished", handleFinish));
    action.paused && action.stop();
    action.play();
  }
  stop() {
    var _a;
    this.action && (this.action.paused = true);
    (_a = mixerHandleMap.get(this.mixer)) == null ? void 0 : _a.cancel();
  }
  getPaused() {
    var _a;
    return (_a = this.action) == null ? void 0 : _a.paused;
  }
  setPaused(val) {
    this.action && (this.action.paused = val);
  }
  update(seconds) {
    this.mixer.time = 0;
    this.action && (this.action.time = 0);
    this.mixer.update(seconds);
  }
};

// node_modules/lingo3d/lib/display/core/mixins/AnimationMixin/index.js
var buildAnimationTracks = debounce((val) => {
  const entries = Object.entries(val);
  let maxLength = 0;
  for (const [, { length }] of entries)
    length > maxLength && (maxLength = length);
  const duration = 1e3;
  const timeStep = duration * 1e-3 / maxLength;
  const result = {};
  for (const [name, values] of entries)
    result[name] = Object.fromEntries(values.map((v, i) => [(i * timeStep).toFixed(2), v]));
  return result;
}, 0, "trailingPromise");
var AnimationMixin = class extends EventLoopItem {
  constructor() {
    super(...arguments);
    __publicField(this, "animationManagers");
    __publicField(this, "loadingAnims");
    __publicField(this, "animationManager");
    __publicField(this, "animationRepeat");
    __publicField(this, "onAnimationFinish");
    __publicField(this, "animationName");
    __publicField(this, "_animation");
  }
  get animations() {
    var _a;
    return (_a = this.animationManagers) != null ? _a : this.animationManagers = {};
  }
  set animations(val) {
    this.animationManagers = val;
  }
  createAnimation(name) {
    if (name in this.animations) {
      const animation2 = this.animations[name];
      if (typeof animation2 !== "string")
        return animation2;
    }
    const animation = this.watch(new AnimationManager(name, this));
    this.animations[name] = animation;
    return animation;
  }
  buildAnimation(val) {
    buildAnimationTracks(val).then((tracks) => {
      const name = "lingo3d-animation";
      this.createAnimation(name).setTracks(tracks);
      this.playAnimation(name);
    });
  }
  makeAnimationProxy(source) {
    return new Proxy(source, {
      get: (anim, prop) => {
        return anim[prop];
      },
      set: (anim, prop, value) => {
        anim[prop] = value;
        this.buildAnimation(anim);
        return true;
      }
    });
  }
  async loadingAnimsAsync() {
    await new Promise((resolve) => setTimeout(resolve));
    if (this.loadingAnims) {
      await Promise.all(this.loadingAnims);
      this.loadingAnims = void 0;
    }
  }
  get animationPaused() {
    var _a;
    return (_a = this.animationManager) == null ? void 0 : _a.getPaused();
  }
  set animationPaused(value) {
    this.loadingAnimsAsync().then(() => {
      var _a;
      if (this.done)
        return;
      (_a = this.animationManager) == null ? void 0 : _a.setPaused(!!value);
    });
  }
  async playAnimation(name, o) {
    var _a;
    await this.loadingAnimsAsync();
    if (this.done)
      return;
    this.animationManager = typeof name === "string" ? this.animations[name] : Object.values(this.animations)[name != null ? name : 0];
    (_a = this.animationManager) == null ? void 0 : _a.play(o);
  }
  async stopAnimation() {
    var _a;
    await this.loadingAnimsAsync();
    if (this.done)
      return;
    (_a = this.animationManager) == null ? void 0 : _a.stop();
  }
  setAnimation(val, o) {
    this._animation = val;
    if (typeof val === "string" || typeof val === "number") {
      this.animationName = val;
      this.playAnimation(val, o);
      return;
    }
    if (typeof val === "boolean") {
      val ? this.playAnimation(void 0, o) : this.stopAnimation();
      return;
    }
    if (!val) {
      this.stopAnimation();
      return;
    }
    this._animation = this.makeAnimationProxy(val);
    this.buildAnimation(val);
  }
  get animation() {
    return this._animation;
  }
  set animation(val) {
    if (Array.isArray(val)) {
      let currentIndex = 0;
      const o = {
        onFinish: () => {
          var _a;
          if (++currentIndex >= val.length) {
            if (this.animationRepeat === false) {
              (_a = this.onAnimationFinish) == null ? void 0 : _a.call(this);
              return;
            }
            currentIndex = 0;
          }
          this.setAnimation(val[currentIndex], o);
        },
        repeat: false
      };
      this.setAnimation(val[0], o);
      return;
    }
    this.queueMicrotask(() => this.setAnimation(val, {
      repeat: this.animationRepeat,
      onFinish: this.onAnimationFinish
    }));
  }
};

// node_modules/lingo3d/lib/display/core/StaticObjectManager/applyMaterialProperties/copyMaterial.js
var properties = [
  "name",
  "blending",
  "side",
  "vertexColors",
  "opacity",
  "transparent",
  "blendSrc",
  "blendDst",
  "blendEquation",
  "blendSrcAlpha",
  "blendDstAlpha",
  "blendEquationAlpha",
  "depthFunc",
  "depthTest",
  "depthWrite",
  "stencilWriteMask",
  "stencilFunc",
  "stencilRef",
  "stencilFuncMask",
  "stencilFail",
  "stencilZFail",
  "stencilZPass",
  "stencilWrite",
  "clipIntersection",
  "clipShadows",
  "shadowSide",
  "colorWrite",
  "precision",
  "polygonOffset",
  "polygonOffsetFactor",
  "polygonOffsetUnits",
  "dithering",
  "alphaTest",
  "alphaToCoverage",
  "premultipliedAlpha",
  "visible",
  "toneMapped"
];
var copyMaterial_default = (from, to) => {
  for (const prop of properties) {
    const value = from[prop];
    value != null && (to[prop] = value);
  }
  const srcPlanes = from.clippingPlanes;
  let dstPlanes = null;
  if (srcPlanes) {
    const n = srcPlanes.length;
    dstPlanes = new Array(n);
    for (let i = 0; i !== n; ++i)
      dstPlanes[i] = srcPlanes[i].clone();
  }
  to.clippingPlanes = dstPlanes;
};

// node_modules/lingo3d/lib/display/core/StaticObjectManager/applyMaterialProperties/copyStandard.js
var properties2 = [
  "roughness",
  "metalness",
  "map",
  "lightMap",
  "lightMapIntensity",
  "aoMap",
  "aoMapIntensity",
  "emissiveMap",
  "emissiveIntensity",
  "bumpMap",
  "bumpScale",
  "normalMap",
  "normalMapType",
  "displacementMap",
  "displacementScale",
  "displacementBias",
  "roughnessMap",
  "metalnessMap",
  "alphaMap",
  "envMap",
  "envMapIntensity",
  "wireframe",
  "wireframeLinewidth",
  "wireframeLinecap",
  "wireframeLinejoin",
  "flatShading",
  "fog"
];
var copyStandard_default = (source, target) => {
  copyMaterial_default(source, target);
  for (const prop of properties2) {
    const value = source[prop];
    value != null && (target[prop] = value);
  }
  target.defines = { "STANDARD": "" };
  source.color && target.color.copy(source.color);
  source.emissive && target.emissive.copy(source.emissive);
  source.normalScale && target.normalScale.copy(source.normalScale);
};

// node_modules/lingo3d/lib/display/core/StaticObjectManager/applyMaterialProperties/copyToon.js
var properties3 = [
  "map",
  "gradientMap",
  "lightMap",
  "lightMapIntensity",
  "aoMap",
  "aoMapIntensity",
  "emissiveMap",
  "emissiveIntensity",
  "bumpMap",
  "bumpScale",
  "normalMap",
  "normalMapType",
  "displacementMap",
  "displacementScale",
  "displacementBias",
  "alphaMap",
  "wireframe",
  "wireframeLinewidth",
  "wireframeLinecap",
  "wireframeLinejoin",
  "fog"
];
var copyToon_default = (source, target) => {
  copyMaterial_default(source, target);
  for (const prop of properties3) {
    const value = source[prop];
    value != null && (target[prop] = value);
  }
  source.color && target.color.copy(source.color);
  source.emissive && target.emissive.copy(source.emissive);
  source.normalScale && target.normalScale.copy(source.normalScale);
};

// node_modules/lingo3d/lib/display/utils/diffQuaternions.js
var diffQuaternions_default = (A, B) => A.clone().multiply(B.clone().invert());

// node_modules/lingo3d/lib/display/core/StaticObjectManager/index.js
var thisOBB = new OBB();
var targetOBB = new OBB();
var updateFrustum = throttle(() => {
  const camera = getCameraRendered();
  frustum.setFromProjectionMatrix(matrix4.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
}, 200, "leading");
var forcePBRSet = /* @__PURE__ */ new WeakSet();
var setNumber = (child, property, factor) => {
  var _a, _b;
  const defaultValue = (_b = (_a = child.userData)[property]) != null ? _b : _a[property] = child.material[property];
  child.material[property] = factor === void 0 ? defaultValue : (defaultValue || (forcePBRSet.has(child.material) ? 1 : 0)) * factor;
};
var setBoolean = (child, property, value) => {
  var _a, _b;
  const defaultValue = (_b = (_a = child.userData)[property]) != null ? _b : _a[property] = child.material[property];
  child.material[property] = value === void 0 ? defaultValue : value;
};
var setColor = (child, property, value) => {
  var _a, _b;
  const defaultValue = (_b = (_a = child.userData)[property]) != null ? _b : _a[property] = child.material[property];
  child.material[property] = value === void 0 ? defaultValue : value;
};
var idMap = /* @__PURE__ */ new Map();
var makeSet = () => /* @__PURE__ */ new Set();
var StaticObjectManager = class extends EventLoopItem {
  constructor(object3d) {
    super(object3d);
    __publicField(this, "object3d");
    __publicField(this, "_id");
    __publicField(this, "_onClick");
    __publicField(this, "_onMouseDown");
    __publicField(this, "_onMouseUp");
    __publicField(this, "_onMouseOver");
    __publicField(this, "_onMouseOut");
    __publicField(this, "_onMouseMove");
    __publicField(this, "_visible");
    __publicField(this, "_refreshFactors");
    __publicField(this, "_metalnessFactor");
    __publicField(this, "_roughnessFactor");
    __publicField(this, "_opacityFactor");
    __publicField(this, "_emissiveIntensityFactor");
    __publicField(this, "_emissiveColorFactor");
    __publicField(this, "_colorFactor");
    __publicField(this, "_toon");
    __publicField(this, "_pbr");
    __publicField(this, "onLookToEnd");
    this.object3d = object3d;
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this._id !== void 0 && idMap.get(this._id).delete(this);
    return this;
  }
  get id() {
    return this._id;
  }
  set id(val) {
    this._id !== void 0 && idMap.get(this._id).delete(this);
    this._id = val;
    val !== void 0 && forceGet(idMap, val, makeSet).add(this);
  }
  addToRaycastSet(set) {
    set.add(this.object3d);
    return new Cancellable(() => set.delete(this.object3d));
  }
  get onClick() {
    return this._onClick;
  }
  set onClick(cb) {
    this._onClick = cb;
    this.cancelHandle("onClick", cb && (() => this.addToRaycastSet(clickSet)));
  }
  get onMouseDown() {
    return this._onMouseDown;
  }
  set onMouseDown(cb) {
    this._onMouseDown = cb;
    this.cancelHandle("onMouseDown", cb && (() => this.addToRaycastSet(mouseDownSet)));
  }
  get onMouseUp() {
    return this._onMouseUp;
  }
  set onMouseUp(cb) {
    this._onMouseUp = cb;
    this.cancelHandle("onMouseUp", cb && (() => this.addToRaycastSet(mouseUpSet)));
  }
  get onMouseOver() {
    return this._onMouseOver;
  }
  set onMouseOver(cb) {
    this._onMouseOver = cb;
    this.cancelHandle("onMouseOver", cb && (() => this.addToRaycastSet(mouseOverSet)));
  }
  get onMouseOut() {
    return this._onMouseOut;
  }
  set onMouseOut(cb) {
    this._onMouseOut = cb;
    this.cancelHandle("onMouseOut", cb && (() => this.addToRaycastSet(mouseOutSet)));
  }
  get onMouseMove() {
    return this._onMouseMove;
  }
  set onMouseMove(cb) {
    this._onMouseMove = cb;
    this.cancelHandle("onMouseMove", cb && (() => this.addToRaycastSet(mouseMoveSet)));
  }
  get name() {
    return this.outerObject3d.name;
  }
  set name(val) {
    this.outerObject3d.name = PropertyBinding.sanitizeNodeName(val);
  }
  getRay() {
    return ray.set(getWorldPosition_default(this.object3d), this.object3d.getWorldDirection(vector3));
  }
  pointAt(distance2) {
    return vec2Point(this.getRay().at(distance2 * scaleDown, vector3));
  }
  rayIntersectsAt(target, maxDistance) {
    if (this.done)
      return void 0;
    if (target.done)
      return void 0;
    if (this === target)
      return void 0;
    targetOBB.set(getWorldPosition_default(target.object3d), vector3_half, new Matrix3().setFromMatrix4(target.object3d.matrixWorld));
    const vec = targetOBB.intersectRay(this.getRay(), vector3);
    if (!vec)
      return;
    if (maxDistance) {
      const { x, y, z } = getWorldPosition_default(this.object3d);
      if (distance3d(vec.x, vec.y, vec.z, x, y, z) * scaleUp > maxDistance)
        return;
    }
    return vec2Point(vec);
  }
  rayIntersects(target) {
    return !!this.rayIntersectsAt(target);
  }
  intersects(target) {
    if (this.done)
      return false;
    if (target.done)
      return false;
    if (this === target)
      return false;
    thisOBB.set(getWorldPosition_default(this.object3d), vector3_1.clone(), new Matrix3());
    thisOBB.applyMatrix4(this.object3d.matrixWorld);
    targetOBB.set(getWorldPosition_default(target.object3d), vector3_1.clone(), new Matrix3());
    targetOBB.applyMatrix4(target.object3d.matrixWorld);
    return thisOBB.intersectsOBB(targetOBB, 0);
  }
  get clientX() {
    return worldToClient_default(this.object3d).x;
  }
  get clientY() {
    return worldToClient_default(this.object3d).y;
  }
  get reflection() {
    return !!this.object3d.userData.ssr;
  }
  set reflection(val) {
    val && addSSR(this.object3d);
    this.cancelHandle("reflection", val && (() => new Cancellable(() => deleteSSR(this.object3d))));
  }
  get bloom() {
    return !!this.outerObject3d.userData.bloom;
  }
  set bloom(val) {
    val && addBloom(this.outerObject3d);
    this.cancelHandle("bloom", val && (() => new Cancellable(() => deleteBloom(this.outerObject3d))));
  }
  get outline() {
    return !!this.object3d.userData.outline;
  }
  set outline(val) {
    val && addOutline(this.object3d);
    this.cancelHandle("outline", val && (() => new Cancellable(() => deleteOutline(this.object3d))));
  }
  get visible() {
    return this._visible !== false;
  }
  set visible(val) {
    this._visible = val;
    this.outerObject3d.visible = val;
  }
  get frustumCulled() {
    return this.outerObject3d.frustumCulled;
  }
  set frustumCulled(val) {
    this.outerObject3d.traverse((child) => child.frustumCulled = val);
  }
  refreshFactors() {
    if (this._refreshFactors) {
      this._refreshFactors.set({});
      return;
    }
    this._refreshFactors = new Reactive({});
    this.createEffect(() => {
      const handle = new Cancellable();
      const { _toon, _pbr, _metalnessFactor, _roughnessFactor, _opacityFactor, _emissiveIntensityFactor, _emissiveColorFactor, _colorFactor } = this;
      this.outerObject3d.traverse((child) => {
        let { material } = child;
        if (!material)
          return;
        Array.isArray(material) && (material = material[0]);
        if (_toon) {
          child.material = new MeshToonMaterial();
          copyToon_default(material, child.material);
        } else if (_pbr) {
          forcePBRSet.add(child.material = new MeshStandardMaterial());
          copyStandard_default(material, child.material);
        }
        if (_metalnessFactor !== void 0)
          setNumber(child, "metalness", _metalnessFactor !== 0 ? _metalnessFactor : void 0);
        if (_roughnessFactor !== void 0)
          setNumber(child, "roughness", _roughnessFactor !== 1 ? _roughnessFactor : void 0);
        if (_opacityFactor !== void 0) {
          setNumber(child, "opacity", _opacityFactor);
          setBoolean(child, "transparent", _opacityFactor !== 1 ? true : void 0);
        }
        if (_emissiveIntensityFactor !== void 0)
          setNumber(child, "emissiveIntensity", _emissiveIntensityFactor !== 1 ? _emissiveIntensityFactor : void 0);
        if (_emissiveColorFactor !== void 0)
          setColor(child, "emissive", _emissiveColorFactor !== "#000000" ? new Color(_emissiveColorFactor) : void 0);
        if (_colorFactor !== void 0)
          setColor(child, "color", _colorFactor !== "#ffffff" ? new Color(_colorFactor) : void 0);
        handle.then(() => {
          child.material.dispose();
          child.material = material;
        });
      });
      return () => {
        handle.cancel();
      };
    }, [this._refreshFactors.get]);
  }
  get metalnessFactor() {
    return this._metalnessFactor;
  }
  set metalnessFactor(val) {
    this._metalnessFactor = val;
    this.refreshFactors();
  }
  get roughnessFactor() {
    return this._roughnessFactor;
  }
  set roughnessFactor(val) {
    this._roughnessFactor = val;
    this.refreshFactors();
  }
  get opacityFactor() {
    return this._opacityFactor;
  }
  set opacityFactor(val) {
    this._opacityFactor = val;
    this.refreshFactors();
  }
  get emissiveIntensityFactor() {
    return this._emissiveIntensityFactor;
  }
  set emissiveIntensityFactor(val) {
    this._emissiveIntensityFactor = val;
    this.refreshFactors();
  }
  get emissiveColorFactor() {
    return this._emissiveColorFactor;
  }
  set emissiveColorFactor(val) {
    this._emissiveColorFactor = val;
    this.refreshFactors();
  }
  get colorFactor() {
    return this._colorFactor;
  }
  set colorFactor(val) {
    this._colorFactor = val;
    this.refreshFactors();
  }
  get toon() {
    var _a;
    return (_a = this._toon) != null ? _a : false;
  }
  set toon(val) {
    this._toon = val;
    this.refreshFactors();
  }
  get pbr() {
    var _a;
    return (_a = this._pbr) != null ? _a : false;
  }
  set pbr(val) {
    this._pbr = val;
    this.refreshFactors();
  }
  get frustumVisible() {
    updateFrustum();
    return frustum.containsPoint(getCenter_default(this.object3d));
  }
  lookAt(a0, a1, a2) {
    if (typeof a0 === "number") {
      this.lookAt(new Point3d(a0, a1 === void 0 ? this.outerObject3d.position.y * scaleUp : a1, a2));
      return;
    }
    if ("outerObject3d" in a0)
      this.outerObject3d.lookAt(getWorldPosition_default(getObject3d(a0)));
    else
      this.outerObject3d.lookAt(point2Vec(a0));
  }
  lookTo(a0, a1, a2, a3) {
    if (typeof a0 === "number") {
      this.lookTo(new Point3d(a0, a1 === void 0 ? this.outerObject3d.position.y * scaleUp : a1, a2), a3);
      return;
    }
    const { quaternion } = this.outerObject3d;
    const quaternionOld = quaternion.clone();
    this.lookAt(a0);
    const quaternionNew = quaternion.clone();
    quaternion.copy(quaternionOld);
    this.cancelHandle("lookTo", () => onBeforeRender(() => {
      var _a;
      quaternion.slerp(quaternionNew, a1);
      const { x, y, z } = diffQuaternions_default(quaternion, quaternionNew);
      if (Math.abs(x) + Math.abs(y) + Math.abs(z) < 1e-3) {
        this.cancelHandle("lookTo", void 0);
        (_a = this.onLookToEnd) == null ? void 0 : _a.call(this);
        quaternion.copy(quaternionNew);
      }
    }));
  }
};
applyMixins(StaticObjectManager, [AnimationMixin]);
var StaticObjectManager_default = StaticObjectManager;

// node_modules/lingo3d/lib/display/core/MeshItem.js
var isMeshItem = (item) => !!item && (isPositionedItem(item) || item instanceof StaticObjectManager_default);
var getObject3d = (item) => {
  if ("object3d" in item)
    return item.object3d;
  return item.outerObject3d;
};

// node_modules/lingo3d/lib/display/utils/getActualScale.js
var cache3 = /* @__PURE__ */ new WeakMap();
var getActualScale_default = (target) => {
  if (cache3.has(target))
    return cache3.get(target).clone();
  const result = getObject3d(target).scale.clone().multiply(target.outerObject3d.scale);
  cache3.set(target, result.clone());
  onAfterRender(() => cache3.delete(target), true);
  return result;
};

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/cubeShape.js
async function cubeShape_default() {
  const { Box } = await loadCannon_default();
  this.cannonBody.addShape(new Box(getActualScale_default(this).multiplyScalar(0.5)));
}

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/bvh/bvhContactMap.js
var bvhContactMap_default = /* @__PURE__ */ new Map();

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/index.js
var PhysicsMixin = class extends PositionedItem {
  constructor() {
    super(...arguments);
    __publicField(this, "_mAV");
    __publicField(this, "_mV");
    __publicField(this, "physicsUpdate");
    __publicField(this, "cannonBody");
    __publicField(this, "_noTumble");
    __publicField(this, "_slippery");
    __publicField(this, "_mass");
    __publicField(this, "_physicsGroup");
    __publicField(this, "_ignorePhysicsGroups");
    __publicField(this, "_physicsShape");
    __publicField(this, "bvhVelocity");
    __publicField(this, "bvhOnGround");
    __publicField(this, "bvhRadius");
    __publicField(this, "bvhHalfHeight");
    __publicField(this, "bvhMap");
    __publicField(this, "bvhCharacter");
    __publicField(this, "_physics");
  }
  getMAV() {
    var _a;
    return (_a = this._mAV) != null ? _a : this._mAV = new Point3d(Infinity, Infinity, Infinity);
  }
  get maxAngularVelocityX() {
    var _a, _b;
    return (_b = (_a = this._mAV) == null ? void 0 : _a.x) != null ? _b : Infinity;
  }
  set maxAngularVelocityX(val) {
    this.getMAV().x = val;
  }
  get maxAngularVelocityY() {
    var _a, _b;
    return (_b = (_a = this._mAV) == null ? void 0 : _a.y) != null ? _b : Infinity;
  }
  set maxAngularVelocityY(val) {
    this.getMAV().y = val;
  }
  get maxAngularVelocityZ() {
    var _a, _b;
    return (_b = (_a = this._mAV) == null ? void 0 : _a.z) != null ? _b : Infinity;
  }
  set maxAngularVelocityZ(val) {
    this.getMAV().z = val;
  }
  getMV() {
    var _a;
    return (_a = this._mV) != null ? _a : this._mV = new Point3d(Infinity, Infinity, Infinity);
  }
  get maxVelocityX() {
    var _a, _b;
    return (_b = (_a = this._mV) == null ? void 0 : _a.x) != null ? _b : Infinity;
  }
  set maxVelocityX(val) {
    this.getMV().x = val;
  }
  get maxVelocityY() {
    var _a, _b;
    return (_b = (_a = this._mV) == null ? void 0 : _a.y) != null ? _b : Infinity;
  }
  set maxVelocityY(val) {
    this.getMV().y = val;
  }
  get maxVelocityZ() {
    var _a, _b;
    return (_b = (_a = this._mV) == null ? void 0 : _a.z) != null ? _b : Infinity;
  }
  set maxVelocityZ(val) {
    this.getMV().z = val;
  }
  physicsRotate() {
    var _a, _b;
    if (!this.physicsUpdate)
      return;
    const rotation = (_b = (_a = this.physicsUpdate).rotation) != null ? _b : _a.rotation = {};
    rotation.x = true;
    rotation.y = true;
    rotation.z = true;
  }
  physicsMove() {
    var _a, _b;
    if (!this.physicsUpdate)
      return;
    const position = (_b = (_a = this.physicsUpdate).position) != null ? _b : _a.position = {};
    position.x = true;
    position.y = true;
    position.z = true;
  }
  physicsMoveXZ() {
    var _a, _b;
    if (!this.physicsUpdate)
      return;
    const position = (_b = (_a = this.physicsUpdate).position) != null ? _b : _a.position = {};
    position.x = true;
    position.z = true;
  }
  applyForce(x, y, z) {
    setTimeout(() => {
      var _a;
      return (_a = this.cannonBody) == null ? void 0 : _a.applyForce({ x, y, z });
    });
  }
  applyImpulse(x, y, z) {
    setTimeout(() => {
      var _a;
      return (_a = this.cannonBody) == null ? void 0 : _a.applyImpulse({ x, y, z });
    });
  }
  applyLocalForce(x, y, z) {
    setTimeout(() => {
      var _a;
      return (_a = this.cannonBody) == null ? void 0 : _a.applyLocalForce({ x, y, z });
    });
  }
  applyLocalImpulse(x, y, z) {
    setTimeout(() => {
      var _a;
      return (_a = this.cannonBody) == null ? void 0 : _a.applyLocalImpulse({ x, y, z });
    });
  }
  applyTorque(x, y, z) {
    setTimeout(() => {
      var _a;
      return (_a = this.cannonBody) == null ? void 0 : _a.applyTorque({ x, y, z });
    });
  }
  get velocity() {
    if (this.bvhVelocity)
      return this.bvhVelocity;
    if (this.cannonBody)
      return this.cannonBody.velocity;
    return new Point3d(0, 0, 0);
  }
  set velocity(val) {
    if (this.bvhVelocity)
      Object.assign(this.bvhVelocity, val);
    else if (this.cannonBody)
      Object.assign(this.cannonBody.velocity, val);
  }
  refreshCannon() {
    var _a;
    this.physicsUpdate && (this.physics = (_a = this._physics) != null ? _a : false);
  }
  get noTumble() {
    return this._noTumble;
  }
  set noTumble(val) {
    this._noTumble = val;
    this.refreshCannon();
  }
  get slippery() {
    return this._slippery;
  }
  set slippery(val) {
    this._slippery = val;
    this.refreshCannon();
  }
  get mass() {
    return this._mass;
  }
  set mass(val) {
    this._mass = val;
    this.refreshCannon();
  }
  get physicsGroup() {
    return this._physicsGroup;
  }
  set physicsGroup(val) {
    this._physicsGroup = val;
    this.refreshCannon();
  }
  get ignorePhysicsGroups() {
    return this._ignorePhysicsGroups;
  }
  set ignorePhysicsGroups(val) {
    this._ignorePhysicsGroups = val;
    this.refreshCannon();
  }
  get physicsShape() {
    var _a;
    return (_a = this._physicsShape) != null ? _a : this._physicsShape = cubeShape_default;
  }
  set physicsShape(val) {
    this._physicsShape = val;
    this.refreshCannon();
  }
  initPhysics(val, handle) {
    if (!val || handle.done)
      return;
    switch (val) {
      case true:
      case "2d":
        import("./enableCannon-J62CHCKV.js").then((module) => module.default.call(this, handle));
        break;
      case "map":
        this.bvhMap = true;
        import("./enableBVHMap-WEXVWXNV.js").then((module) => module.default.call(this, handle, false));
        break;
      case "map-debug":
        this.bvhMap = true;
        import("./enableBVHMap-WEXVWXNV.js").then((module) => module.default.call(this, handle, true));
        break;
      case "character":
        this.bvhCharacter = true;
        import("./enableBVHCharacter-JHZJATLT.js").then((module) => module.default.call(this, handle));
        break;
      default:
        assertExhaustive(val);
    }
  }
  get physics() {
    var _a;
    return (_a = this._physics) != null ? _a : false;
  }
  set physics(val) {
    if (this._physics === val)
      return;
    this._physics = val;
    this.initPhysics(val, this.cancelHandle("physics", () => new Cancellable()));
  }
};

// node_modules/lingo3d/lib/display/core/SimpleObjectManager/index.js
var ptDistCache = /* @__PURE__ */ new WeakMap();
var distance3dCached = (pt, vecSelf) => {
  const cached = ptDistCache.get(pt);
  if (cached)
    return cached;
  const result = distance3d(pt.x, pt.y, pt.z, vecSelf.x * scaleUp, vecSelf.y * scaleUp, vecSelf.z * scaleUp);
  ptDistCache.set(pt, result);
  return result;
};
var SimpleObjectManager = class extends StaticObjectManager_default {
  constructor() {
    super(...arguments);
    __publicField(this, "onIntersectState");
    __publicField(this, "onIntersectOutState");
    __publicField(this, "intersectIdsState");
    __publicField(this, "onMoveToEnd");
  }
  getRayIntersectionsAt(id, maxDistance) {
    var _a;
    const result = [];
    for (const target of (_a = idMap.get(id)) != null ? _a : []) {
      if (target === this)
        continue;
      const pt = this.rayIntersectsAt(target, maxDistance);
      pt && result.push([target, pt]);
    }
    const vec = getWorldPosition_default(this.object3d);
    return result.sort((a2, b2) => {
      return distance3dCached(a2[1], vec) - distance3dCached(b2[1], vec);
    });
  }
  getRayIntersections(id, maxDistance) {
    return this.getRayIntersectionsAt(id, maxDistance).map((result) => result[0]);
  }
  listenToRayIntersection(id, cb, maxDistance) {
    return this.beforeRender(() => {
      for (const [target, pt] of this.getRayIntersectionsAt(id, maxDistance))
        cb(target, pt);
    });
  }
  getIntersections(id) {
    var _a;
    const result = [];
    for (const target of (_a = idMap.get(id)) != null ? _a : []) {
      if (target === this)
        continue;
      this.intersects(target) && result.push(target);
    }
    return result;
  }
  listenToIntersection(id, cb, cbOut) {
    let intersectionsOld = [];
    return this.beforeRender(() => {
      const intersections = this.getIntersections(id);
      if (cb) {
        for (const target of intersections)
          if (!intersectionsOld.includes(target))
            cb(target);
      }
      if (cbOut) {
        for (const target of intersectionsOld)
          if (!intersections.includes(target))
            cbOut(target);
      }
      intersectionsOld = intersections;
    });
  }
  initIntersect() {
    if (this.onIntersectState)
      return;
    this.onIntersectState = new Reactive(void 0);
    this.onIntersectOutState = new Reactive(void 0);
    this.intersectIdsState = new Reactive(void 0);
    this.createEffect(() => {
      const { onIntersect, onIntersectOut, intersectIds } = this;
      if (!intersectIds || !onIntersect && !onIntersectOut)
        return;
      const handles = [];
      for (const id of intersectIds)
        handles.push(this.listenToIntersection(id, onIntersect, onIntersectOut));
      return () => {
        for (const handle of handles)
          handle.cancel();
      };
    }, [this.onIntersectState.get, this.onIntersectOutState.get, this.intersectIdsState.get]);
  }
  get onIntersect() {
    var _a;
    return (_a = this.onIntersectState) == null ? void 0 : _a.get();
  }
  set onIntersect(val) {
    var _a;
    this.initIntersect();
    (_a = this.onIntersectState) == null ? void 0 : _a.set(val);
  }
  get onIntersectOut() {
    var _a;
    return (_a = this.onIntersectOutState) == null ? void 0 : _a.get();
  }
  set onIntersectOut(val) {
    var _a;
    this.initIntersect();
    (_a = this.onIntersectOutState) == null ? void 0 : _a.set(val);
  }
  get intersectIds() {
    var _a;
    return (_a = this.intersectIdsState) == null ? void 0 : _a.get();
  }
  set intersectIds(val) {
    var _a;
    this.initIntersect();
    (_a = this.intersectIdsState) == null ? void 0 : _a.set(val);
  }
  intersects(target) {
    var _a, _b, _c, _d;
    if (this.done)
      return false;
    if (target.done)
      return false;
    if (this === target)
      return false;
    if (target instanceof SimpleObjectManager) {
      if (this.bvhMap && target.bvhCharacter || this.bvhCharacter && target.bvhMap)
        return ((_a = bvhContactMap_default.get(this)) == null ? void 0 : _a.has(target)) || ((_b = bvhContactMap_default.get(target)) == null ? void 0 : _b.has(this)) || false;
      if (this.cannonBody && target.cannonBody) {
        cannonContactBodies.add(this.cannonBody);
        cannonContactBodies.add(target.cannonBody);
        return ((_c = cannonContactMap.get(this.cannonBody)) == null ? void 0 : _c.has(target.cannonBody)) || ((_d = cannonContactMap.get(target.cannonBody)) == null ? void 0 : _d.has(this.cannonBody)) || false;
      }
    }
    return super.intersects(target);
  }
  get width() {
    return this.object3d.scale.x * scaleUp;
  }
  set width(val) {
    this.object3d.scale.x = val * scaleDown;
  }
  get height() {
    return this.object3d.scale.y * scaleUp;
  }
  set height(val) {
    this.object3d.scale.y = val * scaleDown;
  }
  get depth() {
    return this.object3d.scale.z * scaleUp;
  }
  set depth(val) {
    this.object3d.scale.z = val * scaleDown;
  }
  get x() {
    return this.outerObject3d.position.x * scaleUp;
  }
  set x(val) {
    var _a, _b;
    this.outerObject3d.position.x = val * scaleDown;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).position) != null ? _b : _a.position = {}).x = true);
  }
  get y() {
    return this.outerObject3d.position.y * scaleUp;
  }
  set y(val) {
    var _a, _b;
    this.outerObject3d.position.y = val * scaleDown;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).position) != null ? _b : _a.position = {}).y = true);
  }
  get z() {
    return this.outerObject3d.position.z * scaleUp;
  }
  set z(val) {
    var _a, _b;
    this.outerObject3d.position.z = val * scaleDown;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).position) != null ? _b : _a.position = {}).z = true);
  }
  get scaleX() {
    return this.outerObject3d.scale.x;
  }
  set scaleX(val) {
    this.outerObject3d.scale.x = val;
  }
  get scaleY() {
    return this.outerObject3d.scale.y;
  }
  set scaleY(val) {
    this.outerObject3d.scale.y = val;
  }
  get scaleZ() {
    return this.outerObject3d.scale.z;
  }
  set scaleZ(val) {
    this.outerObject3d.scale.z = val;
  }
  get scale() {
    return this.scaleX;
  }
  set scale(val) {
    this.scaleX = val;
    this.scaleY = val;
    this.scaleZ = val;
  }
  get rotationX() {
    return this.outerObject3d.rotation.x * rad2Deg;
  }
  set rotationX(val) {
    var _a, _b;
    this.outerObject3d.rotation.x = val * deg2Rad;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).rotation) != null ? _b : _a.rotation = {}).x = true);
  }
  get rotationY() {
    return this.outerObject3d.rotation.y * rad2Deg;
  }
  set rotationY(val) {
    var _a, _b;
    this.outerObject3d.rotation.y = val * deg2Rad;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).rotation) != null ? _b : _a.rotation = {}).y = true);
  }
  get rotationZ() {
    return this.outerObject3d.rotation.z * rad2Deg;
  }
  set rotationZ(val) {
    var _a, _b;
    this.outerObject3d.rotation.z = val * deg2Rad;
    this.physicsUpdate && (((_b = (_a = this.physicsUpdate).rotation) != null ? _b : _a.rotation = {}).z = true);
  }
  get rotation() {
    return this.rotationZ;
  }
  set rotation(val) {
    this.rotationZ = val;
  }
  get innerVisible() {
    return this.object3d.visible;
  }
  set innerVisible(val) {
    this.object3d.visible = val;
  }
  lookAt(a0, a1, a2) {
    super.lookAt(a0, a1, a2);
    this.physicsRotate();
  }
  translateX(val) {
    this.outerObject3d.translateX(val * scaleDown);
    this.physicsMove();
  }
  translateY(val) {
    this.outerObject3d.translateY(val * scaleDown);
    this.physicsMove();
  }
  translateZ(val) {
    this.outerObject3d.translateZ(val * scaleDown);
    this.physicsMove();
  }
  placeAt(object) {
    if ("outerObject3d" in object) {
      this.outerObject3d.position.copy(getCenter_default(getObject3d(object)));
      this.outerObject3d.quaternion.copy(getWorldQuaternion_default(object.outerObject3d));
    } else
      this.outerObject3d.position.copy(point2Vec(object));
    this.physicsMove();
    this.physicsRotate();
  }
  moveForward(distance2) {
    if (distance2 === 0)
      return;
    vector3.setFromMatrixColumn(this.outerObject3d.matrix, 0);
    vector3.crossVectors(this.outerObject3d.up, vector3);
    this.outerObject3d.position.addScaledVector(vector3, distance2 * scaleDown);
    this.physicsMoveXZ();
  }
  moveRight(distance2) {
    if (distance2 === 0)
      return;
    vector3.setFromMatrixColumn(this.outerObject3d.matrix, 0);
    this.outerObject3d.position.addScaledVector(vector3, distance2 * scaleDown);
    this.physicsMoveXZ();
  }
  lerpTo(x, y, z, alpha) {
    const from = new Vector3(this.x, this.y, this.z);
    const to = new Vector3(x, y, z);
    this.cancelHandle("lerpTo", () => onBeforeRender(() => {
      var _a;
      const { x: x2, y: y2, z: z2 } = from.lerp(to, alpha);
      if (Math.abs(this.x - x2) < 0.1 && Math.abs(this.y - y2) < 0.1 && Math.abs(this.z - z2) < 0.1) {
        this.cancelHandle("lerpTo", void 0);
        (_a = this.onMoveToEnd) == null ? void 0 : _a.call(this);
      }
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.physicsMove();
    }));
  }
  moveTo(x, y, z, speed) {
    const { x: rx, y: ry, z: rz } = new Vector3(x - this.x, y === void 0 ? 0 : y - this.y, z - this.z).normalize();
    const sx = speed * rx;
    const sy = speed * ry;
    const sz = speed * rz;
    let distOld = Infinity;
    this.cancelHandle("lerpTo", () => onBeforeRender(() => {
      var _a;
      this.x += sx;
      y !== void 0 && (this.y += sy);
      this.z += sz;
      let dist = distance3d(this.x, y === void 0 ? 0 : this.y, this.z, x, y === void 0 ? 0 : y, z);
      if (dist >= distOld) {
        this.cancelHandle("lerpTo", void 0);
        (_a = this.onMoveToEnd) == null ? void 0 : _a.call(this);
        this.x = x;
        y !== void 0 && (this.y = y);
        this.z = z;
      }
      distOld = dist;
      y === void 0 ? this.physicsMoveXZ() : this.physicsMove();
    }));
  }
};
applyMixins(SimpleObjectManager, [PositionedItem, PhysicsMixin]);
var SimpleObjectManager_default = SimpleObjectManager;

// node_modules/lingo3d/lib/interface/IAnimationMixin.js
var animationMixinSchema = {
  animations: Object,
  animation: [String, Number, Array, Boolean, Object],
  animationPaused: Boolean,
  animationRepeat: Boolean,
  onAnimationFinish: Function
};
var animationMixinDefaults = {
  animations: {},
  animation: void 0,
  animationPaused: [void 0, false],
  animationRepeat: [void 0, true],
  onAnimationFinish: void 0
};

// node_modules/lingo3d/lib/interface/IStaticObjectManaget.js
var staticObjectManagerSchema = {
  ...eventLoopSchema,
  ...animationMixinSchema,
  onClick: Function,
  onMouseDown: Function,
  onMouseUp: Function,
  onMouseOver: Function,
  onMouseOut: Function,
  onMouseMove: Function,
  onLookToEnd: Function,
  name: String,
  id: String,
  bloom: Boolean,
  reflection: Boolean,
  outline: Boolean,
  visible: Boolean,
  frustumCulled: Boolean,
  metalnessFactor: Number,
  roughnessFactor: Number,
  opacityFactor: Number,
  emissiveIntensityFactor: Number,
  emissiveColorFactor: String,
  colorFactor: String,
  toon: Boolean,
  pbr: Boolean
};
var staticObjectManagerDefaults = {
  ...eventLoopDefaults,
  ...animationMixinDefaults,
  onClick: void 0,
  onMouseDown: void 0,
  onMouseUp: void 0,
  onMouseOver: void 0,
  onMouseOut: void 0,
  onMouseMove: void 0,
  onLookToEnd: void 0,
  name: "",
  id: void 0,
  bloom: false,
  reflection: false,
  outline: false,
  visible: true,
  frustumCulled: true,
  metalnessFactor: [void 0, 0],
  roughnessFactor: [void 0, 1],
  opacityFactor: [void 0, 1],
  emissiveIntensityFactor: [void 0, 1],
  emissiveColorFactor: [void 0, "#000000"],
  colorFactor: [void 0, "#ffffff"],
  toon: false,
  pbr: false
};

// node_modules/lingo3d/lib/interface/ITexturedBasic.js
var texturedBasicSchema = {
  color: String,
  fog: Boolean,
  opacity: Number,
  texture: [String, Object],
  videoTexture: [String, Object],
  alphaMap: String,
  textureRepeat: [Object, Number]
};
var texturedBasicDefaults = {
  color: "#ffffff",
  fog: true,
  opacity: 1,
  texture: void 0,
  videoTexture: void 0,
  alphaMap: void 0,
  textureRepeat: [void 0, { x: 1, y: 1 }]
};

// node_modules/lingo3d/lib/interface/ITexturedStandard.js
var texturedStandardSchema = {
  color: String,
  wireframe: Boolean,
  envMap: String,
  aoMap: String,
  aoMapIntensity: Number,
  bumpMap: String,
  bumpScale: Number,
  displacementMap: String,
  displacementScale: Number,
  displacementBias: Number,
  emissiveColor: String,
  emissiveMap: String,
  emissiveIntensity: Number,
  lightMap: String,
  lightMapIntensity: Number,
  metalnessMap: String,
  metalness: Number,
  roughnessMap: String,
  roughness: Number,
  normalMap: String,
  normalScale: [Object, Number],
  normalMapType: String
};
var texturedStandardDefaults = {
  color: "#ffffff",
  wireframe: false,
  envMap: void 0,
  aoMap: void 0,
  aoMapIntensity: 1,
  bumpMap: void 0,
  bumpScale: 1,
  displacementMap: void 0,
  displacementScale: 1,
  displacementBias: 0,
  emissiveColor: "#000000",
  emissiveMap: void 0,
  emissiveIntensity: 1,
  lightMap: void 0,
  lightMapIntensity: 1,
  metalnessMap: void 0,
  metalness: 0,
  roughnessMap: void 0,
  roughness: 1,
  normalMap: void 0,
  normalScale: { x: 1, y: 1 },
  normalMapType: void 0
};

// node_modules/lingo3d/lib/interface/IFound.js
var foundSchema = {
  ...staticObjectManagerSchema,
  ...texturedBasicSchema,
  ...texturedStandardSchema
};
var foundDefaults = {
  ...staticObjectManagerDefaults,
  ...texturedBasicDefaults,
  ...texturedStandardDefaults
};

// node_modules/lingo3d/lib/display/utils/loaders/setObjectURLMapper.js
var objectURLMapperPtr = [(url) => url];

// node_modules/lingo3d/lib/display/core/mixins/TexturedBasicMixin.js
var mapNames = ["map", "alphaMap"];
var textureRepeatMap = /* @__PURE__ */ new Map();
var applyTextureRepeat = debounce(function() {
  for (const [item, repeat] of textureRepeatMap) {
    for (const name of mapNames) {
      const map = item.material[name];
      map && (map.repeat = repeat);
    }
  }
  textureRepeatMap.clear();
}, 0, "trailing");
var TexturedBasicMixin = class {
  constructor() {
    __publicField(this, "_opacity");
    __publicField(this, "videoTextureState");
    __publicField(this, "textureState");
    __publicField(this, "_alphaMap");
    __publicField(this, "_textureRepeat");
  }
  get color() {
    return "#" + this.material.color.getHexString();
  }
  set color(val) {
    this.material.color = new Color(val);
  }
  get fog() {
    return this.material.fog;
  }
  set fog(val) {
    this.material.fog = val;
  }
  get opacity() {
    var _a;
    return (_a = this._opacity) != null ? _a : this._opacity = 1;
  }
  set opacity(val) {
    var _a;
    this._opacity = val;
    this.material.opacity = val;
    this.material.transparent = (_a = this.transparent) != null ? _a : val < 1;
    this.object3d.visible = !!val;
  }
  basicTextureRepeat() {
    this.material.needsUpdate = true;
    if (!this._textureRepeat)
      return;
    textureRepeatMap.set(this, this._textureRepeat);
    applyTextureRepeat();
  }
  initTexture() {
    var _a, _b;
    if (this.textureState)
      return;
    const videoTextureState = (_a = this.videoTextureState) != null ? _a : this.videoTextureState = new Reactive(void 0);
    const textureState = (_b = this.textureState) != null ? _b : this.textureState = new Reactive(void 0);
    this.createEffect(() => {
      const url = textureState.get();
      let videoURL = videoTextureState.get();
      if (!videoURL && (typeof url === "string" && objectURLMapperPtr[0](url).toLowerCase().endsWith(".mp4") || url && url instanceof HTMLVideoElement)) {
        videoURL = url;
      }
      if (videoURL) {
        let video;
        if (videoURL instanceof HTMLVideoElement)
          video = videoURL;
        else {
          video = document.createElement("video");
          video.crossOrigin = "anonymous";
          video.src = videoURL;
          video.loop = true;
          video.autoplay = true;
          video.muted = true;
          video.playsInline = true;
          video.play();
        }
        const videoTexture = new VideoTexture(video);
        videoTexture.wrapS = videoTexture.wrapT = RepeatWrapping;
        const { material: material2 } = this;
        const { map: map2 } = material2;
        material2.map = videoTexture;
        material2.needsUpdate = true;
        this.basicTextureRepeat();
        return () => {
          video.pause();
          videoTexture.dispose();
          material2.map = map2;
          material2.needsUpdate = true;
        };
      }
      if (!url)
        return;
      const { material } = this;
      const { map } = material;
      material.map = loadTexture_default(url);
      this.basicTextureRepeat();
      return () => {
        material.map = map;
        this.material.needsUpdate = true;
      };
    }, [videoTextureState.get, textureState.get]);
  }
  get videoTexture() {
    var _a;
    return (_a = this.videoTextureState) == null ? void 0 : _a.get();
  }
  set videoTexture(url) {
    this.initTexture();
    this.videoTextureState.set(url);
  }
  get texture() {
    var _a;
    return (_a = this.textureState) == null ? void 0 : _a.get();
  }
  set texture(url) {
    this.initTexture();
    this.textureState.set(url);
  }
  get alphaMap() {
    return this._alphaMap;
  }
  set alphaMap(val) {
    this._alphaMap = val;
    this.material.alphaMap = val ? loadTexture_default(val) : null;
    this.basicTextureRepeat();
  }
  get textureRepeat() {
    return this._textureRepeat;
  }
  set textureRepeat(val) {
    typeof val === "number" && (val = new Vector2(val, val));
    this._textureRepeat = val;
    this.basicTextureRepeat();
  }
};

// node_modules/lingo3d/lib/display/core/mixins/TexturedStandardMixin.js
var mapNames2 = ["map", "alphaMap", "envMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "lightMap", "metalnessMap", "roughnessMap", "normalMap"];
var textureRepeatMap2 = /* @__PURE__ */ new Map();
var applyTextureRepeat2 = debounce(function() {
  for (const [item, repeat] of textureRepeatMap2) {
    for (const name of mapNames2) {
      const map = item.material[name];
      map && (map.repeat = repeat);
    }
  }
  textureRepeatMap2.clear();
}, 0, "trailing");
var TexturedStandardMixin = class {
  constructor() {
    __publicField(this, "_envMap");
    __publicField(this, "_aoMap");
    __publicField(this, "_bumpMap");
    __publicField(this, "_displacementMap");
    __publicField(this, "_emissiveMap");
    __publicField(this, "_lightMap");
    __publicField(this, "_metalnessMap");
    __publicField(this, "_roughnessMap");
    __publicField(this, "_normalMap");
    __publicField(this, "_normalMapType");
  }
  get color() {
    return "#" + this.material.color.getHexString();
  }
  set color(val) {
    this.material.color = new Color(val);
  }
  get wireframe() {
    return this.material.wireframe;
  }
  set wireframe(val) {
    this.material.wireframe = val;
  }
  standardTextureRepeat() {
    this.material.needsUpdate = true;
    if (!this._textureRepeat)
      return;
    textureRepeatMap2.set(this, this._textureRepeat);
    applyTextureRepeat2();
  }
  get envMap() {
    return this._envMap;
  }
  set envMap(val) {
    this._envMap = val;
    this.material.envMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get aoMap() {
    return this._aoMap;
  }
  set aoMap(val) {
    this._aoMap = val;
    this.material.aoMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get aoMapIntensity() {
    return this.material.aoMapIntensity;
  }
  set aoMapIntensity(val) {
    this.material.aoMapIntensity = val;
  }
  get bumpMap() {
    return this._bumpMap;
  }
  set bumpMap(val) {
    this._bumpMap = val;
    this.material.bumpMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get bumpScale() {
    return this.material.bumpScale;
  }
  set bumpScale(val) {
    this.material.bumpScale = val;
  }
  get displacementMap() {
    return this._displacementMap;
  }
  set displacementMap(val) {
    this._displacementMap = val;
    this.material.displacementMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get displacementScale() {
    return this.material.displacementScale;
  }
  set displacementScale(val) {
    this.material.displacementScale = val;
  }
  get displacementBias() {
    return this.material.displacementBias;
  }
  set displacementBias(val) {
    this.material.displacementBias = val;
  }
  get emissiveColor() {
    return "#" + this.material.emissive.getHexString();
  }
  set emissiveColor(val) {
    this.material.emissive = new Color(val);
  }
  get emissiveMap() {
    return this._emissiveMap;
  }
  set emissiveMap(val) {
    this._emissiveMap = val;
    this.material.emissiveMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get emissiveIntensity() {
    return this.material.emissiveIntensity;
  }
  set emissiveIntensity(val) {
    this.material.emissiveIntensity = val;
  }
  get lightMap() {
    return this._lightMap;
  }
  set lightMap(val) {
    this._lightMap = val;
    this.material.lightMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get lightMapIntensity() {
    return this.material.lightMapIntensity;
  }
  set lightMapIntensity(val) {
    this.material.lightMapIntensity = val;
  }
  get metalnessMap() {
    return this._metalnessMap;
  }
  set metalnessMap(val) {
    this._metalnessMap = val;
    this.material.metalnessMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get metalness() {
    return this.material.metalness;
  }
  set metalness(val) {
    this.material.metalness = val;
  }
  get roughnessMap() {
    return this._roughnessMap;
  }
  set roughnessMap(val) {
    this._roughnessMap = val;
    this.material.roughnessMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get roughness() {
    return this.material.roughness;
  }
  set roughness(val) {
    this.material.roughness = val;
  }
  get normalMap() {
    return this._normalMap;
  }
  set normalMap(val) {
    this._normalMap = val;
    this.material.normalMap = val ? loadTexture_default(val) : null;
    this.standardTextureRepeat();
  }
  get normalScale() {
    return this.material.normalScale;
  }
  set normalScale(val) {
    if (typeof val === "number")
      this.material.normalScale = new Vector2(val, val);
    else
      this.material.normalScale = val;
  }
  get normalMapType() {
    return this._normalMapType;
  }
  set normalMapType(val) {
    this._normalMapType = val;
    this.material.normalMapType = val === "objectSpace" ? ObjectSpaceNormalMap : TangentSpaceNormalMap;
  }
};

// node_modules/lingo3d/lib/display/core/FoundManager.js
var FoundManager = class extends StaticObjectManager_default {
  constructor(mesh) {
    var _a;
    super(mesh);
    __publicField(this, "material");
    __publicField(this, "model");
    __publicField(this, "managerSet");
    this.material = (_a = mesh.material) != null ? _a : mesh.material = new MeshStandardMaterial();
    appendableRoot.delete(this);
  }
  retargetAnimations() {
    var _a;
    if (!((_a = this.model) == null ? void 0 : _a.animationManagers))
      return;
    for (const animationManager of Object.values(this.model.animationManagers))
      this.animations[animationManager.name] = this.watch(animationManager.retarget(this.object3d));
    this.model = void 0;
  }
  get animation() {
    return super.animation;
  }
  set animation(val) {
    this.retargetAnimations();
    super.animation = val;
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.material.dispose();
    return this;
  }
  addToRaycastSet(set) {
    if (!this.managerSet) {
      this.managerSet = true;
      this.object3d.traverse((child) => child.userData.manager = this);
    }
    set.add(this.object3d);
    return new Cancellable(() => set.delete(this.object3d));
  }
};
__publicField(FoundManager, "componentName", "find");
__publicField(FoundManager, "defaults", foundDefaults);
__publicField(FoundManager, "schema", foundSchema);
applyMixins(FoundManager, [TexturedStandardMixin, TexturedBasicMixin]);
var FoundManager_default = FoundManager;

// node_modules/lingo3d/lib/display/core/ObjectManager.js
var ObjectManager = class extends SimpleObjectManager_default {
  constructor(object3d) {
    super(object3d);
    const group = this.outerObject3d = new Group();
    group.userData.manager = this;
    scene_default.add(group);
    group.add(object3d);
  }
  get innerRotationX() {
    return this.object3d.rotation.x * rad2Deg;
  }
  set innerRotationX(val) {
    this.object3d.rotation.x = val * deg2Rad;
  }
  get innerRotationY() {
    return this.object3d.rotation.y * rad2Deg;
  }
  set innerRotationY(val) {
    this.object3d.rotation.y = val * deg2Rad;
  }
  get innerRotationZ() {
    return this.object3d.rotation.z * rad2Deg;
  }
  set innerRotationZ(val) {
    this.object3d.rotation.z = val * deg2Rad;
  }
  get innerRotation() {
    return this.innerRotationZ;
  }
  set innerRotation(val) {
    this.innerRotationZ = val;
  }
  get innerX() {
    return this.object3d.position.x * scaleUp;
  }
  set innerX(val) {
    this.object3d.position.x = val * scaleDown;
  }
  get innerY() {
    return this.object3d.position.y * scaleUp;
  }
  set innerY(val) {
    this.object3d.position.y = val * scaleDown;
  }
  get innerZ() {
    return this.object3d.position.z * scaleUp;
  }
  set innerZ(val) {
    this.object3d.position.z = val * scaleDown;
  }
  find(name, hiddenFromSceneGraph) {
    var _a, _b;
    const child = this.outerObject3d.getObjectByName(PropertyBinding.sanitizeNodeName(name));
    if (!child)
      return;
    const result = (_b = (_a = child.userData).manager) != null ? _b : _a.manager = new FoundManager_default(child);
    !hiddenFromSceneGraph && this._append(result);
    return result;
  }
  findAll(name) {
    const result = [];
    this.outerObject3d.traverse((child) => {
      var _a, _b;
      child.name === name && result.push((_b = (_a = child.userData).manager) != null ? _b : _a.manager = new FoundManager_default(child));
    });
    return result;
  }
};

// node_modules/lingo3d/lib/interface/IPhysics.js
var physicsSchema = {
  maxAngularVelocityX: Number,
  maxAngularVelocityY: Number,
  maxAngularVelocityZ: Number,
  maxVelocityX: Number,
  maxVelocityY: Number,
  maxVelocityZ: Number,
  velocity: Object,
  noTumble: Boolean,
  slippery: Boolean,
  mass: Number,
  physicsGroup: Number,
  ignorePhysicsGroups: Array,
  physics: [String, Boolean],
  physicsShape: Function
};
hideSchema([
  "maxAngularVelocityX",
  "maxAngularVelocityY",
  "maxAngularVelocityZ",
  "maxVelocityX",
  "maxVelocityY",
  "maxVelocityZ",
  "velocity",
  "noTumble",
  "slippery",
  "mass",
  "physicsGroup",
  "ignorePhysicsGroups",
  "physicsShape"
]);
var physicsDefaults = {
  maxAngularVelocityX: Infinity,
  maxAngularVelocityY: Infinity,
  maxAngularVelocityZ: Infinity,
  maxVelocityX: Infinity,
  maxVelocityY: Infinity,
  maxVelocityZ: Infinity,
  velocity: { x: 0, y: 0, z: 0 },
  noTumble: [void 0, false],
  slippery: [void 0, false],
  mass: [void 0, 1],
  physicsGroup: void 0,
  ignorePhysicsGroups: void 0,
  physics: false,
  physicsShape: cubeShape_default
};

// node_modules/lingo3d/lib/interface/IPositioned.js
var positionedSchema = {
  ...eventLoopSchema,
  x: Number,
  y: Number,
  z: Number
};
var positionedDefaults = {
  ...eventLoopDefaults,
  x: 0,
  y: 0,
  z: 0
};

// node_modules/lingo3d/lib/interface/ISimpleObjectManager.js
var simpleObjectManagerSchema = {
  ...staticObjectManagerSchema,
  ...positionedSchema,
  ...physicsSchema,
  onIntersect: Function,
  onIntersectOut: Function,
  onMoveToEnd: Function,
  intersectIds: Array,
  width: Number,
  height: Number,
  depth: Number,
  scaleX: Number,
  scaleY: Number,
  scaleZ: Number,
  scale: Number,
  rotationX: Number,
  rotationY: Number,
  rotationZ: Number,
  rotation: Number,
  innerVisible: Boolean
};
hideSchema(["intersectIds"]);
var simpleObjectManagerDefaults = {
  ...staticObjectManagerDefaults,
  ...positionedDefaults,
  ...physicsDefaults,
  onIntersect: void 0,
  onIntersectOut: void 0,
  onMoveToEnd: void 0,
  intersectIds: void 0,
  width: 100,
  height: 100,
  depth: 100,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  scale: 1,
  rotationX: 0,
  rotationY: 0,
  rotationZ: 0,
  rotation: 0,
  innerVisible: true
};

// node_modules/lingo3d/lib/interface/IObjectManager.js
var objectManagerSchema = {
  ...simpleObjectManagerSchema,
  innerRotationX: Number,
  innerRotationY: Number,
  innerRotationZ: Number,
  innerRotation: Number,
  innerX: Number,
  innerY: Number,
  innerZ: Number
};
var objectManagerDefaults = {
  ...simpleObjectManagerDefaults,
  innerRotationX: 0,
  innerRotationY: 0,
  innerRotationZ: 0,
  innerRotation: 0,
  innerX: 0,
  innerY: 0,
  innerZ: 0
};

// node_modules/lingo3d/lib/interface/IPrimitive.js
var primitiveSchema = {
  ...objectManagerSchema,
  ...texturedBasicSchema,
  ...texturedStandardSchema
};
var primitiveDefaults = {
  ...objectManagerDefaults,
  ...texturedBasicDefaults,
  ...texturedStandardDefaults
};

// node_modules/lingo3d/lib/display/core/Primitive.js
var Primitive = class extends ObjectManager {
  constructor(geometry, transparent) {
    const material = new MeshStandardMaterial(transparent ? { transparent: true } : void 0);
    const mesh = new Mesh(geometry, material);
    super(mesh);
    __publicField(this, "material");
    __publicField(this, "transparent");
    this.material = material;
    this.transparent = transparent;
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.material.dispose();
    return this;
  }
};
__publicField(Primitive, "defaults", primitiveDefaults);
__publicField(Primitive, "schema", primitiveSchema);
applyMixins(Primitive, [TexturedStandardMixin, TexturedBasicMixin]);
var Primitive_default = Primitive;

export {
  setMultipleSelectionTargets,
  getMultipleSelectionTargets,
  multipleSelectionGroupManagers,
  getSelectionTarget,
  setSelectionTarget,
  Point3d,
  rad2Deg,
  deg2Rad,
  distance,
  rotatePoint,
  endPoint,
  vec2Point,
  point2Vec,
  getCenter_default,
  setMultipleSelection,
  getMultipleSelection,
  onSelectionTarget,
  emitSelectionTarget,
  setTransformControlsDragging,
  getTransformControlsDragging,
  setSelectionFrozen,
  getSelectionFrozen,
  addSelectionFrozen,
  clearSelectionFrozen,
  CopyShader,
  Pass,
  FullScreenQuad,
  ShaderPass,
  EffectComposer,
  getSelectiveBloomComposer,
  bloomPtr,
  addBloom,
  deleteBloom,
  renderSelectiveBloom_default,
  ssrPtr,
  addSSR,
  deleteSSR,
  ssrPass_default,
  setOutlineColor,
  getOutlineColor,
  setOutlineHiddenColor,
  getOutlineHiddenColor,
  setOutlinePattern,
  getOutlinePattern,
  setOutlinePulse,
  getOutlinePulse,
  setOutlineStrength,
  getOutlineStrength,
  setOutlineThickness,
  getOutlineThickness,
  outlinePtr,
  addOutline,
  deleteOutline,
  outlinePass_default,
  AnimationManager,
  idMap,
  isMeshItem,
  getObject3d,
  PositionedItem,
  isPositionedItem,
  getActualScale_default,
  bvhContactMap_default,
  SimpleObjectManager_default,
  texturedBasicSchema,
  texturedBasicDefaults,
  texturedStandardSchema,
  texturedStandardDefaults,
  objectURLMapperPtr,
  TexturedBasicMixin,
  TexturedStandardMixin,
  ObjectManager,
  positionedSchema,
  positionedDefaults,
  objectManagerSchema,
  objectManagerDefaults,
  primitiveSchema,
  primitiveDefaults,
  Primitive_default
};
//# sourceMappingURL=chunk-KPG43TSV.js.map
