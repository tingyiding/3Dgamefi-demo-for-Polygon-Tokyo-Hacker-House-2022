import {
  EventLoopItem,
  appendableRoot,
  eventLoopDefaults,
  eventLoopSchema,
  getBackgroundColor,
  getDefaultLight,
  getDefaultLightScale
} from "./chunk-MO2ISMHQ.js";
import {
  decreaseLoadingCount,
  handleProgress,
  increaseLoadingCount
} from "./chunk-2PNJ75KS.js";
import {
  getEditorActive,
  onBeforeRender
} from "./chunk-J7HA7FW3.js";
import {
  Events_default,
  createEffect,
  forceGet,
  last,
  lazy,
  preventTreeShake,
  pull2 as pull,
  push,
  store
} from "./chunk-NXCTIVNA.js";
import {
  Color,
  CubeTextureLoader,
  DataTextureLoader,
  DataUtils,
  DirectionalLight,
  EquirectangularReflectionMapping,
  FloatType,
  Fog,
  Group,
  HalfFloatType,
  HemisphereLight,
  LinearEncoding,
  LinearFilter,
  RepeatWrapping,
  Scene,
  TextureLoader
} from "./chunk-57VJUUAA.js";
import {
  __publicField
} from "./chunk-XA4H47DG.js";

// node_modules/lingo3d/lib/states/useEnvironmentStack.js
var [setEnvironmentStack, getEnvironmentStack] = store([]);
var pushEnvironmentStack = push(setEnvironmentStack, getEnvironmentStack);
var pullEnvironmentStack = pull(setEnvironmentStack, getEnvironmentStack);

// node_modules/lingo3d/lib/interface/IEnvironment.js
var environmentSchema = {
  ...eventLoopSchema,
  texture: String
};
var environmentDefaults = {
  ...eventLoopDefaults,
  texture: void 0
};

// node_modules/lingo3d/lib/display/Environment.js
var Environment = class extends EventLoopItem {
  constructor() {
    super(new Group());
    __publicField(this, "_texture");
    pushEnvironmentStack(this);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    pullEnvironmentStack(this);
    return this;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    setEnvironmentStack([...getEnvironmentStack()]);
  }
};
__publicField(Environment, "componentName", "environment");
__publicField(Environment, "defaults", environmentDefaults);
__publicField(Environment, "schema", environmentSchema);

// node_modules/three/examples/jsm/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer) {
    const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          console.error("THREE.RGBELoader Read Error: " + (msg || ""));
          break;
        case rgbe_write_error:
          console.error("THREE.RGBELoader Write Error: " + (msg || ""));
          break;
        case rgbe_format_error:
          console.error("THREE.RGBELoader Bad File Format: " + (msg || ""));
          break;
        default:
        case rgbe_memory_error:
          console.error("THREE.RGBELoader: Error: " + (msg || ""));
      }
      return RGBE_RETURN_FAILURE;
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      }
      if (-1 < i) {
        if (consume !== false)
          buffer2.pos += len + i + 1;
        return s + chunk.slice(0, i);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let line, match;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        return rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line.match(magic_token_re))) {
        return rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (line === false)
          break;
        header.string += line + "\n";
        if (line.charAt(0) === "#") {
          header.comments += line + "\n";
          continue;
        }
        if (match = line.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
          break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        return rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        return rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {
      const scanline_width = w;
      if (scanline_width < 8 || scanline_width > 32767 || (buffer2[0] !== 2 || buffer2[1] !== 2 || buffer2[2] & 128)) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        return rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w * h);
      if (!data_rgba.length) {
        return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          return rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (rgbeStart[0] != 2 || rgbeStart[1] != 2 || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (count === 0 || ptr + count > ptr_end) {
            return rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i = 0; i < count; i++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i = 0; i < l; i++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, format, type;
        let numElements;
        switch (this.type) {
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
            }
            data = floatArray;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
            }
            data = halfArray;
            type = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w,
          height: h,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          format,
          type
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
        case HalfFloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad)
        onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/lingo3d/lib/display/utils/loaders/loadTexture.js
var cache = /* @__PURE__ */ new Map();
var textureLoader = new TextureLoader();
var rgbeLoader = new RGBELoader();
var loaded = new Events_default();
var loadTexture_default = (url, onLoad) => {
  onLoad && loaded.once(url, () => queueMicrotask(onLoad));
  return forceGet(cache, url, () => {
    increaseLoadingCount();
    const hdr = url.toLowerCase().toLowerCase().endsWith(".hdr");
    const loader2 = hdr ? rgbeLoader : textureLoader;
    return loader2.load(url, (texture) => {
      texture.wrapS = texture.wrapT = RepeatWrapping;
      loaded.setState(url);
      decreaseLoadingCount();
    }, handleProgress, () => {
      loaded.setState(url);
      decreaseLoadingCount();
    });
  });
};

// node_modules/lingo3d/lib/engine/scene/scene.js
var scene_default = new Scene();

// node_modules/lingo3d/lib/engine/scene/defaultLight.js
var defaultLight_default = {};
var defaultEnvironment = new Environment();
appendableRoot.delete(defaultEnvironment);
createEffect(() => {
  var _a;
  const environment = (_a = last(getEnvironmentStack())) == null ? void 0 : _a.texture;
  if (!environment)
    return;
  let proceed = true;
  const texture = loadTexture_default(environment, () => proceed && (scene_default.environment = texture));
  texture.mapping = EquirectangularReflectionMapping;
  return () => {
    proceed = false;
    scene_default.environment = null;
  };
}, [getEnvironmentStack]);
createEffect(() => {
  const defaultLight = getDefaultLight();
  if (!defaultLight)
    return;
  if (typeof defaultLight === "string" && defaultLight !== "default") {
    if (defaultLight === "studio")
      defaultEnvironment.texture = "https://unpkg.com/lingo3d-textures@1.0.0/assets/studio.jpg";
    else
      defaultEnvironment.texture = defaultLight;
    return () => {
      defaultEnvironment.texture = void 0;
    };
  }
  const skylight = new HemisphereLight(16777215, 6710886);
  scene_default.add(skylight);
  const light = new DirectionalLight(16777215, 0.5);
  light.position.set(0, 1, 1);
  scene_default.add(light);
  const handle = getDefaultLightScale((scale) => {
    skylight.intensity = scale;
    light.intensity = scale * 0.5;
  });
  return () => {
    skylight.dispose();
    scene_default.remove(skylight);
    light.dispose();
    scene_default.remove(light);
    handle.cancel();
  };
}, [getDefaultLight]);

// node_modules/lingo3d/lib/states/useDefaultFog.js
var [setDefaultFog, getDefaultFog] = store(void 0);

// node_modules/lingo3d/lib/engine/scene/defaultFog.js
var defaultFog_default = {};
createEffect(() => {
  const defaultFog = getDefaultFog();
  if (!defaultFog)
    return;
  scene_default.fog = new Fog(defaultFog, 0, 100);
  return () => {
    scene_default.fog = null;
  };
}, [getDefaultFog]);

// node_modules/lingo3d/lib/display/utils/loaders/loadCubeTexture.js
var cache2 = /* @__PURE__ */ new Map();
var loader = new CubeTextureLoader();
var loadCubeTexture_default = (urls) => forceGet(cache2, urls.join(","), () => {
  increaseLoadingCount();
  return loader.load(urls, decreaseLoadingCount, handleProgress, decreaseLoadingCount);
});

// node_modules/lingo3d/lib/states/useBackgroundImage.js
var [setBackgroundImage, getBackgroundImage] = store(void 0);

// node_modules/lingo3d/lib/states/useSkyboxStack.js
var [setSkyboxStack, getSkyboxStack] = store([]);
var pushSkyboxStack = push(setSkyboxStack, getSkyboxStack);
var pullSkyboxStack = pull(setSkyboxStack, getSkyboxStack);

// node_modules/lingo3d/lib/engine/scene/background.js
var background_default = {};
createEffect(() => {
  var _a;
  const image = getBackgroundImage();
  const color = getBackgroundColor();
  const skybox = (_a = last(getSkyboxStack())) == null ? void 0 : _a.texture;
  if (skybox) {
    if (Array.isArray(skybox))
      scene_default.background = loadCubeTexture_default(skybox);
    else {
      let proceed = true;
      const texture = loadTexture_default(skybox, () => proceed && (scene_default.background = texture));
      texture.mapping = EquirectangularReflectionMapping;
      return () => {
        proceed = false;
      };
    }
  } else if (image)
    scene_default.background = loadTexture_default(image);
  else if (color) {
    if (color === "transparent")
      scene_default.background = null;
    else
      scene_default.background = new Color(color);
  } else
    scene_default.background = new Color("black");
}, [getBackgroundColor, getBackgroundImage, getSkyboxStack]);

// node_modules/lingo3d/lib/engine/scene/index.js
preventTreeShake([defaultLight_default, defaultFog_default, background_default]);
var scene_default2 = scene_default;

// node_modules/lingo3d/lib/states/useGravity.js
var [setGravity, getGravity] = store(20);

// node_modules/lingo3d/lib/states/usePhysicsWorld.js
var [setPhysicsWorld, getPhysicsWorld] = store(void 0);

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/loadCannon.js
var loadCannon_default = lazy(async () => {
  const { World, GSSolver, SplitSolver, NaiveBroadphase, Material, ContactMaterial, Body, Vec3, Box, Sphere, Cylinder } = await import("./cannon-es-PJGTBNZC.js");
  const world = new World();
  getGravity((gravity) => world.gravity.set(0, -gravity, 0));
  world.quatNormalizeSkip = 0;
  world.quatNormalizeFast = false;
  const solver = new GSSolver();
  world.defaultContactMaterial.contactEquationStiffness = 1e9;
  world.defaultContactMaterial.contactEquationRelaxation = 4;
  solver.iterations = 7;
  solver.tolerance = 0.1;
  const split = true;
  if (split)
    world.solver = new SplitSolver(solver);
  else
    world.solver = solver;
  world.broadphase = new NaiveBroadphase();
  const [defaultMaterial] = world.defaultContactMaterial.materials;
  const slipperyMaterial = new Material("slipperyMaterial");
  world.addContactMaterial(new ContactMaterial(slipperyMaterial, slipperyMaterial, {
    friction: 0,
    restitution: 0
  }));
  world.addContactMaterial(new ContactMaterial(slipperyMaterial, defaultMaterial, {
    friction: 1e-3,
    restitution: 0
  }));
  setPhysicsWorld(world);
  return { world, defaultMaterial, slipperyMaterial, Body, Vec3, Box, Sphere, Cylinder };
});

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/cannonLoop.js
var cannonSet = /* @__PURE__ */ new Set();
var cannonContactMap = /* @__PURE__ */ new Map();
var cannonContactBodies = /* @__PURE__ */ new WeakSet();
var makeWeakSet = () => /* @__PURE__ */ new WeakSet();
var dt = 1 / 60;
createEffect(function() {
  if (getEditorActive())
    return;
  const world = getPhysicsWorld();
  if (!world)
    return;
  const handle = onBeforeRender(() => {
    for (const item of cannonSet) {
      const body = item.cannonBody;
      if ("_mAV" in item) {
        const { x, y, z } = item._mAV;
        const { angularVelocity } = body;
        if (angularVelocity.x > x)
          angularVelocity.x = x;
        else if (angularVelocity.x < -x)
          angularVelocity.x = -x;
        if (angularVelocity.y > y)
          angularVelocity.y = y;
        else if (angularVelocity.y < -y)
          angularVelocity.y = -y;
        if (angularVelocity.z > z)
          angularVelocity.z = z;
        else if (angularVelocity.z < -z)
          angularVelocity.z = -z;
      }
      if ("_mV" in item) {
        const { x, y, z } = item._mV;
        const { velocity } = body;
        if (velocity.x > x)
          velocity.x = x;
        else if (velocity.x < -x)
          velocity.x = -x;
        if (velocity.y > y)
          velocity.y = y;
        else if (velocity.y < -y)
          velocity.y = -y;
        if (velocity.z > z)
          velocity.z = z;
        else if (velocity.z < -z)
          velocity.z = -z;
      }
      const { position, rotation } = item.physicsUpdate;
      item.physicsUpdate = {};
      if (position) {
        if (position.x) {
          body.position.x = item.outerObject3d.position.x;
          body.velocity.x = 0;
          body.force.x = 0;
        }
        if (position.y) {
          body.position.y = item.outerObject3d.position.y;
          body.velocity.y = 0;
          body.force.y = 0;
        }
        if (position.z) {
          body.position.z = item.outerObject3d.position.z;
          body.velocity.z = 0;
          body.force.z = 0;
        }
      }
      item.outerObject3d.position.copy(body.position);
      if (rotation) {
        if (rotation.x) {
          body.angularVelocity.x = 0;
          body.torque.x = 0;
        }
        if (rotation.y) {
          body.angularVelocity.y = 0;
          body.torque.y = 0;
        }
        if (rotation.z) {
          body.angularVelocity.z = 0;
          body.torque.z = 0;
        }
        body.quaternion.copy(item.outerObject3d.quaternion);
      } else
        item.outerObject3d.quaternion.copy(body.quaternion);
    }
    world.step(dt);
    cannonContactMap.clear();
    for (const contact of world.contacts)
      forceGet(cannonContactMap, contact.bi, makeWeakSet).add(contact.bj);
  });
  return () => {
    handle.cancel();
  };
}, [getPhysicsWorld, getEditorActive]);

export {
  Environment,
  loadTexture_default,
  setDefaultFog,
  getDefaultFog,
  setBackgroundImage,
  getBackgroundImage,
  setSkyboxStack,
  getSkyboxStack,
  pushSkyboxStack,
  pullSkyboxStack,
  scene_default2 as scene_default,
  setGravity,
  getGravity,
  loadCannon_default,
  cannonSet,
  cannonContactMap,
  cannonContactBodies
};
//# sourceMappingURL=chunk-VAFQCDDA.js.map
