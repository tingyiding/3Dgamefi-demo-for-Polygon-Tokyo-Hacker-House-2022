{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/SkeletonUtils.js", "../../lingo3d/src/display/utils/cloneSkinnedMesh.ts"],
  "sourcesContent": ["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.update( delta );\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction getSkeletonOffsets( target, source, options = {} ) {\n\n\tconst targetParentPos = new Vector3(),\n\t\ttargetPos = new Vector3(),\n\t\tsourceParentPos = new Vector3(),\n\t\tsourcePos = new Vector3(),\n\t\ttargetDir = new Vector2(),\n\t\tsourceDir = new Vector2();\n\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst nameKeys = Object.keys( options.names ),\n\t\tnameValues = Object.values( options.names ),\n\t\tsourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target ),\n\t\toffsets = [];\n\n\tlet bone, boneTo,\n\t\tname, i;\n\n\ttarget.skeleton.pose();\n\n\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\tconst boneParent = getNearestBone( bone.parent, nameKeys ),\n\t\t\t\tboneToParent = getNearestBone( boneTo.parent, nameValues );\n\n\t\t\tboneParent.updateMatrixWorld();\n\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\ttargetDir.subVectors(\n\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tsourceDir.subVectors(\n\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tconst laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\tconst offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\tnew Euler(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlaterialAngle\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tbone.matrix.multiply( offset );\n\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\tbone.updateMatrixWorld();\n\n\t\t\toffsets[ name ] = offset;\n\n\t\t}\n\n\t}\n\n\treturn offsets;\n\n}\n\nfunction renameBones( skeleton, names ) {\n\n\tconst bones = getBones( skeleton );\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tconst bone = bones[ i ];\n\n\t\tif ( names[ bone.name ] ) {\n\n\t\t\tbone.name = names[ bone.name ];\n\n\t\t}\n\n\t}\n\n\treturn this;\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getNearestBone( bone, names ) {\n\n\twhile ( bone.isBone ) {\n\n\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\tbone = bone.parent;\n\n\t}\n\n}\n\nfunction findBoneTrackData( name, tracks ) {\n\n\tconst regexp = /\\[(.*)\\]\\.(.*)/,\n\t\tresult = { name: name };\n\n\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t// 1 is track name\n\t\t// 2 is track type\n\t\tconst trackData = regexp.exec( tracks[ i ].name );\n\n\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getEqualsBonesNames( skeleton, targetSkeleton ) {\n\n\tconst sourceBones = getBones( skeleton ),\n\t\ttargetBones = getBones( targetSkeleton ),\n\t\tbones = [];\n\n\tsearch : for ( let i = 0; i < sourceBones.length; i ++ ) {\n\n\t\tconst boneName = sourceBones[ i ].name;\n\n\t\tfor ( let j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\tbones.push( boneName );\n\n\t\t\t\tcontinue search;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bones;\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tgetHelperFromSkeleton,\n\tgetSkeletonOffsets,\n\trenameBones,\n\tgetBones,\n\tgetBoneByName,\n\tgetNearestBone,\n\tfindBoneTrackData,\n\tgetEqualsBonesNames,\n\tclone,\n};\n", null],
  "mappings": ";AAihBA,eAAgB,QAAS;AAExB,QAAM,eAAe,oBAAI,IAAI;AAC7B,QAAM,cAAc,oBAAI,IAAI;AAE5B,QAAM,SAAQ,OAAO,MAAM;AAE3B,mBAAkB,QAAQ,QAAO,SAAW,YAAY,YAAa;AAEpE,iBAAa,IAAK,YAAY,UAAW;AACzC,gBAAY,IAAK,YAAY,UAAW;AAAA,EAEzC,CAAE;AAEF,SAAM,SAAU,SAAW,MAAO;AAEjC,QAAK,CAAE,KAAK;AAAgB;AAE5B,UAAM,aAAa;AACnB,UAAM,aAAa,aAAa,IAAK,IAAK;AAC1C,UAAM,cAAc,WAAW,SAAS;AAExC,eAAW,WAAW,WAAW,SAAS,MAAM;AAChD,eAAW,WAAW,KAAM,WAAW,UAAW;AAElD,eAAW,SAAS,QAAQ,YAAY,IAAK,SAAW,MAAO;AAE9D,aAAO,YAAY,IAAK,IAAK;AAAA,IAE9B,CAAE;AAEF,eAAW,KAAM,WAAW,UAAU,WAAW,UAAW;AAAA,EAE7D,CAAE;AAEF,SAAO;AAER;AAKA,0BAA2B,GAAG,GAAG,UAAW;AAE3C,WAAU,GAAG,CAAE;AAEf,WAAU,IAAI,GAAG,IAAI,EAAE,SAAS,QAAQ,KAAO;AAE9C,qBAAkB,EAAE,SAAU,IAAK,EAAE,SAAU,IAAK,QAAS;AAAA,EAE9D;AAED;;;AClkBO,IAAM,iBAAiB,oBAAI,QAAO;AAEzC,IAAA,2BAAe,CAAqB,QAAW,QAAiB,aAAa,OAAO,eAAiB;AAEjG,QAAM,SAAQ,SAAS,OAAO,MAAK,IAAK,AAAc,MAAM,MAAM;AAClE,GAAC,UAAU,eAAe,IAAI,MAAK;AACnC,SAAM,aAAa;AACnB,SAAO;AACX;",
  "names": []
}
