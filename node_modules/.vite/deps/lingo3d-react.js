import {
  setWasmPath
} from "./chunk-QK3ANYOA.js";
import {
  skinnedMeshSet
} from "./chunk-GVZ5LGXU.js";
import {
  require_react_dom
} from "./chunk-S7QNO6ZA.js";
import {
  require_react
} from "./chunk-RPLKCXPX.js";
import {
  getRepulsion,
  setRepulsion
} from "./chunk-PHLDVABJ.js";
import {
  AnimationManager,
  CopyShader,
  EffectComposer,
  FullScreenQuad,
  ObjectManager,
  Pass,
  Point3d,
  PositionedItem,
  Primitive_default,
  ShaderPass,
  SimpleObjectManager_default,
  TexturedBasicMixin,
  TexturedStandardMixin,
  addBloom,
  addOutline,
  addSSR,
  addSelectionFrozen,
  bloomPtr,
  clearSelectionFrozen,
  deg2Rad,
  deleteBloom,
  deleteOutline,
  deleteSSR,
  distance,
  emitSelectionTarget,
  endPoint,
  getActualScale_default,
  getCenter_default,
  getMultipleSelection,
  getMultipleSelectionTargets,
  getObject3d,
  getOutlineColor,
  getOutlineHiddenColor,
  getOutlinePattern,
  getOutlinePulse,
  getOutlineStrength,
  getOutlineThickness,
  getSelectionFrozen,
  getSelectionTarget,
  getSelectiveBloomComposer,
  getTransformControlsDragging,
  idMap,
  isMeshItem,
  isPositionedItem,
  multipleSelectionGroupManagers,
  objectManagerDefaults,
  objectManagerSchema,
  objectURLMapperPtr,
  onSelectionTarget,
  outlinePass_default,
  outlinePtr,
  point2Vec,
  positionedDefaults,
  positionedSchema,
  primitiveDefaults,
  primitiveSchema,
  rad2Deg,
  renderSelectiveBloom_default,
  rotatePoint,
  setMultipleSelection,
  setMultipleSelectionTargets,
  setOutlineColor,
  setOutlineHiddenColor,
  setOutlinePattern,
  setOutlinePulse,
  setOutlineStrength,
  setOutlineThickness,
  setSelectionFrozen,
  setSelectionTarget,
  setTransformControlsDragging,
  ssrPass_default,
  ssrPtr,
  texturedBasicDefaults,
  texturedBasicSchema,
  texturedStandardDefaults,
  texturedStandardSchema,
  vec2Point
} from "./chunk-KPG43TSV.js";
import {
  Mouse,
  clientToWorld_default,
  container,
  emitEditorMountChange,
  getAutoMount,
  getExposure,
  getPBR,
  getPixelRatio,
  getPixelRatioComputed,
  getSecondaryCamera,
  mouse_default,
  setAutoMount,
  setExposure,
  setPBR,
  setPixelRatio,
  setSecondaryCamera,
  setSelectionBlockMouse
} from "./chunk-NMHDQJPG.js";
import {
  box3,
  euler,
  quaternion,
  quaternion_,
  ray,
  vector3,
  vector3_,
  wireframeMaterial
} from "./chunk-NPOYVG57.js";
import {
  Environment,
  getBackgroundImage,
  getDefaultFog,
  getGravity,
  getSkyboxStack,
  loadCannon_default,
  loadTexture_default,
  pullSkyboxStack,
  pushSkyboxStack,
  scene_default,
  setBackgroundImage,
  setDefaultFog,
  setGravity,
  setSkyboxStack
} from "./chunk-VAFQCDDA.js";
import {
  Appendable,
  EventLoopItem,
  appendableRoot,
  emitSceneGraphChange,
  eventLoopDefaults,
  eventLoopSchema,
  getAntiAlias,
  getBackgroundColor,
  getDefaultLight,
  getDefaultLightScale,
  getLogarithmicDepth,
  getRenderer,
  hiddenAppendables,
  loop,
  nonEditorSchemaSet_default,
  onSceneGraphChange,
  setAntiAlias,
  setBackgroundColor,
  setDefaultLight,
  setDefaultLightScale,
  setEffectComposerPassCount,
  setLogarithmicDepth,
  timer
} from "./chunk-MO2ISMHQ.js";
import {
  bytesLoaded_default,
  decreaseLoadingCount,
  getLoadingCount,
  handleProgress,
  increaseLoadingCount
} from "./chunk-2PNJ75KS.js";
import {
  DUMMY_URL,
  HEIGHT,
  MAX_POLAR_ANGLE,
  MIN_POLAR_ANGLE,
  WIDTH,
  YBOT_URL,
  camFar,
  camNear,
  diameterScaled,
  emitAfterRender,
  emitBeforeRender,
  flatGeomScaleZ,
  getCameraRendered,
  getCameraStack,
  getEditorActive,
  getResolution,
  getSelection,
  getVR,
  getWorldPosition_default,
  getWorldQuaternion_default,
  mainCamera_default,
  onAfterRender,
  onBeforeRender,
  pullCameraStack,
  pushCameraStack,
  radiusScaled,
  scaleDown,
  scaleUp,
  setCameraFrom,
  setCameraStack,
  setEditorActive,
  setSelection,
  updateCameraAspect
} from "./chunk-J7HA7FW3.js";
import {
  Cancellable,
  Reactive,
  Resolvable,
  applyMixins,
  assertExhaustive,
  createEffect,
  debounce,
  event_default,
  forceGet,
  import_lodash,
  last,
  lazy,
  preventTreeShake,
  pull,
  pull2,
  push,
  splitFileName,
  store,
  type
} from "./chunk-NXCTIVNA.js";
import {
  AddEquation,
  AdditiveBlending,
  AmbientLight,
  AudioListener,
  AudioLoader,
  BackSide,
  BoxGeometry,
  BoxHelper,
  BufferGeometry,
  CameraHelper,
  CircleGeometry,
  Color,
  ConeGeometry,
  CustomBlending,
  CylinderGeometry,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DstAlphaFactor,
  DstColorFactor,
  ExtrudeGeometry,
  Float32BufferAttribute,
  GridHelper,
  Group,
  HemisphereLight,
  HemisphereLightHelper,
  Line,
  LineBasicMaterial,
  LinearFilter,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshNormalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  NoBlending,
  Object3D,
  OctahedronGeometry,
  PerspectiveCamera,
  PlaneGeometry,
  PointLight,
  PointLightHelper,
  PositionalAudio,
  Quaternion,
  RGBADepthPacking,
  RectAreaLight,
  ShaderMaterial,
  SkeletonHelper,
  SphereGeometry,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  TetrahedronGeometry,
  Texture,
  TorusGeometry,
  UniformsUtils,
  UnsignedShortType,
  Vector2,
  Vector3,
  WebGLRenderTarget,
  ZeroFactor
} from "./chunk-57VJUUAA.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-XA4H47DG.js";

// node_modules/tweakpane/dist/tweakpane.js
var require_tweakpane = __commonJS({
  "node_modules/tweakpane/dist/tweakpane.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Tweakpane = {}));
    })(exports, function(exports2) {
      "use strict";
      class Semver {
        constructor(text) {
          const [core, prerelease] = text.split("-");
          const coreComps = core.split(".");
          this.major = parseInt(coreComps[0], 10);
          this.minor = parseInt(coreComps[1], 10);
          this.patch = parseInt(coreComps[2], 10);
          this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }
        toString() {
          const core = [this.major, this.minor, this.patch].join(".");
          return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
        }
      }
      class BladeApi {
        constructor(controller) {
          this.controller_ = controller;
        }
        get element() {
          return this.controller_.view.element;
        }
        get disabled() {
          return this.controller_.viewProps.get("disabled");
        }
        set disabled(disabled) {
          this.controller_.viewProps.set("disabled", disabled);
        }
        get hidden() {
          return this.controller_.viewProps.get("hidden");
        }
        set hidden(hidden) {
          this.controller_.viewProps.set("hidden", hidden);
        }
        dispose() {
          this.controller_.viewProps.set("disposed", true);
        }
      }
      class TpEvent {
        constructor(target) {
          this.target = target;
        }
      }
      class TpChangeEvent extends TpEvent {
        constructor(target, value, presetKey, last2) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
          this.last = last2 !== null && last2 !== void 0 ? last2 : true;
        }
      }
      class TpUpdateEvent extends TpEvent {
        constructor(target, value, presetKey) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
        }
      }
      class TpFoldEvent extends TpEvent {
        constructor(target, expanded) {
          super(target);
          this.expanded = expanded;
        }
      }
      class TpTabSelectEvent extends TpEvent {
        constructor(target, index2) {
          super(target);
          this.index = index2;
        }
      }
      function forceCast(v4) {
        return v4;
      }
      function isEmpty(value) {
        return value === null || value === void 0;
      }
      function deepEqualsArray(a1, a22) {
        if (a1.length !== a22.length) {
          return false;
        }
        for (let i4 = 0; i4 < a1.length; i4++) {
          if (a1[i4] !== a22[i4]) {
            return false;
          }
        }
        return true;
      }
      const CREATE_MESSAGE_MAP = {
        alreadydisposed: () => "View has been already disposed",
        invalidparams: (context) => `Invalid parameters for '${context.name}'`,
        nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
        nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
        notbindable: () => `Value is not bindable`,
        propertynotfound: (context) => `Property '${context.name}' not found`,
        shouldneverhappen: () => "This error should never happen"
      };
      class TpError {
        constructor(config) {
          var _a2;
          this.message = (_a2 = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a2 !== void 0 ? _a2 : "Unexpected error";
          this.name = this.constructor.name;
          this.stack = new Error(this.message).stack;
          this.type = config.type;
        }
        static alreadyDisposed() {
          return new TpError({ type: "alreadydisposed" });
        }
        static notBindable() {
          return new TpError({
            type: "notbindable"
          });
        }
        static propertyNotFound(name) {
          return new TpError({
            type: "propertynotfound",
            context: {
              name
            }
          });
        }
        static shouldNeverHappen() {
          return new TpError({ type: "shouldneverhappen" });
        }
      }
      class BindingTarget {
        constructor(obj, key, opt_id) {
          this.obj_ = obj;
          this.key_ = key;
          this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
        }
        static isBindable(obj) {
          if (obj === null) {
            return false;
          }
          if (typeof obj !== "object") {
            return false;
          }
          return true;
        }
        get key() {
          return this.key_;
        }
        get presetKey() {
          return this.presetKey_;
        }
        read() {
          return this.obj_[this.key_];
        }
        write(value) {
          this.obj_[this.key_] = value;
        }
        writeProperty(name, value) {
          const valueObj = this.read();
          if (!BindingTarget.isBindable(valueObj)) {
            throw TpError.notBindable();
          }
          if (!(name in valueObj)) {
            throw TpError.propertyNotFound(name);
          }
          valueObj[name] = value;
        }
      }
      class ButtonApi extends BladeApi {
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get title() {
          var _a2;
          return (_a2 = this.controller_.valueController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
        }
        set title(title) {
          this.controller_.valueController.props.set("title", title);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          const emitter = this.controller_.valueController.emitter;
          emitter.on(eventName, () => {
            bh(new TpEvent(this));
          });
          return this;
        }
      }
      class Emitter {
        constructor() {
          this.observers_ = {};
        }
        on(eventName, handler) {
          let observers2 = this.observers_[eventName];
          if (!observers2) {
            observers2 = this.observers_[eventName] = [];
          }
          observers2.push({
            handler
          });
          return this;
        }
        off(eventName, handler) {
          const observers2 = this.observers_[eventName];
          if (observers2) {
            this.observers_[eventName] = observers2.filter((observer) => {
              return observer.handler !== handler;
            });
          }
          return this;
        }
        emit(eventName, event2) {
          const observers2 = this.observers_[eventName];
          if (!observers2) {
            return;
          }
          observers2.forEach((observer) => {
            observer.handler(event2);
          });
        }
      }
      const PREFIX = "tp";
      function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
          return [
            PREFIX,
            "-",
            viewName,
            "v",
            opt_elementName ? `_${opt_elementName}` : "",
            opt_modifier ? `-${opt_modifier}` : ""
          ].join("");
        };
        return fn;
      }
      function compose(h1, h22) {
        return (input) => h22(h1(input));
      }
      function extractValue(ev) {
        return ev.rawValue;
      }
      function bindValue(value, applyValue) {
        value.emitter.on("change", compose(extractValue, applyValue));
        applyValue(value.rawValue);
      }
      function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
      }
      function applyClass(elem, className2, active) {
        if (active) {
          elem.classList.add(className2);
        } else {
          elem.classList.remove(className2);
        }
      }
      function valueToClassName(elem, className2) {
        return (value) => {
          applyClass(elem, className2, value);
        };
      }
      function bindValueToTextContent(value, elem) {
        bindValue(value, (text) => {
          elem.textContent = text !== null && text !== void 0 ? text : "";
        });
      }
      const className$q = ClassName("btn");
      class ButtonView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$q());
          config.viewProps.bindClassModifiers(this.element);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$q("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$q("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
        }
      }
      class ButtonController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new ButtonView(doc, {
            props: this.props,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class BoundValue {
        constructor(initialValue, config) {
          var _a2;
          this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
          this.equals_ = (_a2 = config === null || config === void 0 ? void 0 : config.equals) !== null && _a2 !== void 0 ? _a2 : (v1, v22) => v1 === v22;
          this.emitter = new Emitter();
          this.rawValue_ = initialValue;
        }
        get constraint() {
          return this.constraint_;
        }
        get rawValue() {
          return this.rawValue_;
        }
        set rawValue(rawValue) {
          this.setRawValue(rawValue, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(rawValue, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
          const changed = !this.equals_(this.rawValue_, constrainedValue);
          if (!changed && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.rawValue_ = constrainedValue;
          this.emitter.emit("change", {
            options: opts,
            rawValue: constrainedValue,
            sender: this
          });
        }
      }
      class PrimitiveValue {
        constructor(initialValue) {
          this.emitter = new Emitter();
          this.value_ = initialValue;
        }
        get rawValue() {
          return this.value_;
        }
        set rawValue(value) {
          this.setRawValue(value, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(value, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          if (this.value_ === value && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.value_ = value;
          this.emitter.emit("change", {
            options: opts,
            rawValue: this.value_,
            sender: this
          });
        }
      }
      function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals) {
          return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
      }
      class ValueMap {
        constructor(valueMap) {
          this.emitter = new Emitter();
          this.valMap_ = valueMap;
          for (const key in this.valMap_) {
            const v4 = this.valMap_[key];
            v4.emitter.on("change", () => {
              this.emitter.emit("change", {
                key,
                sender: this
              });
            });
          }
        }
        static createCore(initialValue) {
          const keys = Object.keys(initialValue);
          return keys.reduce((o4, key) => {
            return Object.assign(o4, {
              [key]: createValue(initialValue[key])
            });
          }, {});
        }
        static fromObject(initialValue) {
          const core = this.createCore(initialValue);
          return new ValueMap(core);
        }
        get(key) {
          return this.valMap_[key].rawValue;
        }
        set(key, value) {
          this.valMap_[key].rawValue = value;
        }
        value(key) {
          return this.valMap_[key];
        }
      }
      function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key) => {
          if (tmp === void 0) {
            return void 0;
          }
          const parser = keyToParserMap[key];
          const result2 = parser(value[key]);
          return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key]: result2.value }) : void 0;
        }, {});
        return forceCast(result);
      }
      function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
          if (tmp === void 0) {
            return void 0;
          }
          const result = parseItem(item);
          if (!result.succeeded || result.value === void 0) {
            return void 0;
          }
          return [...tmp, result.value];
        }, []);
      }
      function isObject(value) {
        if (value === null) {
          return false;
        }
        return typeof value === "object";
      }
      function createParamsParserBuilder(parse2) {
        return (optional) => (v4) => {
          if (!optional && v4 === void 0) {
            return {
              succeeded: false,
              value: void 0
            };
          }
          if (optional && v4 === void 0) {
            return {
              succeeded: true,
              value: void 0
            };
          }
          const result = parse2(v4);
          return result !== void 0 ? {
            succeeded: true,
            value: result
          } : {
            succeeded: false,
            value: void 0
          };
        };
      }
      function createParamsParserBuilders(optional) {
        return {
          custom: (parse2) => createParamsParserBuilder(parse2)(optional),
          boolean: createParamsParserBuilder((v4) => typeof v4 === "boolean" ? v4 : void 0)(optional),
          number: createParamsParserBuilder((v4) => typeof v4 === "number" ? v4 : void 0)(optional),
          string: createParamsParserBuilder((v4) => typeof v4 === "string" ? v4 : void 0)(optional),
          function: createParamsParserBuilder((v4) => typeof v4 === "function" ? v4 : void 0)(optional),
          constant: (value) => createParamsParserBuilder((v4) => v4 === value ? value : void 0)(optional),
          raw: createParamsParserBuilder((v4) => v4)(optional),
          object: (keyToParserMap) => createParamsParserBuilder((v4) => {
            if (!isObject(v4)) {
              return void 0;
            }
            return parseObject(v4, keyToParserMap);
          })(optional),
          array: (itemParser) => createParamsParserBuilder((v4) => {
            if (!Array.isArray(v4)) {
              return void 0;
            }
            return parseArray(v4, itemParser);
          })(optional)
        };
      }
      const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };
      function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : void 0;
      }
      function disposeElement(elem) {
        if (elem && elem.parentElement) {
          elem.parentElement.removeChild(elem);
        }
        return null;
      }
      function getAllBladePositions() {
        return ["veryfirst", "first", "last", "verylast"];
      }
      const className$p = ClassName("");
      const POS_TO_CLASS_NAME_MAP = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
      };
      class BladeController {
        constructor(config) {
          this.parent_ = null;
          this.blade = config.blade;
          this.view = config.view;
          this.viewProps = config.viewProps;
          const elem = this.view.element;
          this.blade.value("positions").emitter.on("change", () => {
            getAllBladePositions().forEach((pos) => {
              elem.classList.remove(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
            this.blade.get("positions").forEach((pos) => {
              elem.classList.add(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
          });
          this.viewProps.handleDispose(() => {
            disposeElement(elem);
          });
        }
        get parent() {
          return this.parent_;
        }
      }
      const SVG_NS = "http://www.w3.org/2000/svg";
      function forceReflow(element) {
        element.offsetHeight;
      }
      function disableTransitionTemporarily(element, callback) {
        const t5 = element.style.transition;
        element.style.transition = "none";
        callback();
        element.style.transition = t5;
      }
      function supportsTouch(doc) {
        return doc.ontouchstart !== void 0;
      }
      function getGlobalObject() {
        return new Function("return this")();
      }
      function getWindowDocument() {
        const globalObj = forceCast(getGlobalObject());
        return globalObj.document;
      }
      function getCanvasContext(canvasElement) {
        const win = canvasElement.ownerDocument.defaultView;
        if (!win) {
          return null;
        }
        const isBrowser2 = "document" in win;
        return isBrowser2 ? canvasElement.getContext("2d") : null;
      }
      const ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };
      function createSvgIconElement(document2, iconId) {
        const elem = document2.createElementNS(SVG_NS, "svg");
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
      }
      function insertElementAt(parentElement, element, index2) {
        parentElement.insertBefore(element, parentElement.children[index2]);
      }
      function removeElement(element) {
        if (element.parentElement) {
          element.parentElement.removeChild(element);
        }
      }
      function removeChildElements(element) {
        while (element.children.length > 0) {
          element.removeChild(element.children[0]);
        }
      }
      function removeChildNodes(element) {
        while (element.childNodes.length > 0) {
          element.removeChild(element.childNodes[0]);
        }
      }
      function findNextTarget(ev) {
        if (ev.relatedTarget) {
          return forceCast(ev.relatedTarget);
        }
        if ("explicitOriginalTarget" in ev) {
          return ev.explicitOriginalTarget;
        }
        return null;
      }
      const className$o = ClassName("lbl");
      function createLabelNode(doc, label) {
        const frag = doc.createDocumentFragment();
        const lineNodes = label.split("\n").map((line) => {
          return doc.createTextNode(line);
        });
        lineNodes.forEach((lineNode, index2) => {
          if (index2 > 0) {
            frag.appendChild(doc.createElement("br"));
          }
          frag.appendChild(lineNode);
        });
        return frag;
      }
      class LabelView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$o());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("div");
          labelElem.classList.add(className$o("l"));
          bindValueMap(config.props, "label", (value) => {
            if (isEmpty(value)) {
              this.element.classList.add(className$o(void 0, "nol"));
            } else {
              this.element.classList.remove(className$o(void 0, "nol"));
              removeChildNodes(labelElem);
              labelElem.appendChild(createLabelNode(doc, value));
            }
          });
          this.element.appendChild(labelElem);
          this.labelElement = labelElem;
          const valueElem = doc.createElement("div");
          valueElem.classList.add(className$o("v"));
          this.element.appendChild(valueElem);
          this.valueElement = valueElem;
        }
      }
      class LabelController extends BladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      const ButtonBladePlugin = {
        id: "button",
        type: "blade",
        accept(params) {
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            title: p3.required.string,
            view: p3.required.constant("button"),
            label: p3.optional.string
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new ButtonController(args.document, {
              props: ValueMap.fromObject({
                title: args.params.title
              }),
              viewProps: args.viewProps
            })
          });
        },
        api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof ButtonController)) {
            return null;
          }
          return new ButtonApi(args.controller);
        }
      };
      class ValueBladeController extends BladeController {
        constructor(config) {
          super(config);
          this.value = config.value;
        }
      }
      function createBlade() {
        return new ValueMap({
          positions: createValue([], {
            equals: deepEqualsArray
          })
        });
      }
      class Foldable extends ValueMap {
        constructor(valueMap) {
          super(valueMap);
        }
        static create(expanded) {
          const coreObj = {
            completed: true,
            expanded,
            expandedHeight: null,
            shouldFixHeight: false,
            temporaryExpanded: null
          };
          const core = ValueMap.createCore(coreObj);
          return new Foldable(core);
        }
        get styleExpanded() {
          var _a2;
          return (_a2 = this.get("temporaryExpanded")) !== null && _a2 !== void 0 ? _a2 : this.get("expanded");
        }
        get styleHeight() {
          if (!this.styleExpanded) {
            return "0";
          }
          const exHeight = this.get("expandedHeight");
          if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
            return `${exHeight}px`;
          }
          return "auto";
        }
        bindExpandedClass(elem, expandedClassName) {
          const onExpand = () => {
            const expanded = this.styleExpanded;
            if (expanded) {
              elem.classList.add(expandedClassName);
            } else {
              elem.classList.remove(expandedClassName);
            }
          };
          bindValueMap(this, "expanded", onExpand);
          bindValueMap(this, "temporaryExpanded", onExpand);
        }
        cleanUpTransition() {
          this.set("shouldFixHeight", false);
          this.set("expandedHeight", null);
          this.set("completed", true);
        }
      }
      function computeExpandedFolderHeight(folder, containerElement) {
        let height = 0;
        disableTransitionTemporarily(containerElement, () => {
          folder.set("expandedHeight", null);
          folder.set("temporaryExpanded", true);
          forceReflow(containerElement);
          height = containerElement.clientHeight;
          folder.set("temporaryExpanded", null);
          forceReflow(containerElement);
        });
        return height;
      }
      function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
      }
      function bindFoldable(foldable, elem) {
        foldable.value("expanded").emitter.on("beforechange", () => {
          foldable.set("completed", false);
          if (isEmpty(foldable.get("expandedHeight"))) {
            foldable.set("expandedHeight", computeExpandedFolderHeight(foldable, elem));
          }
          foldable.set("shouldFixHeight", true);
          forceReflow(elem);
        });
        foldable.emitter.on("change", () => {
          applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener("transitionend", (ev) => {
          if (ev.propertyName !== "height") {
            return;
          }
          foldable.cleanUpTransition();
        });
      }
      class RackLikeApi extends BladeApi {
        constructor(controller, rackApi) {
          super(controller);
          this.rackApi_ = rackApi;
        }
      }
      function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
      }
      function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
      }
      function addSeparatorAsBlade(api, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
      }
      function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
      }
      class NestedOrderedSet {
        constructor(extract) {
          this.emitter = new Emitter();
          this.items_ = [];
          this.cache_ = /* @__PURE__ */ new Set();
          this.onSubListAdd_ = this.onSubListAdd_.bind(this);
          this.onSubListRemove_ = this.onSubListRemove_.bind(this);
          this.extract_ = extract;
        }
        get items() {
          return this.items_;
        }
        allItems() {
          return Array.from(this.cache_);
        }
        find(callback) {
          for (const item of this.allItems()) {
            if (callback(item)) {
              return item;
            }
          }
          return null;
        }
        includes(item) {
          return this.cache_.has(item);
        }
        add(item, opt_index) {
          if (this.includes(item)) {
            throw TpError.shouldNeverHappen();
          }
          const index2 = opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index2, 0, item);
          this.cache_.add(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.on("add", this.onSubListAdd_);
            subList.emitter.on("remove", this.onSubListRemove_);
            subList.allItems().forEach((item2) => {
              this.cache_.add(item2);
            });
          }
          this.emitter.emit("add", {
            index: index2,
            item,
            root: this,
            target: this
          });
        }
        remove(item) {
          const index2 = this.items_.indexOf(item);
          if (index2 < 0) {
            return;
          }
          this.items_.splice(index2, 1);
          this.cache_.delete(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.off("add", this.onSubListAdd_);
            subList.emitter.off("remove", this.onSubListRemove_);
          }
          this.emitter.emit("remove", {
            index: index2,
            item,
            root: this,
            target: this
          });
        }
        onSubListAdd_(ev) {
          this.cache_.add(ev.item);
          this.emitter.emit("add", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
        onSubListRemove_(ev) {
          this.cache_.delete(ev.item);
          this.emitter.emit("remove", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
      }
      class InputBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingChange_ = this.onBindingChange_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("change", this.onBindingChange_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingChange_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
          });
        }
      }
      class InputBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
        }
      }
      class MonitorBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingUpdate_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
          });
        }
      }
      class MonitorBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
          this.viewProps.bindDisabled(this.binding.ticker);
          this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
        }
      }
      function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
          return api["apiSet_"];
        }
        if (api instanceof RackLikeApi) {
          return api["rackApi_"]["apiSet_"];
        }
        return null;
      }
      function getApiByController(apiSet, controller) {
        const api = apiSet.find((api2) => api2.controller_ === controller);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        return api;
      }
      function createBindingTarget(obj, key, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
          throw TpError.notBindable();
        }
        return new BindingTarget(obj, key, opt_id);
      }
      class RackApi extends BladeApi {
        constructor(controller, pool) {
          super(controller);
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          this.onRackInputChange_ = this.onRackInputChange_.bind(this);
          this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
          this.pool_ = pool;
          const rack = this.controller_.rack;
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          rack.emitter.on("inputchange", this.onRackInputChange_);
          rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
          rack.children.forEach((bc) => {
            this.setUpApi_(bc);
          });
        }
        get children() {
          return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
        }
        addInput(object, key, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
          const api = new InputBindingApi(bc);
          return this.add(api, params.index);
        }
        addMonitor(object, key, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
          const api = new MonitorBindingApi(bc);
          return forceCast(this.add(api, params.index));
        }
        addFolder(params) {
          return addFolderAsBlade(this, params);
        }
        addButton(params) {
          return addButtonAsBlade(this, params);
        }
        addSeparator(opt_params) {
          return addSeparatorAsBlade(this, opt_params);
        }
        addTab(params) {
          return addTabAsBlade(this, params);
        }
        add(api, opt_index) {
          this.controller_.rack.add(api.controller_, opt_index);
          const gapi = this.apiSet_.find((a5) => a5.controller_ === api.controller_);
          if (gapi) {
            this.apiSet_.remove(gapi);
          }
          this.apiSet_.add(api);
          return api;
        }
        remove(api) {
          this.controller_.rack.remove(api.controller_);
        }
        addBlade(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createBlade(doc, params);
          const api = this.pool_.createBladeApi(bc);
          return this.add(api, params.index);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpApi_(bc) {
          const api = this.apiSet_.find((api2) => api2.controller_ === bc);
          if (!api) {
            this.apiSet_.add(this.pool_.createBladeApi(bc));
          }
        }
        onRackAdd_(ev) {
          this.setUpApi_(ev.bladeController);
        }
        onRackRemove_(ev) {
          if (ev.isRoot) {
            const api = getApiByController(this.apiSet_, ev.bladeController);
            this.apiSet_.remove(api);
          }
        }
        onRackInputChange_(ev) {
          const bc = ev.bladeController;
          if (bc instanceof InputBindingController) {
            const api = getApiByController(this.apiSet_, bc);
            const binding = bc.binding;
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
            });
          } else if (bc instanceof ValueBladeController) {
            const api = getApiByController(this.apiSet_, bc);
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
            });
          }
        }
        onRackMonitorUpdate_(ev) {
          if (!(ev.bladeController instanceof MonitorBindingController)) {
            throw TpError.shouldNeverHappen();
          }
          const api = getApiByController(this.apiSet_, ev.bladeController);
          const binding = ev.bladeController.binding;
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
          });
        }
      }
      class FolderApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.emitter_ = new Emitter();
          this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
            this.emitter_.emit("fold", {
              event: new TpFoldEvent(this, ev.sender.rawValue)
            });
          });
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
        }
        get expanded() {
          return this.controller_.foldable.get("expanded");
        }
        set expanded(expanded) {
          this.controller_.foldable.set("expanded", expanded);
        }
        get title() {
          return this.controller_.props.get("title");
        }
        set title(title) {
          this.controller_.props.set("title", title);
        }
        get children() {
          return this.rackApi_.children;
        }
        addInput(object, key, opt_params) {
          return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
          return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          return this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class RackLikeController extends BladeController {
        constructor(config) {
          super({
            blade: config.blade,
            view: config.view,
            viewProps: config.rackController.viewProps
          });
          this.rackController = config.rackController;
        }
      }
      class PlainView {
        constructor(doc, config) {
          const className2 = ClassName(config.viewName);
          this.element = doc.createElement("div");
          this.element.classList.add(className2());
          config.viewProps.bindClassModifiers(this.element);
        }
      }
      function findInputBindingController(bcs, b4) {
        for (let i4 = 0; i4 < bcs.length; i4++) {
          const bc = bcs[i4];
          if (bc instanceof InputBindingController && bc.binding === b4) {
            return bc;
          }
        }
        return null;
      }
      function findMonitorBindingController(bcs, b4) {
        for (let i4 = 0; i4 < bcs.length; i4++) {
          const bc = bcs[i4];
          if (bc instanceof MonitorBindingController && bc.binding === b4) {
            return bc;
          }
        }
        return null;
      }
      function findValueBladeController(bcs, v4) {
        for (let i4 = 0; i4 < bcs.length; i4++) {
          const bc = bcs[i4];
          if (bc instanceof ValueBladeController && bc.value === v4) {
            return bc;
          }
        }
        return null;
      }
      function findSubRack(bc) {
        if (bc instanceof RackController) {
          return bc.rack;
        }
        if (bc instanceof RackLikeController) {
          return bc.rackController.rack;
        }
        return null;
      }
      function findSubBladeControllerSet(bc) {
        const rack = findSubRack(bc);
        return rack ? rack["bcSet_"] : null;
      }
      class BladeRack {
        constructor(blade) {
          var _a2;
          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
          this.onSetAdd_ = this.onSetAdd_.bind(this);
          this.onSetRemove_ = this.onSetRemove_.bind(this);
          this.onChildDispose_ = this.onChildDispose_.bind(this);
          this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
          this.onChildInputChange_ = this.onChildInputChange_.bind(this);
          this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
          this.onChildValueChange_ = this.onChildValueChange_.bind(this);
          this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
          this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
          this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
          this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
          this.emitter = new Emitter();
          this.blade_ = blade !== null && blade !== void 0 ? blade : null;
          (_a2 = this.blade_) === null || _a2 === void 0 ? void 0 : _a2.value("positions").emitter.on("change", this.onBladePositionsChange_);
          this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
          this.bcSet_.emitter.on("add", this.onSetAdd_);
          this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }
        get children() {
          return this.bcSet_.items;
        }
        add(bc, opt_index) {
          if (bc.parent) {
            bc.parent.remove(bc);
          }
          bc["parent_"] = this;
          this.bcSet_.add(bc, opt_index);
        }
        remove(bc) {
          bc["parent_"] = null;
          this.bcSet_.remove(bc);
        }
        find(controllerClass) {
          return forceCast(this.bcSet_.allItems().filter((bc) => {
            return bc instanceof controllerClass;
          }));
        }
        onSetAdd_(ev) {
          this.updatePositions_();
          const isRoot = ev.target === ev.root;
          this.emitter.emit("add", {
            bladeController: ev.item,
            index: ev.index,
            isRoot,
            sender: this
          });
          if (!isRoot) {
            return;
          }
          const bc = ev.item;
          bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
          bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
          bc.viewProps.handleDispose(this.onChildDispose_);
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.on("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.on("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.on("layout", this.onDescendantLayout_);
              emitter.on("inputchange", this.onDescendantInputChange_);
              emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        onSetRemove_(ev) {
          this.updatePositions_();
          const isRoot = ev.target === ev.root;
          this.emitter.emit("remove", {
            bladeController: ev.item,
            isRoot,
            sender: this
          });
          if (!isRoot) {
            return;
          }
          const bc = ev.item;
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.off("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.off("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.off("layout", this.onDescendantLayout_);
              emitter.off("inputchange", this.onDescendantInputChange_);
              emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        updatePositions_() {
          const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
          const firstVisibleItem = visibleItems[0];
          const lastVisibleItem = visibleItems[visibleItems.length - 1];
          this.bcSet_.items.forEach((bc) => {
            const ps = [];
            if (bc === firstVisibleItem) {
              ps.push("first");
              if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
                ps.push("veryfirst");
              }
            }
            if (bc === lastVisibleItem) {
              ps.push("last");
              if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
                ps.push("verylast");
              }
            }
            bc.blade.set("positions", ps);
          });
        }
        onChildPositionsChange_() {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildViewPropsChange_(_ev) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildDispose_() {
          const disposedUcs = this.bcSet_.items.filter((bc) => {
            return bc.viewProps.get("disposed");
          });
          disposedUcs.forEach((bc) => {
            this.bcSet_.remove(bc);
          });
        }
        onChildInputChange_(ev) {
          const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
          if (!bc) {
            throw TpError.shouldNeverHappen();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onChildMonitorUpdate_(ev) {
          const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
          if (!bc) {
            throw TpError.shouldNeverHappen();
          }
          this.emitter.emit("monitorupdate", {
            bladeController: bc,
            sender: this
          });
        }
        onChildValueChange_(ev) {
          const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
          if (!bc) {
            throw TpError.shouldNeverHappen();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onDescendantLayout_(_4) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onDescendantInputChange_(ev) {
          this.emitter.emit("inputchange", {
            bladeController: ev.bladeController,
            options: ev.options,
            sender: this
          });
        }
        onDescendantMonitorUpdate_(ev) {
          this.emitter.emit("monitorupdate", {
            bladeController: ev.bladeController,
            sender: this
          });
        }
        onBladePositionsChange_() {
          this.updatePositions_();
        }
      }
      class RackController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
            viewName: "brk",
            viewProps: config.viewProps
          }) }));
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          const rack = new BladeRack(config.root ? void 0 : config.blade);
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          this.rack = rack;
          this.viewProps.handleDispose(() => {
            for (let i4 = this.rack.children.length - 1; i4 >= 0; i4--) {
              const bc = this.rack.children[i4];
              bc.viewProps.set("disposed", true);
            }
          });
        }
        onRackAdd_(ev) {
          if (!ev.isRoot) {
            return;
          }
          insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
        }
        onRackRemove_(ev) {
          if (!ev.isRoot) {
            return;
          }
          removeElement(ev.bladeController.view.element);
        }
      }
      const bladeContainerClassName = ClassName("cnt");
      class FolderView {
        constructor(doc, config) {
          var _a2;
          this.className_ = ClassName((_a2 = config.viewName) !== null && _a2 !== void 0 ? _a2 : "fld");
          this.element = doc.createElement("div");
          this.element.classList.add(this.className_(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          this.foldable_ = config.foldable;
          this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
          bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(this.className_("b"));
          bindValueMap(config.props, "title", (title) => {
            if (isEmpty(title)) {
              this.element.classList.add(this.className_(void 0, "not"));
            } else {
              this.element.classList.remove(this.className_(void 0, "not"));
            }
          });
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(this.className_("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(this.className_("m"));
          this.buttonElement.appendChild(markElem);
          const containerElem = config.containerElement;
          containerElem.classList.add(this.className_("c"));
          this.element.appendChild(containerElem);
          this.containerElement = containerElem;
        }
      }
      class FolderController extends RackLikeController {
        constructor(doc, config) {
          var _a2;
          const foldable = Foldable.create((_a2 = config.expanded) !== null && _a2 !== void 0 ? _a2 : true);
          const rc = new RackController(doc, {
            blade: config.blade,
            root: config.root,
            viewProps: config.viewProps
          });
          super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
            containerElement: rc.view.element,
            foldable,
            props: config.props,
            viewName: config.root ? "rot" : void 0,
            viewProps: config.viewProps
          }) }));
          this.onTitleClick_ = this.onTitleClick_.bind(this);
          this.props = config.props;
          this.foldable = foldable;
          bindFoldable(this.foldable, this.view.containerElement);
          this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          });
          this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          });
          this.view.buttonElement.addEventListener("click", this.onTitleClick_);
        }
        get document() {
          return this.view.element.ownerDocument;
        }
        onTitleClick_() {
          this.foldable.set("expanded", !this.foldable.get("expanded"));
        }
      }
      const FolderBladePlugin = {
        id: "folder",
        type: "blade",
        accept(params) {
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            title: p3.required.string,
            view: p3.required.constant("folder"),
            expanded: p3.optional.boolean
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new FolderController(args.document, {
            blade: args.blade,
            expanded: args.params.expanded,
            props: ValueMap.fromObject({
              title: args.params.title
            }),
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof FolderController)) {
            return null;
          }
          return new FolderApi(args.controller, args.pool);
        }
      };
      class LabeledValueController extends ValueBladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      class SeparatorApi extends BladeApi {
      }
      const className$n = ClassName("spr");
      class SeparatorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$n());
          config.viewProps.bindClassModifiers(this.element);
          const hrElem = doc.createElement("hr");
          hrElem.classList.add(className$n("r"));
          this.element.appendChild(hrElem);
        }
      }
      class SeparatorController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
            viewProps: config.viewProps
          }) }));
        }
      }
      const SeparatorBladePlugin = {
        id: "separator",
        type: "blade",
        accept(params) {
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            view: p3.required.constant("separator")
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new SeparatorController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof SeparatorController)) {
            return null;
          }
          return new SeparatorApi(args.controller);
        }
      };
      const className$m = ClassName("");
      function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$m(void 0, modifier));
      }
      class ViewProps extends ValueMap {
        constructor(valueMap) {
          super(valueMap);
        }
        static create(opt_initialValue) {
          var _a2, _b;
          const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
          const coreObj = {
            disabled: (_a2 = initialValue.disabled) !== null && _a2 !== void 0 ? _a2 : false,
            disposed: false,
            hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false
          };
          const core = ValueMap.createCore(coreObj);
          return new ViewProps(core);
        }
        bindClassModifiers(elem) {
          bindValueMap(this, "disabled", valueToModifier(elem, "disabled"));
          bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
        }
        bindDisabled(target) {
          bindValueMap(this, "disabled", (disabled) => {
            target.disabled = disabled;
          });
        }
        bindTabIndex(elem) {
          bindValueMap(this, "disabled", (disabled) => {
            elem.tabIndex = disabled ? -1 : 0;
          });
        }
        handleDispose(callback) {
          this.value("disposed").emitter.on("change", (disposed) => {
            if (disposed) {
              callback();
            }
          });
        }
      }
      const className$l = ClassName("tbi");
      class TabItemView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$l());
          config.viewProps.bindClassModifiers(this.element);
          bindValueMap(config.props, "selected", (selected) => {
            if (selected) {
              this.element.classList.add(className$l(void 0, "sel"));
            } else {
              this.element.classList.remove(className$l(void 0, "sel"));
            }
          });
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$l("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$l("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
        }
      }
      class TabItemController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new TabItemView(doc, {
            props: config.props,
            viewProps: config.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class TabPageController {
        constructor(doc, config) {
          this.onItemClick_ = this.onItemClick_.bind(this);
          this.ic_ = new TabItemController(doc, {
            props: config.itemProps,
            viewProps: ViewProps.create()
          });
          this.ic_.emitter.on("click", this.onItemClick_);
          this.cc_ = new RackController(doc, {
            blade: createBlade(),
            viewProps: ViewProps.create()
          });
          this.props = config.props;
          bindValueMap(this.props, "selected", (selected) => {
            this.itemController.props.set("selected", selected);
            this.contentController.viewProps.set("hidden", !selected);
          });
        }
        get itemController() {
          return this.ic_;
        }
        get contentController() {
          return this.cc_;
        }
        onItemClick_() {
          this.props.set("selected", true);
        }
      }
      class TabPageApi {
        constructor(controller, contentRackApi) {
          this.controller_ = controller;
          this.rackApi_ = contentRackApi;
        }
        get title() {
          var _a2;
          return (_a2 = this.controller_.itemController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
        }
        set title(title) {
          this.controller_.itemController.props.set("title", title);
        }
        get selected() {
          return this.controller_.props.get("selected");
        }
        set selected(selected) {
          this.controller_.props.set("selected", selected);
        }
        get children() {
          return this.rackApi_.children;
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addInput(object, key, opt_params) {
          return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
          return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
      }
      class TabApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.onSelect_ = this.onSelect_.bind(this);
          this.emitter_ = new Emitter();
          this.pageApiMap_ = /* @__PURE__ */ new Map();
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
          this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_);
          this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
          this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
          this.controller_.pageSet.items.forEach((pc) => {
            this.setUpPageApi_(pc);
          });
        }
        get pages() {
          return this.controller_.pageSet.items.map((pc) => {
            const api = this.pageApiMap_.get(pc);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          });
        }
        addPage(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const pc = new TabPageController(doc, {
            itemProps: ValueMap.fromObject({
              selected: false,
              title: params.title
            }),
            props: ValueMap.fromObject({
              selected: false
            })
          });
          this.controller_.add(pc, params.index);
          const api = this.pageApiMap_.get(pc);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
        removePage(index2) {
          this.controller_.remove(index2);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpPageApi_(pc) {
          const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
          if (!rackApi) {
            throw TpError.shouldNeverHappen();
          }
          const api = new TabPageApi(pc, rackApi);
          this.pageApiMap_.set(pc, api);
        }
        onPageAdd_(ev) {
          this.setUpPageApi_(ev.item);
        }
        onPageRemove_(ev) {
          const api = this.pageApiMap_.get(ev.item);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          this.pageApiMap_.delete(ev.item);
        }
        onSelect_(ev) {
          this.emitter_.emit("select", {
            event: new TpTabSelectEvent(this, ev.rawValue)
          });
        }
      }
      const INDEX_NOT_SELECTED = -1;
      class Tab {
        constructor() {
          this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
          this.empty = createValue(true);
          this.selectedIndex = createValue(INDEX_NOT_SELECTED);
          this.items_ = [];
        }
        add(item, opt_index) {
          const index2 = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index2, 0, item);
          item.emitter.on("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        remove(item) {
          const index2 = this.items_.indexOf(item);
          if (index2 < 0) {
            return;
          }
          this.items_.splice(index2, 1);
          item.emitter.off("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        keepSelection_() {
          if (this.items_.length === 0) {
            this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
            this.empty.rawValue = true;
            return;
          }
          const firstSelIndex = this.items_.findIndex((s5) => s5.rawValue);
          if (firstSelIndex < 0) {
            this.items_.forEach((s5, i4) => {
              s5.rawValue = i4 === 0;
            });
            this.selectedIndex.rawValue = 0;
          } else {
            this.items_.forEach((s5, i4) => {
              s5.rawValue = i4 === firstSelIndex;
            });
            this.selectedIndex.rawValue = firstSelIndex;
          }
          this.empty.rawValue = false;
        }
        onItemSelectedChange_(ev) {
          if (ev.rawValue) {
            const index2 = this.items_.findIndex((s5) => s5 === ev.sender);
            this.items_.forEach((s5, i4) => {
              s5.rawValue = i4 === index2;
            });
            this.selectedIndex.rawValue = index2;
          } else {
            this.keepSelection_();
          }
        }
      }
      const className$k = ClassName("tab");
      class TabView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$k(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.empty, valueToClassName(this.element, className$k(void 0, "nop")));
          const itemsElem = doc.createElement("div");
          itemsElem.classList.add(className$k("i"));
          this.element.appendChild(itemsElem);
          this.itemsElement = itemsElem;
          const contentsElem = config.contentsElement;
          contentsElem.classList.add(className$k("c"));
          this.element.appendChild(contentsElem);
          this.contentsElement = contentsElem;
        }
      }
      class TabController extends RackLikeController {
        constructor(doc, config) {
          const cr = new RackController(doc, {
            blade: config.blade,
            viewProps: config.viewProps
          });
          const tab = new Tab();
          super({
            blade: config.blade,
            rackController: cr,
            view: new TabView(doc, {
              contentsElement: cr.view.element,
              empty: tab.empty,
              viewProps: config.viewProps
            })
          });
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.pageSet_ = new NestedOrderedSet(() => null);
          this.pageSet_.emitter.on("add", this.onPageAdd_);
          this.pageSet_.emitter.on("remove", this.onPageRemove_);
          this.tab = tab;
        }
        get pageSet() {
          return this.pageSet_;
        }
        add(pc, opt_index) {
          this.pageSet_.add(pc, opt_index);
        }
        remove(index2) {
          this.pageSet_.remove(this.pageSet_.items[index2]);
        }
        onPageAdd_(ev) {
          const pc = ev.item;
          insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
          this.rackController.rack.add(pc.contentController, ev.index);
          this.tab.add(pc.props.value("selected"));
        }
        onPageRemove_(ev) {
          const pc = ev.item;
          removeElement(pc.itemController.view.element);
          this.rackController.rack.remove(pc.contentController);
          this.tab.remove(pc.props.value("selected"));
        }
      }
      const TabBladePlugin = {
        id: "tab",
        type: "blade",
        accept(params) {
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            pages: p3.required.array(p3.required.object({ title: p3.required.string })),
            view: p3.required.constant("tab")
          });
          if (!result || result.pages.length === 0) {
            return null;
          }
          return { params: result };
        },
        controller(args) {
          const c5 = new TabController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
          args.params.pages.forEach((p3) => {
            const pc = new TabPageController(args.document, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: p3.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            c5.add(pc);
          });
          return c5;
        },
        api(args) {
          if (!(args.controller instanceof TabController)) {
            return null;
          }
          return new TabApi(args.controller, args.pool);
        }
      };
      function createBladeController(plugin, args) {
        const ac = plugin.accept(args.params);
        if (!ac) {
          return null;
        }
        const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
        const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
        return plugin.controller({
          blade: createBlade(),
          document: args.document,
          params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
      }
      class ManualTicker {
        constructor() {
          this.disabled = false;
          this.emitter = new Emitter();
        }
        dispose() {
        }
        tick() {
          if (this.disabled) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class IntervalTicker {
        constructor(doc, interval) {
          this.disabled_ = false;
          this.timerId_ = null;
          this.onTick_ = this.onTick_.bind(this);
          this.doc_ = doc;
          this.emitter = new Emitter();
          this.interval_ = interval;
          this.setTimer_();
        }
        get disabled() {
          return this.disabled_;
        }
        set disabled(inactive) {
          this.disabled_ = inactive;
          if (this.disabled_) {
            this.clearTimer_();
          } else {
            this.setTimer_();
          }
        }
        dispose() {
          this.clearTimer_();
        }
        clearTimer_() {
          if (this.timerId_ === null) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            win.clearInterval(this.timerId_);
          }
          this.timerId_ = null;
        }
        setTimer_() {
          this.clearTimer_();
          if (this.interval_ <= 0) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            this.timerId_ = win.setInterval(this.onTick_, this.interval_);
          }
        }
        onTick_() {
          if (this.disabled_) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class CompositeConstraint {
        constructor(constraints) {
          this.constraints = constraints;
        }
        constrain(value) {
          return this.constraints.reduce((result, c5) => {
            return c5.constrain(result);
          }, value);
        }
      }
      function findConstraint(c5, constraintClass) {
        if (c5 instanceof constraintClass) {
          return c5;
        }
        if (c5 instanceof CompositeConstraint) {
          const result = c5.constraints.reduce((tmpResult, sc) => {
            if (tmpResult) {
              return tmpResult;
            }
            return sc instanceof constraintClass ? sc : null;
          }, null);
          if (result) {
            return result;
          }
        }
        return null;
      }
      class ListConstraint {
        constructor(options) {
          this.options = options;
        }
        constrain(value) {
          const opts = this.options;
          if (opts.length === 0) {
            return value;
          }
          const matched = opts.filter((item) => {
            return item.value === value;
          }).length > 0;
          return matched ? value : opts[0].value;
        }
      }
      class RangeConstraint {
        constructor(config) {
          this.maxValue = config.max;
          this.minValue = config.min;
        }
        constrain(value) {
          let result = value;
          if (!isEmpty(this.minValue)) {
            result = Math.max(result, this.minValue);
          }
          if (!isEmpty(this.maxValue)) {
            result = Math.min(result, this.maxValue);
          }
          return result;
        }
      }
      class StepConstraint {
        constructor(step, origin = 0) {
          this.step = step;
          this.origin = origin;
        }
        constrain(value) {
          const o4 = this.origin % this.step;
          const r5 = Math.round((value - o4) / this.step);
          return o4 + r5 * this.step;
        }
      }
      const className$j = ClassName("lst");
      class ListView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.props_ = config.props;
          this.element = doc.createElement("div");
          this.element.classList.add(className$j());
          config.viewProps.bindClassModifiers(this.element);
          const selectElem = doc.createElement("select");
          selectElem.classList.add(className$j("s"));
          bindValueMap(this.props_, "options", (opts) => {
            removeChildElements(selectElem);
            opts.forEach((item, index2) => {
              const optionElem = doc.createElement("option");
              optionElem.dataset.index = String(index2);
              optionElem.textContent = item.text;
              optionElem.value = String(item.value);
              selectElem.appendChild(optionElem);
            });
          });
          config.viewProps.bindDisabled(selectElem);
          this.element.appendChild(selectElem);
          this.selectElement = selectElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(className$j("m"));
          markElem.appendChild(createSvgIconElement(doc, "dropdown"));
          this.element.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value_ = config.value;
          this.update_();
        }
        update_() {
          this.selectElement.value = String(this.value_.rawValue);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ListController {
        constructor(doc, config) {
          this.onSelectChange_ = this.onSelectChange_.bind(this);
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ListView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.selectElement.addEventListener("change", this.onSelectChange_);
        }
        onSelectChange_(e5) {
          const selectElem = forceCast(e5.currentTarget);
          const optElem = selectElem.selectedOptions.item(0);
          if (!optElem) {
            return;
          }
          const itemIndex = Number(optElem.dataset.index);
          this.value.rawValue = this.props.get("options")[itemIndex].value;
        }
      }
      const className$i = ClassName("pop");
      class PopupView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$i());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.shows, valueToClassName(this.element, className$i(void 0, "v")));
        }
      }
      class PopupController {
        constructor(doc, config) {
          this.shows = createValue(false);
          this.viewProps = config.viewProps;
          this.view = new PopupView(doc, {
            shows: this.shows,
            viewProps: this.viewProps
          });
        }
      }
      const className$h = ClassName("txt");
      class TextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$h());
          config.viewProps.bindClassModifiers(this.element);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$h("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value_.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class TextController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.parser_ = config.parser;
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new TextView(doc, {
            props: config.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e5) {
          const inputElem = forceCast(e5.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = parsedValue;
          }
          this.view.refresh();
        }
      }
      function boolToString(value) {
        return String(value);
      }
      function boolFromUnknown(value) {
        if (value === "false") {
          return false;
        }
        return !!value;
      }
      function BooleanFormatter(value) {
        return boolToString(value);
      }
      class NumberLiteralNode {
        constructor(text) {
          this.text = text;
        }
        evaluate() {
          return Number(this.text);
        }
        toString() {
          return this.text;
        }
      }
      const BINARY_OPERATION_MAP = {
        "**": (v1, v22) => Math.pow(v1, v22),
        "*": (v1, v22) => v1 * v22,
        "/": (v1, v22) => v1 / v22,
        "%": (v1, v22) => v1 % v22,
        "+": (v1, v22) => v1 + v22,
        "-": (v1, v22) => v1 - v22,
        "<<": (v1, v22) => v1 << v22,
        ">>": (v1, v22) => v1 >> v22,
        ">>>": (v1, v22) => v1 >>> v22,
        "&": (v1, v22) => v1 & v22,
        "^": (v1, v22) => v1 ^ v22,
        "|": (v1, v22) => v1 | v22
      };
      class BinaryOperationNode {
        constructor(operator, left, right) {
          this.left = left;
          this.operator = operator;
          this.right = right;
        }
        evaluate() {
          const op = BINARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected binary operator: '${this.operator}`);
          }
          return op(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
          return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")"
          ].join(" ");
        }
      }
      const UNARY_OPERATION_MAP = {
        "+": (v4) => v4,
        "-": (v4) => -v4,
        "~": (v4) => ~v4
      };
      class UnaryOperationNode {
        constructor(operator, expr) {
          this.operator = operator;
          this.expression = expr;
        }
        evaluate() {
          const op = UNARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected unary operator: '${this.operator}`);
          }
          return op(this.expression.evaluate());
        }
        toString() {
          return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
        }
      }
      function combineReader(parsers) {
        return (text, cursor) => {
          for (let i4 = 0; i4 < parsers.length; i4++) {
            const result = parsers[i4](text, cursor);
            if (result !== "") {
              return result;
            }
          }
          return "";
        };
      }
      function readWhitespace(text, cursor) {
        var _a2;
        const m4 = text.substr(cursor).match(/^\s+/);
        return (_a2 = m4 && m4[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readNonZeroDigit(text, cursor) {
        const ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : "";
      }
      function readDecimalDigits(text, cursor) {
        var _a2;
        const m4 = text.substr(cursor).match(/^[0-9]+/);
        return (_a2 = m4 && m4[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readSignedInteger(text, cursor) {
        const ds = readDecimalDigits(text, cursor);
        if (ds !== "") {
          return ds;
        }
        const sign = text.substr(cursor, 1);
        cursor += 1;
        if (sign !== "-" && sign !== "+") {
          return "";
        }
        const sds = readDecimalDigits(text, cursor);
        if (sds === "") {
          return "";
        }
        return sign + sds;
      }
      function readExponentPart(text, cursor) {
        const e5 = text.substr(cursor, 1);
        cursor += 1;
        if (e5.toLowerCase() !== "e") {
          return "";
        }
        const si = readSignedInteger(text, cursor);
        if (si === "") {
          return "";
        }
        return e5 + si;
      }
      function readDecimalIntegerLiteral(text, cursor) {
        const ch = text.substr(cursor, 1);
        if (ch === "0") {
          return ch;
        }
        const nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;
        if (nzd === "") {
          return "";
        }
        return nzd + readDecimalDigits(text, cursor);
      }
      function readDecimalLiteral1(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral2(text, cursor) {
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        if (dds === "") {
          return "";
        }
        return dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral3(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        return dil + readExponentPart(text, cursor);
      }
      const readDecimalLiteral = combineReader([
        readDecimalLiteral1,
        readDecimalLiteral2,
        readDecimalLiteral3
      ]);
      function parseBinaryDigits(text, cursor) {
        var _a2;
        const m4 = text.substr(cursor).match(/^[01]+/);
        return (_a2 = m4 && m4[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readBinaryIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0b") {
          return "";
        }
        const bds = parseBinaryDigits(text, cursor);
        if (bds === "") {
          return "";
        }
        return prefix + bds;
      }
      function readOctalDigits(text, cursor) {
        var _a2;
        const m4 = text.substr(cursor).match(/^[0-7]+/);
        return (_a2 = m4 && m4[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readOctalIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0o") {
          return "";
        }
        const ods = readOctalDigits(text, cursor);
        if (ods === "") {
          return "";
        }
        return prefix + ods;
      }
      function readHexDigits(text, cursor) {
        var _a2;
        const m4 = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a2 = m4 && m4[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readHexIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0x") {
          return "";
        }
        const hds = readHexDigits(text, cursor);
        if (hds === "") {
          return "";
        }
        return prefix + hds;
      }
      const readNonDecimalIntegerLiteral = combineReader([
        readBinaryIntegerLiteral,
        readOctalIntegerLiteral,
        readHexIntegerLiteral
      ]);
      const readNumericLiteral = combineReader([
        readNonDecimalIntegerLiteral,
        readDecimalLiteral
      ]);
      function parseLiteral(text, cursor) {
        const num = readNumericLiteral(text, cursor);
        cursor += num.length;
        if (num === "") {
          return null;
        }
        return {
          evaluable: new NumberLiteralNode(num),
          cursor
        };
      }
      function parseParenthesizedExpression(text, cursor) {
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "(") {
          return null;
        }
        const expr = parseExpression(text, cursor);
        if (!expr) {
          return null;
        }
        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        const cl = text.substr(cursor, 1);
        cursor += cl.length;
        if (cl !== ")") {
          return null;
        }
        return {
          evaluable: expr.evaluable,
          cursor
        };
      }
      function parsePrimaryExpression(text, cursor) {
        var _a2;
        return (_a2 = parseLiteral(text, cursor)) !== null && _a2 !== void 0 ? _a2 : parseParenthesizedExpression(text, cursor);
      }
      function parseUnaryExpression(text, cursor) {
        const expr = parsePrimaryExpression(text, cursor);
        if (expr) {
          return expr;
        }
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "+" && op !== "-" && op !== "~") {
          return null;
        }
        const num = parseUnaryExpression(text, cursor);
        if (!num) {
          return null;
        }
        cursor = num.cursor;
        return {
          cursor,
          evaluable: new UnaryOperationNode(op, num.evaluable)
        };
      }
      function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
        if (!op) {
          return null;
        }
        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
          cursor,
          operator: op
        };
      }
      function createBinaryOperationExpressionParser(exprParser, ops) {
        return (text, cursor) => {
          const firstExpr = exprParser(text, cursor);
          if (!firstExpr) {
            return null;
          }
          cursor = firstExpr.cursor;
          let expr = firstExpr.evaluable;
          for (; ; ) {
            const op = readBinaryOperator(ops, text, cursor);
            if (!op) {
              break;
            }
            cursor = op.cursor;
            const nextExpr = exprParser(text, cursor);
            if (!nextExpr) {
              return null;
            }
            cursor = nextExpr.cursor;
            expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
          }
          return expr ? {
            cursor,
            evaluable: expr
          } : null;
        };
      }
      const parseBinaryOperationExpression = [
        ["**"],
        ["*", "/", "%"],
        ["+", "-"],
        ["<<", ">>>", ">>"],
        ["&"],
        ["^"],
        ["|"]
      ].reduce((parser, ops) => {
        return createBinaryOperationExpressionParser(parser, ops);
      }, parseUnaryExpression);
      function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
      }
      function parseEcmaNumberExpression(text) {
        const expr = parseExpression(text, 0);
        if (!expr) {
          return null;
        }
        const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
        if (cursor !== text.length) {
          return null;
        }
        return expr.evaluable;
      }
      function parseNumber(text) {
        var _a2;
        const r5 = parseEcmaNumberExpression(text);
        return (_a2 = r5 === null || r5 === void 0 ? void 0 : r5.evaluate()) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function numberFromUnknown(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          const pv = parseNumber(value);
          if (!isEmpty(pv)) {
            return pv;
          }
        }
        return 0;
      }
      function numberToString(value) {
        return String(value);
      }
      function createNumberFormatter(digits) {
        return (value) => {
          return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
      }
      const innerFormatter = createNumberFormatter(0);
      function formatPercentage(value) {
        return innerFormatter(value) + "%";
      }
      function stringFromUnknown(value) {
        return String(value);
      }
      function formatString(value) {
        return value;
      }
      function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
          buffer.push(void 0);
        }
      }
      function initializeBuffer(bufferSize) {
        const buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
      }
      function createTrimmedBuffer(buffer) {
        const index2 = buffer.indexOf(void 0);
        return forceCast(index2 < 0 ? buffer : buffer.slice(0, index2));
      }
      function createPushedBuffer(buffer, newValue) {
        const newBuffer = [...createTrimmedBuffer(buffer), newValue];
        if (newBuffer.length > buffer.length) {
          newBuffer.splice(0, newBuffer.length - buffer.length);
        } else {
          fillBuffer(newBuffer, buffer.length);
        }
        return newBuffer;
      }
      function connectValues({ primary, secondary, forward, backward }) {
        let changing = false;
        function preventFeedback(callback) {
          if (changing) {
            return;
          }
          changing = true;
          callback();
          changing = false;
        }
        primary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        secondary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            primary.setRawValue(backward(primary, secondary), ev.options);
          });
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        preventFeedback(() => {
          secondary.setRawValue(forward(primary, secondary), {
            forceEmit: false,
            last: true
          });
        });
      }
      function getStepForKey(baseStep, keys) {
        const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
        if (keys.upKey) {
          return +step;
        } else if (keys.downKey) {
          return -step;
        }
        return 0;
      }
      function getVerticalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowDown",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowUp"
        };
      }
      function getHorizontalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowLeft",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowRight"
        };
      }
      function isVerticalArrowKey(key) {
        return key === "ArrowUp" || key === "ArrowDown";
      }
      function isArrowKey(key) {
        return isVerticalArrowKey(key) || key === "ArrowLeft" || key === "ArrowRight";
      }
      function computeOffset$1(ev, elem) {
        var _a2, _b;
        const win = elem.ownerDocument.defaultView;
        const rect = elem.getBoundingClientRect();
        return {
          x: ev.pageX - (((_a2 = win && win.scrollX) !== null && _a2 !== void 0 ? _a2 : 0) + rect.left),
          y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) + rect.top)
        };
      }
      class PointerHandler {
        constructor(element) {
          this.lastTouch_ = null;
          this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
          this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
          this.onMouseDown_ = this.onMouseDown_.bind(this);
          this.onTouchEnd_ = this.onTouchEnd_.bind(this);
          this.onTouchMove_ = this.onTouchMove_.bind(this);
          this.onTouchStart_ = this.onTouchStart_.bind(this);
          this.elem_ = element;
          this.emitter = new Emitter();
          element.addEventListener("touchstart", this.onTouchStart_, {
            passive: false
          });
          element.addEventListener("touchmove", this.onTouchMove_, {
            passive: true
          });
          element.addEventListener("touchend", this.onTouchEnd_);
          element.addEventListener("mousedown", this.onMouseDown_);
        }
        computePosition_(offset) {
          const rect = this.elem_.getBoundingClientRect();
          return {
            bounds: {
              width: rect.width,
              height: rect.height
            },
            point: offset ? {
              x: offset.x,
              y: offset.y
            } : null
          };
        }
        onMouseDown_(ev) {
          var _a2;
          ev.preventDefault();
          (_a2 = ev.currentTarget) === null || _a2 === void 0 ? void 0 : _a2.focus();
          const doc = this.elem_.ownerDocument;
          doc.addEventListener("mousemove", this.onDocumentMouseMove_);
          doc.addEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseMove_(ev) {
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseUp_(ev) {
          const doc = this.elem_.ownerDocument;
          doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
          doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onTouchStart_(ev) {
          ev.preventDefault();
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchMove_(ev) {
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchEnd_(ev) {
          var _a2;
          const touch = (_a2 = ev.targetTouches.item(0)) !== null && _a2 !== void 0 ? _a2 : this.lastTouch_;
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
      }
      function mapRange(value, start1, end1, start22, end2) {
        const p3 = (value - start1) / (end1 - start1);
        return start22 + p3 * (end2 - start22);
      }
      function getDecimalDigits(value) {
        const text = String(value.toFixed(10));
        const frac = text.split(".")[1];
        return frac.replace(/0+$/, "").length;
      }
      function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      function loopRange(value, max) {
        return (value % max + max) % max;
      }
      const className$g = ClassName("txt");
      class NumberTextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$g(), className$g(void 0, "num"));
          if (config.arrayPosition) {
            this.element.classList.add(className$g(void 0, config.arrayPosition));
          }
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$g("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          this.onDraggingChange_ = this.onDraggingChange_.bind(this);
          this.dragging_ = config.dragging;
          this.dragging_.emitter.on("change", this.onDraggingChange_);
          this.element.classList.add(className$g());
          this.inputElement.classList.add(className$g("i"));
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$g("k"));
          this.element.appendChild(knobElem);
          this.knobElement = knobElem;
          const guideElem = doc.createElementNS(SVG_NS, "svg");
          guideElem.classList.add(className$g("g"));
          this.knobElement.appendChild(guideElem);
          const bodyElem = doc.createElementNS(SVG_NS, "path");
          bodyElem.classList.add(className$g("gb"));
          guideElem.appendChild(bodyElem);
          this.guideBodyElem_ = bodyElem;
          const headElem = doc.createElementNS(SVG_NS, "path");
          headElem.classList.add(className$g("gh"));
          guideElem.appendChild(headElem);
          this.guideHeadElem_ = headElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(ClassName("tt")());
          this.knobElement.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.refresh();
        }
        onDraggingChange_(ev) {
          if (ev.rawValue === null) {
            this.element.classList.remove(className$g(void 0, "drg"));
            return;
          }
          this.element.classList.add(className$g(void 0, "drg"));
          const x2 = ev.rawValue / this.props_.get("draggingScale");
          const aox = x2 + (x2 > 0 ? -1 : x2 < 0 ? 1 : 0);
          const adx = constrainRange(-aox, -4, 4);
          this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x2},-1 L${x2},9`].join(" "));
          this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x2},4`);
          const formatter = this.props_.get("formatter");
          this.tooltipElem_.textContent = formatter(this.value.rawValue);
          this.tooltipElem_.style.left = `${x2}px`;
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class NumberTextController {
        constructor(doc, config) {
          var _a2;
          this.originRawValue_ = 0;
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
          this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.parser_ = config.parser;
          this.props = config.props;
          this.sliderProps_ = (_a2 = config.sliderProps) !== null && _a2 !== void 0 ? _a2 : null;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.dragging_ = createValue(null);
          this.view = new NumberTextView(doc, {
            arrayPosition: config.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
          this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
          this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
          const ph = new PointerHandler(this.view.knobElement);
          ph.emitter.on("down", this.onPointerDown_);
          ph.emitter.on("move", this.onPointerMove_);
          ph.emitter.on("up", this.onPointerUp_);
        }
        constrainValue_(value) {
          var _a2, _b;
          const min = (_a2 = this.sliderProps_) === null || _a2 === void 0 ? void 0 : _a2.get("minValue");
          const max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get("maxValue");
          let v4 = value;
          if (min !== void 0) {
            v4 = Math.max(v4, min);
          }
          if (max !== void 0) {
            v4 = Math.min(v4, max);
          }
          return v4;
        }
        onInputChange_(e5) {
          const inputElem = forceCast(e5.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = this.constrainValue_(parsedValue);
          }
          this.view.refresh();
        }
        onInputKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
            forceEmit: false,
            last: false
          });
        }
        onInputKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
        onPointerDown_() {
          this.originRawValue_ = this.value.rawValue;
          this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(data) {
          if (!data.point) {
            return null;
          }
          const dx = data.point.x - data.bounds.width / 2;
          return this.constrainValue_(this.originRawValue_ + dx * this.props.get("draggingScale"));
        }
        onPointerMove_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: false,
            last: false
          });
          this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
        }
        onPointerUp_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: true,
            last: true
          });
          this.dragging_.rawValue = null;
        }
      }
      const className$f = ClassName("sld");
      class SliderView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$f());
          config.viewProps.bindClassModifiers(this.element);
          const trackElem = doc.createElement("div");
          trackElem.classList.add(className$f("t"));
          config.viewProps.bindTabIndex(trackElem);
          this.element.appendChild(trackElem);
          this.trackElement = trackElem;
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$f("k"));
          this.trackElement.appendChild(knobElem);
          this.knobElement = knobElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const p3 = constrainRange(mapRange(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
          this.knobElement.style.width = `${p3}%`;
        }
        onChange_() {
          this.update_();
        }
      }
      class SliderController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.props = config.props;
          this.view = new SliderView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.trackElement);
          this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
          this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d4, opts) {
          if (!d4.point) {
            return;
          }
          this.value.setRawValue(mapRange(constrainRange(d4.point.x, 0, d4.bounds.width), 0, d4.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
        }
        onPointerDownOrMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue + step, {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$e = ClassName("sldtxt");
      class SliderTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$e());
          const sliderElem = doc.createElement("div");
          sliderElem.classList.add(className$e("s"));
          this.sliderView_ = config.sliderView;
          sliderElem.appendChild(this.sliderView_.element);
          this.element.appendChild(sliderElem);
          const textElem = doc.createElement("div");
          textElem.classList.add(className$e("t"));
          this.textView_ = config.textView;
          textElem.appendChild(this.textView_.element);
          this.element.appendChild(textElem);
        }
      }
      class SliderTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.sliderC_ = new SliderController(doc, {
            baseStep: config.baseStep,
            props: config.sliderProps,
            value: config.value,
            viewProps: this.viewProps
          });
          this.textC_ = new NumberTextController(doc, {
            baseStep: config.baseStep,
            parser: config.parser,
            props: config.textProps,
            sliderProps: config.sliderProps,
            value: config.value,
            viewProps: config.viewProps
          });
          this.view = new SliderTextView(doc, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }
        get sliderController() {
          return this.sliderC_;
        }
        get textController() {
          return this.textC_;
        }
      }
      function writePrimitive(target, value) {
        target.write(value);
      }
      function parseListOptions(value) {
        const p3 = ParamsParsers;
        if (Array.isArray(value)) {
          return p3.required.array(p3.required.object({
            text: p3.required.string,
            value: p3.required.raw
          }))(value).value;
        }
        if (typeof value === "object") {
          return p3.required.raw(value).value;
        }
        return void 0;
      }
      function parsePickerLayout(value) {
        if (value === "inline" || value === "popup") {
          return value;
        }
        return void 0;
      }
      function parsePointDimensionParams(value) {
        const p3 = ParamsParsers;
        return p3.required.object({
          max: p3.optional.number,
          min: p3.optional.number,
          step: p3.optional.number
        })(value).value;
      }
      function normalizeListOptions(options) {
        if (Array.isArray(options)) {
          return options;
        }
        const items = [];
        Object.keys(options).forEach((text) => {
          items.push({ text, value: options[text] });
        });
        return items;
      }
      function createListConstraint(options) {
        return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
      }
      function findListItems(constraint) {
        const c5 = constraint ? findConstraint(constraint, ListConstraint) : null;
        if (!c5) {
          return null;
        }
        return c5.options;
      }
      function findStep(constraint) {
        const c5 = constraint ? findConstraint(constraint, StepConstraint) : null;
        if (!c5) {
          return null;
        }
        return c5.step;
      }
      function getSuitableDecimalDigits(constraint, rawValue) {
        const sc = constraint && findConstraint(constraint, StepConstraint);
        if (sc) {
          return getDecimalDigits(sc.step);
        }
        return Math.max(getDecimalDigits(rawValue), 2);
      }
      function getBaseStep(constraint) {
        const step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
      }
      function getSuitableDraggingScale(constraint, rawValue) {
        var _a2;
        const sc = constraint && findConstraint(constraint, StepConstraint);
        const base = Math.abs((_a2 = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a2 !== void 0 ? _a2 : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
      }
      const className$d = ClassName("ckb");
      class CheckboxView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$d());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("label");
          labelElem.classList.add(className$d("l"));
          this.element.appendChild(labelElem);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$d("i"));
          inputElem.type = "checkbox";
          labelElem.appendChild(inputElem);
          this.inputElement = inputElem;
          config.viewProps.bindDisabled(this.inputElement);
          const wrapperElem = doc.createElement("div");
          wrapperElem.classList.add(className$d("w"));
          labelElem.appendChild(wrapperElem);
          const markElem = createSvgIconElement(doc, "check");
          wrapperElem.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class CheckboxController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new CheckboxView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e5) {
          const inputElem = forceCast(e5.currentTarget);
          this.value.rawValue = inputElem.checked;
        }
      }
      function createConstraint$6(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      const BooleanInputPlugin = {
        id: "input-bool",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            options: p3.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown,
          constraint: (args) => createConstraint$6(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          var _a2;
          const doc = args.document;
          const value = args.value;
          const c5 = args.constraint;
          if (c5 && findConstraint(c5, ListConstraint)) {
            return new ListController(doc, {
              props: ValueMap.fromObject({
                options: (_a2 = findListItems(c5)) !== null && _a2 !== void 0 ? _a2 : []
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new CheckboxController(doc, {
            value,
            viewProps: args.viewProps
          });
        }
      };
      const className$c = ClassName("col");
      class ColorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$c());
          config.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
          bindValueMap(config.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$c("h"));
          this.element.appendChild(headElem);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$c("s"));
          headElem.appendChild(swatchElem);
          this.swatchElement = swatchElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$c("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$c("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      function rgbToHslInt(r5, g3, b4) {
        const rp = constrainRange(r5 / 255, 0, 1);
        const gp = constrainRange(g3 / 255, 0, 1);
        const bp = constrainRange(b4 / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const c5 = cmax - cmin;
        let h4 = 0;
        let s5 = 0;
        const l5 = (cmin + cmax) / 2;
        if (c5 !== 0) {
          s5 = c5 / (1 - Math.abs(cmax + cmin - 1));
          if (rp === cmax) {
            h4 = (gp - bp) / c5;
          } else if (gp === cmax) {
            h4 = 2 + (bp - rp) / c5;
          } else {
            h4 = 4 + (rp - gp) / c5;
          }
          h4 = h4 / 6 + (h4 < 0 ? 1 : 0);
        }
        return [h4 * 360, s5 * 100, l5 * 100];
      }
      function hslToRgbInt(h4, s5, l5) {
        const hp = (h4 % 360 + 360) % 360;
        const sp = constrainRange(s5 / 100, 0, 1);
        const lp = constrainRange(l5 / 100, 0, 1);
        const c5 = (1 - Math.abs(2 * lp - 1)) * sp;
        const x2 = c5 * (1 - Math.abs(hp / 60 % 2 - 1));
        const m4 = lp - c5 / 2;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c5, x2, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x2, c5, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c5, x2];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x2, c5];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x2, 0, c5];
        } else {
          [rp, gp, bp] = [c5, 0, x2];
        }
        return [(rp + m4) * 255, (gp + m4) * 255, (bp + m4) * 255];
      }
      function rgbToHsvInt(r5, g3, b4) {
        const rp = constrainRange(r5 / 255, 0, 1);
        const gp = constrainRange(g3 / 255, 0, 1);
        const bp = constrainRange(b4 / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const d4 = cmax - cmin;
        let h4;
        if (d4 === 0) {
          h4 = 0;
        } else if (cmax === rp) {
          h4 = 60 * (((gp - bp) / d4 % 6 + 6) % 6);
        } else if (cmax === gp) {
          h4 = 60 * ((bp - rp) / d4 + 2);
        } else {
          h4 = 60 * ((rp - gp) / d4 + 4);
        }
        const s5 = cmax === 0 ? 0 : d4 / cmax;
        const v4 = cmax;
        return [h4, s5 * 100, v4 * 100];
      }
      function hsvToRgbInt(h4, s5, v4) {
        const hp = loopRange(h4, 360);
        const sp = constrainRange(s5 / 100, 0, 1);
        const vp = constrainRange(v4 / 100, 0, 1);
        const c5 = vp * sp;
        const x2 = c5 * (1 - Math.abs(hp / 60 % 2 - 1));
        const m4 = vp - c5;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c5, x2, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x2, c5, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c5, x2];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x2, c5];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x2, 0, c5];
        } else {
          [rp, gp, bp] = [c5, 0, x2];
        }
        return [(rp + m4) * 255, (gp + m4) * 255, (bp + m4) * 255];
      }
      function hslToHsvInt(h4, s5, l5) {
        const sd = l5 + s5 * (100 - Math.abs(2 * l5 - 100)) / (2 * 100);
        return [
          h4,
          sd !== 0 ? s5 * (100 - Math.abs(2 * l5 - 100)) / sd : 0,
          l5 + s5 * (100 - Math.abs(2 * l5 - 100)) / (2 * 100)
        ];
      }
      function hsvToHslInt(h4, s5, v4) {
        const sd = 100 - Math.abs(v4 * (200 - s5) / 100 - 100);
        return [h4, sd !== 0 ? s5 * v4 / sd : 0, v4 * (200 - s5) / (2 * 100)];
      }
      function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
      }
      function appendAlphaComponent(comps, alpha2) {
        return [comps[0], comps[1], comps[2], alpha2];
      }
      const MODE_CONVERTER_MAP = {
        hsl: {
          hsl: (h4, s5, l5) => [h4, s5, l5],
          hsv: hslToHsvInt,
          rgb: hslToRgbInt
        },
        hsv: {
          hsl: hsvToHslInt,
          hsv: (h4, s5, v4) => [h4, s5, v4],
          rgb: hsvToRgbInt
        },
        rgb: {
          hsl: rgbToHslInt,
          hsv: rgbToHsvInt,
          rgb: (r5, g3, b4) => [r5, g3, b4]
        }
      };
      function getColorMaxComponents(mode, type2) {
        return [
          type2 === "float" ? 1 : mode === "rgb" ? 255 : 360,
          type2 === "float" ? 1 : mode === "rgb" ? 255 : 100,
          type2 === "float" ? 1 : mode === "rgb" ? 255 : 100
        ];
      }
      function constrainColorComponents(components, mode, type2) {
        var _a2;
        const ms = getColorMaxComponents(mode, type2);
        return [
          mode === "rgb" ? constrainRange(components[0], 0, ms[0]) : loopRange(components[0], ms[0]),
          constrainRange(components[1], 0, ms[1]),
          constrainRange(components[2], 0, ms[2]),
          constrainRange((_a2 = components[3]) !== null && _a2 !== void 0 ? _a2 : 1, 0, 1)
        ];
      }
      function convertColorType(comps, mode, from, to) {
        const fms = getColorMaxComponents(mode, from);
        const tms = getColorMaxComponents(mode, to);
        return comps.map((c5, index2) => c5 / fms[index2] * tms[index2]);
      }
      function convertColor(components, from, to) {
        const intComps = convertColorType(components, from.mode, from.type, "int");
        const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
        return convertColorType(result, to.mode, "int", to.type);
      }
      function isRgbColorComponent(obj, key) {
        if (typeof obj !== "object" || isEmpty(obj)) {
          return false;
        }
        return key in obj && typeof obj[key] === "number";
      }
      class Color2 {
        constructor(comps, mode, type2 = "int") {
          this.mode = mode;
          this.type = type2;
          this.comps_ = constrainColorComponents(comps, mode, type2);
        }
        static black(type2 = "int") {
          return new Color2([0, 0, 0], "rgb", type2);
        }
        static fromObject(obj, type2 = "int") {
          const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
          return new Color2(comps, "rgb", type2);
        }
        static toRgbaObject(color2, type2 = "int") {
          return color2.toRgbaObject(type2);
        }
        static isRgbColorObject(obj) {
          return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
        }
        static isRgbaColorObject(obj) {
          return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
        }
        static isColorObject(obj) {
          return this.isRgbColorObject(obj);
        }
        static equals(v1, v22) {
          if (v1.mode !== v22.mode) {
            return false;
          }
          const comps1 = v1.comps_;
          const comps2 = v22.comps_;
          for (let i4 = 0; i4 < comps1.length; i4++) {
            if (comps1[i4] !== comps2[i4]) {
              return false;
            }
          }
          return true;
        }
        getComponents(opt_mode, type2 = "int") {
          return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type: type2 }), this.comps_[3]);
        }
        toRgbaObject(type2 = "int") {
          const rgbComps = this.getComponents("rgb", type2);
          return {
            r: rgbComps[0],
            g: rgbComps[1],
            b: rgbComps[2],
            a: rgbComps[3]
          };
        }
      }
      const className$b = ClassName("colp");
      class ColorPickerView {
        constructor(doc, config) {
          this.alphaViews_ = null;
          this.element = doc.createElement("div");
          this.element.classList.add(className$b());
          const hsvElem = doc.createElement("div");
          hsvElem.classList.add(className$b("hsv"));
          const svElem = doc.createElement("div");
          svElem.classList.add(className$b("sv"));
          this.svPaletteView_ = config.svPaletteView;
          svElem.appendChild(this.svPaletteView_.element);
          hsvElem.appendChild(svElem);
          const hElem = doc.createElement("div");
          hElem.classList.add(className$b("h"));
          this.hPaletteView_ = config.hPaletteView;
          hElem.appendChild(this.hPaletteView_.element);
          hsvElem.appendChild(hElem);
          this.element.appendChild(hsvElem);
          const rgbElem = doc.createElement("div");
          rgbElem.classList.add(className$b("rgb"));
          this.textView_ = config.textView;
          rgbElem.appendChild(this.textView_.element);
          this.element.appendChild(rgbElem);
          if (config.alphaViews) {
            this.alphaViews_ = {
              palette: config.alphaViews.palette,
              text: config.alphaViews.text
            };
            const aElem = doc.createElement("div");
            aElem.classList.add(className$b("a"));
            const apElem = doc.createElement("div");
            apElem.classList.add(className$b("ap"));
            apElem.appendChild(this.alphaViews_.palette.element);
            aElem.appendChild(apElem);
            const atElem = doc.createElement("div");
            atElem.classList.add(className$b("at"));
            atElem.appendChild(this.alphaViews_.text.element);
            aElem.appendChild(atElem);
            this.element.appendChild(aElem);
          }
        }
        get allFocusableElements() {
          const elems = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textView_.modeSelectElement,
            ...this.textView_.textViews.map((v4) => v4.inputElement)
          ];
          if (this.alphaViews_) {
            elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
          }
          return elems;
        }
      }
      function parseColorType(value) {
        return value === "int" ? "int" : value === "float" ? "float" : void 0;
      }
      function parseColorInputParams(params) {
        const p3 = ParamsParsers;
        return parseParams(params, {
          alpha: p3.optional.boolean,
          color: p3.optional.object({
            alpha: p3.optional.boolean,
            type: p3.optional.custom(parseColorType)
          }),
          expanded: p3.optional.boolean,
          picker: p3.optional.custom(parsePickerLayout)
        });
      }
      function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
      }
      function extractColorType(params) {
        var _a2;
        return (_a2 = params.color) === null || _a2 === void 0 ? void 0 : _a2.type;
      }
      function equalsStringColorFormat(f1, f22) {
        return f1.alpha === f22.alpha && f1.mode === f22.mode && f1.notation === f22.notation && f1.type === f22.type;
      }
      function parseCssNumberOrPercentage(text, maxValue) {
        const m4 = text.match(/^(.+)%$/);
        if (!m4) {
          return Math.min(parseFloat(text), maxValue);
        }
        return Math.min(parseFloat(m4[1]) * 0.01 * maxValue, maxValue);
      }
      const ANGLE_TO_DEG_MAP = {
        deg: (angle2) => angle2,
        grad: (angle2) => angle2 * 360 / 400,
        rad: (angle2) => angle2 * 360 / (2 * Math.PI),
        turn: (angle2) => angle2 * 360
      };
      function parseCssNumberOrAngle(text) {
        const m4 = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!m4) {
          return parseFloat(text);
        }
        const angle2 = parseFloat(m4[1]);
        const unit = m4[2];
        return ANGLE_TO_DEG_MAP[unit](angle2);
      }
      function parseFunctionalRgbColorComponents(text) {
        const m4 = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m4[1], 255),
          parseCssNumberOrPercentage(m4[2], 255),
          parseCssNumberOrPercentage(m4[3], 255)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbColorParser(type2) {
        return (text) => {
          const comps = parseFunctionalRgbColorComponents(text);
          return comps ? new Color2(comps, "rgb", type2) : null;
        };
      }
      function parseFunctionalRgbaColorComponents(text) {
        const m4 = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m4[1], 255),
          parseCssNumberOrPercentage(m4[2], 255),
          parseCssNumberOrPercentage(m4[3], 255),
          parseCssNumberOrPercentage(m4[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbaColorParser(type2) {
        return (text) => {
          const comps = parseFunctionalRgbaColorComponents(text);
          return comps ? new Color2(comps, "rgb", type2) : null;
        };
      }
      function parseHslColorComponents(text) {
        const m4 = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m4[1]),
          parseCssNumberOrPercentage(m4[2], 100),
          parseCssNumberOrPercentage(m4[3], 100)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createHslColorParser(type2) {
        return (text) => {
          const comps = parseHslColorComponents(text);
          return comps ? new Color2(comps, "hsl", type2) : null;
        };
      }
      function parseHslaColorComponents(text) {
        const m4 = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m4[1]),
          parseCssNumberOrPercentage(m4[2], 100),
          parseCssNumberOrPercentage(m4[3], 100),
          parseCssNumberOrPercentage(m4[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createHslaColorParser(type2) {
        return (text) => {
          const comps = parseHslaColorComponents(text);
          return comps ? new Color2(comps, "hsl", type2) : null;
        };
      }
      function parseHexRgbColorComponents(text) {
        const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16)
          ];
        }
        return null;
      }
      function parseHexRgbColor(text) {
        const comps = parseHexRgbColorComponents(text);
        return comps ? new Color2(comps, "rgb", "int") : null;
      }
      function parseHexRgbaColorComponents(text) {
        const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16),
            mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16),
            mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
          ];
        }
        return null;
      }
      function parseHexRgbaColor(text) {
        const comps = parseHexRgbaColorComponents(text);
        return comps ? new Color2(comps, "rgb", "int") : null;
      }
      function parseObjectRgbColorComponents(text) {
        const m4 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseFloat(m4[1]),
          parseFloat(m4[2]),
          parseFloat(m4[3])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbColorParser(type2) {
        return (text) => {
          const comps = parseObjectRgbColorComponents(text);
          return comps ? new Color2(comps, "rgb", type2) : null;
        };
      }
      function parseObjectRgbaColorComponents(text) {
        const m4 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m4) {
          return null;
        }
        const comps = [
          parseFloat(m4[1]),
          parseFloat(m4[2]),
          parseFloat(m4[3]),
          parseFloat(m4[4])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbaColorParser(type2) {
        return (text) => {
          const comps = parseObjectRgbaColorComponents(text);
          return comps ? new Color2(comps, "rgb", type2) : null;
        };
      }
      const PARSER_AND_RESULT = [
        {
          parser: parseHexRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseHexRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseFunctionalRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseFunctionalRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseHslColorComponents,
          result: {
            alpha: false,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseHslaColorComponents,
          result: {
            alpha: true,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseObjectRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "object"
          }
        },
        {
          parser: parseObjectRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "object"
          }
        }
      ];
      function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
          if (prev) {
            return prev;
          }
          return parser(text) ? detection : null;
        }, null);
      }
      function detectStringColorFormat(text, type2 = "int") {
        const r5 = detectStringColor(text);
        if (!r5) {
          return null;
        }
        if (r5.notation === "hex" && type2 !== "float") {
          return Object.assign(Object.assign({}, r5), { type: "int" });
        }
        if (r5.notation === "func") {
          return Object.assign(Object.assign({}, r5), { type: type2 });
        }
        return null;
      }
      const TYPE_TO_PARSERS = {
        int: [
          parseHexRgbColor,
          parseHexRgbaColor,
          createFunctionalRgbColorParser("int"),
          createFunctionalRgbaColorParser("int"),
          createHslColorParser("int"),
          createHslaColorParser("int"),
          createObjectRgbColorParser("int"),
          createObjectRgbaColorParser("int")
        ],
        float: [
          createFunctionalRgbColorParser("float"),
          createFunctionalRgbaColorParser("float"),
          createHslColorParser("float"),
          createHslaColorParser("float"),
          createObjectRgbColorParser("float"),
          createObjectRgbaColorParser("float")
        ]
      };
      function createColorStringBindingReader(type2) {
        const parsers = TYPE_TO_PARSERS[type2];
        return (value) => {
          if (typeof value !== "string") {
            return Color2.black(type2);
          }
          const result = parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
          return result !== null && result !== void 0 ? result : Color2.black(type2);
        };
      }
      function createColorStringParser(type2) {
        const parsers = TYPE_TO_PARSERS[type2];
        return (value) => {
          return parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
        };
      }
      function zerofill(comp) {
        const hex2 = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex2.length === 1 ? `0${hex2}` : hex2;
      }
      function colorToHexRgbString(value, prefix = "#") {
        const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToHexRgbaString(value, prefix = "#") {
        const rgbaComps = value.getComponents("rgb");
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents("rgb", opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(", ")})`;
      }
      function createFunctionalRgbColorFormatter(type2) {
        return (value) => {
          return colorToFunctionalRgbString(value, type2);
        };
      }
      function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = value.getComponents("rgb", opt_type).map((comp, index2) => {
          const formatter = index2 === 3 ? aFormatter : rgbFormatter;
          return formatter(comp);
        });
        return `rgba(${comps.join(", ")})`;
      }
      function createFunctionalRgbaColorFormatter(type2) {
        return (value) => {
          return colorToFunctionalRgbaString(value, type2);
        };
      }
      function colorToFunctionalHslString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage
        ];
        const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index2) => formatters[index2](comp));
        return `hsl(${comps.join(", ")})`;
      }
      function colorToFunctionalHslaString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage,
          createNumberFormatter(2)
        ];
        const comps = value.getComponents("hsl").map((comp, index2) => formatters[index2](comp));
        return `hsla(${comps.join(", ")})`;
      }
      function colorToObjectRgbString(value, type2) {
        const formatter = createNumberFormatter(type2 === "float" ? 2 : 0);
        const names = ["r", "g", "b"];
        const comps = removeAlphaComponent(value.getComponents("rgb", type2)).map((comp, index2) => `${names[index2]}: ${formatter(comp)}`);
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbColorFormatter(type2) {
        return (value) => colorToObjectRgbString(value, type2);
      }
      function colorToObjectRgbaString(value, type2) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type2 === "float" ? 2 : 0);
        const names = ["r", "g", "b", "a"];
        const comps = value.getComponents("rgb", type2).map((comp, index2) => {
          const formatter = index2 === 3 ? aFormatter : rgbFormatter;
          return `${names[index2]}: ${formatter(comp)}`;
        });
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbaColorFormatter(type2) {
        return (value) => colorToObjectRgbaString(value, type2);
      }
      const FORMAT_AND_STRINGIFIERS = [
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbString
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbaString
        },
        {
          format: {
            alpha: false,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslString
        },
        {
          format: {
            alpha: true,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslaString
        },
        ...["int", "float"].reduce((prev, type2) => {
          return [
            ...prev,
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "func",
                type: type2
              },
              stringifier: createFunctionalRgbColorFormatter(type2)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "func",
                type: type2
              },
              stringifier: createFunctionalRgbaColorFormatter(type2)
            },
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "object",
                type: type2
              },
              stringifier: createObjectRgbColorFormatter(type2)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "object",
                type: type2
              },
              stringifier: createObjectRgbaColorFormatter(type2)
            }
          ];
        }, [])
      ];
      function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
          if (prev) {
            return prev;
          }
          return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
        }, null);
      }
      const className$a = ClassName("apl");
      class APaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$a());
          config.viewProps.bindTabIndex(this.element);
          const barElem = doc.createElement("div");
          barElem.classList.add(className$a("b"));
          this.element.appendChild(barElem);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$a("c"));
          barElem.appendChild(colorElem);
          this.colorElem_ = colorElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$a("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          const previewElem = doc.createElement("div");
          previewElem.classList.add(className$a("p"));
          this.markerElem_.appendChild(previewElem);
          this.previewElem_ = previewElem;
          this.update_();
        }
        update_() {
          const c5 = this.value.rawValue;
          const rgbaComps = c5.getComponents("rgb");
          const leftColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
          const rightColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
          const gradientComps = [
            "to right",
            colorToFunctionalRgbaString(leftColor),
            colorToFunctionalRgbaString(rightColor)
          ];
          this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
          this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c5);
          const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class APaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new APaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d4, opts) {
          if (!d4.point) {
            return;
          }
          const alpha2 = d4.point.x / d4.bounds.width;
          const c5 = this.value.rawValue;
          const [h4, s5, v4] = c5.getComponents("hsv");
          this.value.setRawValue(new Color2([h4, s5, v4, alpha2], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c5 = this.value.rawValue;
          const [h4, s5, v4, a5] = c5.getComponents("hsv");
          this.value.setRawValue(new Color2([h4, s5, v4, a5 + step], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$9 = ClassName("coltxt");
      function createModeSelectElement(doc) {
        const selectElem = doc.createElement("select");
        const items = [
          { text: "RGB", value: "rgb" },
          { text: "HSL", value: "hsl" },
          { text: "HSV", value: "hsv" }
        ];
        selectElem.appendChild(items.reduce((frag, item) => {
          const optElem = doc.createElement("option");
          optElem.textContent = item.text;
          optElem.value = item.value;
          frag.appendChild(optElem);
          return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
      }
      class ColorTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$9());
          const modeElem = doc.createElement("div");
          modeElem.classList.add(className$9("m"));
          this.modeElem_ = createModeSelectElement(doc);
          this.modeElem_.classList.add(className$9("ms"));
          modeElem.appendChild(this.modeSelectElement);
          const modeMarkerElem = doc.createElement("div");
          modeMarkerElem.classList.add(className$9("mm"));
          modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
          modeElem.appendChild(modeMarkerElem);
          this.element.appendChild(modeElem);
          const textsElem = doc.createElement("div");
          textsElem.classList.add(className$9("w"));
          this.element.appendChild(textsElem);
          this.textsElem_ = textsElem;
          this.textViews_ = config.textViews;
          this.applyTextViews_();
          bindValue(config.colorMode, (mode) => {
            this.modeElem_.value = mode;
          });
        }
        get modeSelectElement() {
          return this.modeElem_;
        }
        get textViews() {
          return this.textViews_;
        }
        set textViews(textViews) {
          this.textViews_ = textViews;
          this.applyTextViews_();
        }
        applyTextViews_() {
          removeChildElements(this.textsElem_);
          const doc = this.element.ownerDocument;
          this.textViews_.forEach((v4) => {
            const compElem = doc.createElement("div");
            compElem.classList.add(className$9("c"));
            compElem.appendChild(v4.element);
            this.textsElem_.appendChild(compElem);
          });
        }
      }
      function createFormatter$2(type2) {
        return createNumberFormatter(type2 === "float" ? 2 : 0);
      }
      function createConstraint$5(mode, type2, index2) {
        const max = getColorMaxComponents(mode, type2)[index2];
        return new RangeConstraint({
          min: 0,
          max
        });
      }
      function createComponentController(doc, config, index2) {
        return new NumberTextController(doc, {
          arrayPosition: index2 === 0 ? "fst" : index2 === 3 - 1 ? "lst" : "mid",
          baseStep: getBaseStepForColor(false),
          parser: config.parser,
          props: ValueMap.fromObject({
            draggingScale: config.colorType === "float" ? 0.01 : 1,
            formatter: createFormatter$2(config.colorType)
          }),
          value: createValue(0, {
            constraint: createConstraint$5(config.colorMode, config.colorType, index2)
          }),
          viewProps: config.viewProps
        });
      }
      class ColorTextController {
        constructor(doc, config) {
          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
          this.colorType_ = config.colorType;
          this.parser_ = config.parser;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.colorMode = createValue(this.value.rawValue.mode);
          this.ccs_ = this.createComponentControllers_(doc);
          this.view = new ColorTextView(doc, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
          });
          this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
        }
        createComponentControllers_(doc) {
          const cc2 = {
            colorMode: this.colorMode.rawValue,
            colorType: this.colorType_,
            parser: this.parser_,
            viewProps: this.viewProps
          };
          const ccs = [
            createComponentController(doc, cc2, 0),
            createComponentController(doc, cc2, 1),
            createComponentController(doc, cc2, 2)
          ];
          ccs.forEach((cs, index2) => {
            connectValues({
              primary: this.value,
              secondary: cs.value,
              forward: (p3) => {
                return p3.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index2];
              },
              backward: (p3, s5) => {
                const pickedMode = this.colorMode.rawValue;
                const comps = p3.rawValue.getComponents(pickedMode, this.colorType_);
                comps[index2] = s5.rawValue;
                return new Color2(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
              }
            });
          });
          return ccs;
        }
        onModeSelectChange_(ev) {
          const selectElem = ev.currentTarget;
          this.colorMode.rawValue = selectElem.value;
          this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
          this.view.textViews = [
            this.ccs_[0].view,
            this.ccs_[1].view,
            this.ccs_[2].view
          ];
        }
      }
      const className$8 = ClassName("hpl");
      class HPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$8());
          config.viewProps.bindTabIndex(this.element);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$8("c"));
          this.element.appendChild(colorElem);
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$8("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const c5 = this.value.rawValue;
          const [h4] = c5.getComponents("hsv");
          this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color2([h4, 100, 100], "hsv"));
          const left = mapRange(h4, 0, 360, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class HPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new HPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d4, opts) {
          if (!d4.point) {
            return;
          }
          const hue = mapRange(constrainRange(d4.point.x, 0, d4.bounds.width), 0, d4.bounds.width, 0, 359);
          const c5 = this.value.rawValue;
          const [, s5, v4, a5] = c5.getComponents("hsv");
          this.value.setRawValue(new Color2([hue, s5, v4, a5], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c5 = this.value.rawValue;
          const [h4, s5, v4, a5] = c5.getComponents("hsv");
          this.value.setRawValue(new Color2([h4 + step, s5, v4, a5], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$7 = ClassName("svp");
      const CANVAS_RESOL = 64;
      class SvPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$7());
          config.viewProps.bindTabIndex(this.element);
          const canvasElem = doc.createElement("canvas");
          canvasElem.height = CANVAS_RESOL;
          canvasElem.width = CANVAS_RESOL;
          canvasElem.classList.add(className$7("c"));
          this.element.appendChild(canvasElem);
          this.canvasElement = canvasElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$7("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const ctx = getCanvasContext(this.canvasElement);
          if (!ctx) {
            return;
          }
          const c5 = this.value.rawValue;
          const hsvComps = c5.getComponents("hsv");
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;
          const imgData = ctx.getImageData(0, 0, width, height);
          const data = imgData.data;
          for (let iy = 0; iy < height; iy++) {
            for (let ix = 0; ix < width; ix++) {
              const s5 = mapRange(ix, 0, width, 0, 100);
              const v4 = mapRange(iy, 0, height, 100, 0);
              const rgbComps = hsvToRgbInt(hsvComps[0], s5, v4);
              const i4 = (iy * width + ix) * 4;
              data[i4] = rgbComps[0];
              data[i4 + 1] = rgbComps[1];
              data[i4 + 2] = rgbComps[2];
              data[i4 + 3] = 255;
            }
          }
          ctx.putImageData(imgData, 0, 0);
          const left = mapRange(hsvComps[1], 0, 100, 0, 100);
          this.markerElem_.style.left = `${left}%`;
          const top2 = mapRange(hsvComps[2], 0, 100, 100, 0);
          this.markerElem_.style.top = `${top2}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class SvPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SvPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d4, opts) {
          if (!d4.point) {
            return;
          }
          const saturation = mapRange(d4.point.x, 0, d4.bounds.width, 0, 100);
          const value = mapRange(d4.point.y, 0, d4.bounds.height, 100, 0);
          const [h4, , , a5] = this.value.rawValue.getComponents("hsv");
          this.value.setRawValue(new Color2([h4, saturation, value, a5], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [h4, s5, v4, a5] = this.value.rawValue.getComponents("hsv");
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(new Color2([h4, s5 + ds, v4 + dv, a5], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class ColorPickerController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.hPaletteC_ = new HPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.svPaletteC_ = new SvPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.alphaIcs_ = config.supportsAlpha ? {
            palette: new APaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new NumberTextController(doc, {
              parser: parseNumber,
              baseStep: 0.1,
              props: ValueMap.fromObject({
                draggingScale: 0.01,
                formatter: createNumberFormatter(2)
              }),
              value: createValue(0, {
                constraint: new RangeConstraint({ min: 0, max: 1 })
              }),
              viewProps: this.viewProps
            })
          } : null;
          if (this.alphaIcs_) {
            connectValues({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: (p3) => {
                return p3.rawValue.getComponents()[3];
              },
              backward: (p3, s5) => {
                const comps = p3.rawValue.getComponents();
                comps[3] = s5.rawValue;
                return new Color2(comps, p3.rawValue.mode);
              }
            });
          }
          this.textC_ = new ColorTextController(doc, {
            colorType: config.colorType,
            parser: parseNumber,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorPickerView(doc, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: config.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view
          });
        }
        get textController() {
          return this.textC_;
        }
      }
      const className$6 = ClassName("colsw");
      class ColorSwatchView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.element = doc.createElement("div");
          this.element.classList.add(className$6());
          config.viewProps.bindClassModifiers(this.element);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$6("sw"));
          this.element.appendChild(swatchElem);
          this.swatchElem_ = swatchElem;
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$6("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          this.update_();
        }
        update_() {
          const value = this.value.rawValue;
          this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ColorSwatchController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ColorSwatchView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      class ColorController {
        constructor(doc, config) {
          this.onButtonBlur_ = this.onButtonBlur_.bind(this);
          this.onButtonClick_ = this.onButtonClick_.bind(this);
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.swatchC_ = new ColorSwatchController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          const buttonElem = this.swatchC_.view.buttonElement;
          buttonElem.addEventListener("blur", this.onButtonBlur_);
          buttonElem.addEventListener("click", this.onButtonClick_);
          this.textC_ = new TextController(doc, {
            parser: config.parser,
            props: ValueMap.fromObject({
              formatter: config.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorView(doc, {
            foldable: this.foldable_,
            pickerLayout: config.pickerLayout
          });
          this.view.swatchElement.appendChild(this.swatchC_.view.element);
          this.view.textElement.appendChild(this.textC_.view.element);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const pickerC = new ColorPickerController(doc, {
            colorType: config.colorType,
            supportsAlpha: config.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          pickerC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = pickerC;
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(pickerC.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p3) => p3.rawValue,
              backward: (_4, s5) => s5.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        get textController() {
          return this.textC_;
        }
        onButtonBlur_(e5) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e5.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.swatchC_.view.buttonElement.focus();
            }
          }
        }
      }
      function colorFromObject(value, opt_type) {
        if (Color2.isColorObject(value)) {
          return Color2.fromObject(value, opt_type);
        }
        return Color2.black(opt_type);
      }
      function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
          return result << 8 | Math.floor(comp) & 255;
        }, 0);
      }
      function colorToRgbaNumber(value) {
        return value.getComponents("rgb").reduce((result, comp, index2) => {
          const hex2 = Math.floor(index2 === 3 ? comp * 255 : comp) & 255;
          return result << 8 | hex2;
        }, 0) >>> 0;
      }
      function numberToRgbColor(num) {
        return new Color2([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
      }
      function numberToRgbaColor(num) {
        return new Color2([
          num >> 24 & 255,
          num >> 16 & 255,
          num >> 8 & 255,
          mapRange(num & 255, 0, 255, 0, 1)
        ], "rgb");
      }
      function colorFromRgbNumber(value) {
        if (typeof value !== "number") {
          return Color2.black();
        }
        return numberToRgbColor(value);
      }
      function colorFromRgbaNumber(value) {
        if (typeof value !== "number") {
          return Color2.black();
        }
        return numberToRgbaColor(value);
      }
      function createColorStringWriter(format) {
        const stringify = findColorStringifier(format);
        return stringify ? (target, value) => {
          writePrimitive(target, stringify(value));
        } : null;
      }
      function createColorNumberWriter(supportsAlpha) {
        const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return (target, value) => {
          writePrimitive(target, colorToNumber(value));
        };
      }
      function writeRgbaColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
        target.writeProperty("a", obj.a);
      }
      function writeRgbColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
      }
      function createColorObjectWriter(supportsAlpha, opt_type) {
        return (target, inValue) => {
          if (supportsAlpha) {
            writeRgbaColorObject(target, inValue, opt_type);
          } else {
            writeRgbColorObject(target, inValue, opt_type);
          }
        };
      }
      function shouldSupportAlpha$1(inputParams) {
        var _a2;
        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a2 = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a2 === void 0 ? void 0 : _a2.alpha)) {
          return true;
        }
        return false;
      }
      function createFormatter$1(supportsAlpha) {
        return supportsAlpha ? (v4) => colorToHexRgbaString(v4, "0x") : (v4) => colorToHexRgbString(v4, "0x");
      }
      function isForColor(params) {
        if ("color" in params) {
          return true;
        }
        if ("view" in params && params.view === "color") {
          return true;
        }
        return false;
      }
      const NumberColorInputPlugin = {
        id: "input-color-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          if (!isForColor(params)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
          },
          equals: Color2.equals,
          writer: (args) => {
            return createColorNumberWriter(shouldSupportAlpha$1(args.params));
          }
        },
        controller: (args) => {
          const supportsAlpha = shouldSupportAlpha$1(args.params);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: "int",
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createFormatter$1(supportsAlpha),
            parser: createColorStringParser("int"),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      function shouldSupportAlpha(initialValue) {
        return Color2.isRgbaColorObject(initialValue);
      }
      function createColorObjectReader(opt_type) {
        return (value) => {
          return colorFromObject(value, opt_type);
        };
      }
      function createColorObjectFormatter(supportsAlpha, type2) {
        return (value) => {
          if (supportsAlpha) {
            return colorToObjectRgbaString(value, type2);
          }
          return colorToObjectRgbString(value, type2);
        };
      }
      const ObjectColorInputPlugin = {
        id: "input-color-object",
        type: "input",
        accept: (value, params) => {
          if (!Color2.isColorObject(value)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => createColorObjectReader(extractColorType(args.params)),
          equals: Color2.equals,
          writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params))
        },
        controller: (args) => {
          var _a2;
          const supportsAlpha = Color2.isRgbaColorObject(args.initialValue);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          const type2 = (_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int";
          return new ColorController(args.document, {
            colorType: type2,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createColorObjectFormatter(supportsAlpha, type2),
            parser: createColorStringParser(type2),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const StringColorInputPlugin = {
        id: "input-color-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          if ("view" in params && params.view === "text") {
            return null;
          }
          const format = detectStringColorFormat(value, extractColorType(params));
          if (!format) {
            return null;
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            var _a2;
            return createColorStringBindingReader((_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int");
          },
          equals: Color2.equals,
          writer: (args) => {
            const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
            if (!format) {
              throw TpError.shouldNeverHappen();
            }
            const writer = createColorStringWriter(format);
            if (!writer) {
              throw TpError.notBindable();
            }
            return writer;
          }
        },
        controller: (args) => {
          const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
          if (!format) {
            throw TpError.shouldNeverHappen();
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: format.type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: stringifier,
            parser: createColorStringParser(format.type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha: format.alpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      class PointNdConstraint {
        constructor(config) {
          this.components = config.components;
          this.asm_ = config.assembly;
        }
        constrain(value) {
          const comps = this.asm_.toComponents(value).map((comp, index2) => {
            var _a2, _b;
            return (_b = (_a2 = this.components[index2]) === null || _a2 === void 0 ? void 0 : _a2.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
          });
          return this.asm_.fromComponents(comps);
        }
      }
      const className$5 = ClassName("pndtxt");
      class PointNdTextView {
        constructor(doc, config) {
          this.textViews = config.textViews;
          this.element = doc.createElement("div");
          this.element.classList.add(className$5());
          this.textViews.forEach((v4) => {
            const axisElem = doc.createElement("div");
            axisElem.classList.add(className$5("a"));
            axisElem.appendChild(v4.element);
            this.element.appendChild(axisElem);
          });
        }
      }
      function createAxisController(doc, config, index2) {
        return new NumberTextController(doc, {
          arrayPosition: index2 === 0 ? "fst" : index2 === config.axes.length - 1 ? "lst" : "mid",
          baseStep: config.axes[index2].baseStep,
          parser: config.parser,
          props: config.axes[index2].textProps,
          value: createValue(0, {
            constraint: config.axes[index2].constraint
          }),
          viewProps: config.viewProps
        });
      }
      class PointNdTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.acs_ = config.axes.map((_4, index2) => createAxisController(doc, config, index2));
          this.acs_.forEach((c5, index2) => {
            connectValues({
              primary: this.value,
              secondary: c5.value,
              forward: (p3) => {
                return config.assembly.toComponents(p3.rawValue)[index2];
              },
              backward: (p3, s5) => {
                const comps = config.assembly.toComponents(p3.rawValue);
                comps[index2] = s5.rawValue;
                return config.assembly.fromComponents(comps);
              }
            });
          });
          this.view = new PointNdTextView(doc, {
            textViews: this.acs_.map((ac) => ac.view)
          });
        }
      }
      function createStepConstraint(params, initialValue) {
        if ("step" in params && !isEmpty(params.step)) {
          return new StepConstraint(params.step, initialValue);
        }
        return null;
      }
      function createRangeConstraint(params) {
        if ("max" in params && !isEmpty(params.max) || "min" in params && !isEmpty(params.min)) {
          return new RangeConstraint({
            max: params.max,
            min: params.min
          });
        }
        return null;
      }
      function createConstraint$4(params, initialValue) {
        const constraints = [];
        const sc = createStepConstraint(params, initialValue);
        if (sc) {
          constraints.push(sc);
        }
        const rc = createRangeConstraint(params);
        if (rc) {
          constraints.push(rc);
        }
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      function findRange(constraint) {
        const c5 = constraint ? findConstraint(constraint, RangeConstraint) : null;
        if (!c5) {
          return [void 0, void 0];
        }
        return [c5.minValue, c5.maxValue];
      }
      function estimateSuitableRange(constraint) {
        const [min, max] = findRange(constraint);
        return [min !== null && min !== void 0 ? min : 0, max !== null && max !== void 0 ? max : 100];
      }
      const NumberInputPlugin = {
        id: "input-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            format: p3.optional.function,
            max: p3.optional.number,
            min: p3.optional.number,
            options: p3.optional.custom(parseListOptions),
            step: p3.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => numberFromUnknown,
          constraint: (args) => createConstraint$4(args.params, args.initialValue),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          var _a2, _b;
          const value = args.value;
          const c5 = args.constraint;
          if (c5 && findConstraint(c5, ListConstraint)) {
            return new ListController(args.document, {
              props: ValueMap.fromObject({
                options: (_a2 = findListItems(c5)) !== null && _a2 !== void 0 ? _a2 : []
              }),
              value,
              viewProps: args.viewProps
            });
          }
          const formatter = (_b = "format" in args.params ? args.params.format : void 0) !== null && _b !== void 0 ? _b : createNumberFormatter(getSuitableDecimalDigits(c5, value.rawValue));
          if (c5 && findConstraint(c5, RangeConstraint)) {
            const [min, max] = estimateSuitableRange(c5);
            return new SliderTextController(args.document, {
              baseStep: getBaseStep(c5),
              parser: parseNumber,
              sliderProps: ValueMap.fromObject({
                maxValue: max,
                minValue: min
              }),
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c5, value.rawValue),
                formatter
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new NumberTextController(args.document, {
            baseStep: getBaseStep(c5),
            parser: parseNumber,
            props: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(c5, value.rawValue),
              formatter
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point2d {
        constructor(x2 = 0, y4 = 0) {
          this.x = x2;
          this.y = y4;
        }
        getComponents() {
          return [this.x, this.y];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x2 = obj.x;
          const y4 = obj.y;
          if (typeof x2 !== "number" || typeof y4 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v1, v22) {
          return v1.x === v22.x && v1.y === v22.y;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }
      }
      const Point2dAssembly = {
        toComponents: (p3) => p3.getComponents(),
        fromComponents: (comps) => new Point2d(...comps)
      };
      const className$4 = ClassName("p2d");
      class Point2dView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$4());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$4("h"));
          this.element.appendChild(headElem);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$4("b"));
          buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
          config.viewProps.bindDisabled(buttonElem);
          headElem.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$4("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$4("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      const className$3 = ClassName("p2dp");
      class Point2dPickerView {
        constructor(doc, config) {
          this.onFoldableChange_ = this.onFoldableChange_.bind(this);
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.invertsY_ = config.invertsY;
          this.maxValue_ = config.maxValue;
          this.element = doc.createElement("div");
          this.element.classList.add(className$3());
          if (config.layout === "popup") {
            this.element.classList.add(className$3(void 0, "p"));
          }
          const padElem = doc.createElement("div");
          padElem.classList.add(className$3("p"));
          config.viewProps.bindTabIndex(padElem);
          this.element.appendChild(padElem);
          this.padElement = padElem;
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className$3("g"));
          this.padElement.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const xAxisElem = doc.createElementNS(SVG_NS, "line");
          xAxisElem.classList.add(className$3("ax"));
          xAxisElem.setAttributeNS(null, "x1", "0");
          xAxisElem.setAttributeNS(null, "y1", "50%");
          xAxisElem.setAttributeNS(null, "x2", "100%");
          xAxisElem.setAttributeNS(null, "y2", "50%");
          this.svgElem_.appendChild(xAxisElem);
          const yAxisElem = doc.createElementNS(SVG_NS, "line");
          yAxisElem.classList.add(className$3("ax"));
          yAxisElem.setAttributeNS(null, "x1", "50%");
          yAxisElem.setAttributeNS(null, "y1", "0");
          yAxisElem.setAttributeNS(null, "x2", "50%");
          yAxisElem.setAttributeNS(null, "y2", "100%");
          this.svgElem_.appendChild(yAxisElem);
          const lineElem = doc.createElementNS(SVG_NS, "line");
          lineElem.classList.add(className$3("l"));
          lineElem.setAttributeNS(null, "x1", "50%");
          lineElem.setAttributeNS(null, "y1", "50%");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$3("m"));
          this.padElement.appendChild(markerElem);
          this.markerElem_ = markerElem;
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        get allFocusableElements() {
          return [this.padElement];
        }
        update_() {
          const [x2, y4] = this.value.rawValue.getComponents();
          const max = this.maxValue_;
          const px2 = mapRange(x2, -max, +max, 0, 100);
          const py = mapRange(y4, -max, +max, 0, 100);
          const ipy = this.invertsY_ ? 100 - py : py;
          this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
          this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
          this.markerElem_.style.left = `${px2}%`;
          this.markerElem_.style.top = `${ipy}%`;
        }
        onValueChange_() {
          this.update_();
        }
        onFoldableChange_() {
          this.update_();
        }
      }
      function computeOffset(ev, baseSteps, invertsY) {
        return [
          getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
          getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
        ];
      }
      class Point2dPickerController {
        constructor(doc, config) {
          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
          this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.baseSteps_ = config.baseSteps;
          this.maxValue_ = config.maxValue;
          this.invertsY_ = config.invertsY;
          this.view = new Point2dPickerView(doc, {
            invertsY: this.invertsY_,
            layout: config.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.padElement);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
          this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
        }
        handlePointerEvent_(d4, opts) {
          if (!d4.point) {
            return;
          }
          const max = this.maxValue_;
          const px2 = mapRange(d4.point.x, 0, d4.bounds.width, -max, +max);
          const py = mapRange(this.invertsY_ ? d4.bounds.height - d4.point.y : d4.point.y, 0, d4.bounds.height, -max, +max);
          this.value.setRawValue(new Point2d(px2, py), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onPadKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
            forceEmit: false,
            last: false
          });
        }
        onPadKeyUp_(ev) {
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class Point2dController {
        constructor(doc, config) {
          var _a2, _b;
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
          this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const padC = new Point2dPickerController(doc, {
            baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
            invertsY: config.invertsY,
            layout: config.pickerLayout,
            maxValue: config.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          padC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = padC;
          this.textC_ = new PointNdTextController(doc, {
            assembly: Point2dAssembly,
            axes: config.axes,
            parser: config.parser,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new Point2dView(doc, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: config.pickerLayout,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.textC_.view.element);
          (_a2 = this.view.buttonElement) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("blur", this.onPadButtonBlur_);
          (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.onPadButtonClick_);
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(this.pickerC_.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p3) => p3.rawValue,
              backward: (_4, s5) => s5.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        onPadButtonBlur_(e5) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e5.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onPadButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.view.buttonElement.focus();
            }
          }
        }
      }
      function point2dFromUnknown(value) {
        return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
      }
      function writePoint2d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
      }
      function createDimensionConstraint(params, initialValue) {
        if (!params) {
          return void 0;
        }
        const constraints = [];
        const cs = createStepConstraint(params, initialValue);
        if (cs) {
          constraints.push(cs);
        }
        const rs = createRangeConstraint(params);
        if (rs) {
          constraints.push(rs);
        }
        return new CompositeConstraint(constraints);
      }
      function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point2dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y)
          ]
        });
      }
      function getSuitableMaxDimensionValue(constraint, rawValue) {
        var _a2, _b;
        const rc = constraint && findConstraint(constraint, RangeConstraint);
        if (rc) {
          return Math.max(Math.abs((_a2 = rc.minValue) !== null && _a2 !== void 0 ? _a2 : 0), Math.abs((_b = rc.maxValue) !== null && _b !== void 0 ? _b : 0));
        }
        const step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
      }
      function getSuitableMaxValue(initialValue, constraint) {
        const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
        const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
        const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
      }
      function createAxis$2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      function shouldInvertY(params) {
        if (!("y" in params)) {
          return false;
        }
        const yParams = params.y;
        if (!yParams) {
          return false;
        }
        return "inverted" in yParams ? !!yParams.inverted : false;
      }
      const Point2dInputPlugin = {
        id: "input-point2d",
        type: "input",
        accept: (value, params) => {
          if (!Point2d.isObject(value)) {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            expanded: p3.optional.boolean,
            picker: p3.optional.custom(parsePickerLayout),
            x: p3.optional.custom(parsePointDimensionParams),
            y: p3.optional.object({
              inverted: p3.optional.boolean,
              max: p3.optional.number,
              min: p3.optional.number,
              step: p3.optional.number
            })
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point2dFromUnknown,
          constraint: (args) => createConstraint$3(args.params, args.initialValue),
          equals: Point2d.equals,
          writer: (_args) => writePoint2d
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c5 = args.constraint;
          if (!(c5 instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new Point2dController(doc, {
            axes: [
              createAxis$2(value.rawValue.x, c5.components[0]),
              createAxis$2(value.rawValue.y, c5.components[1])
            ],
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            invertsY: shouldInvertY(args.params),
            maxValue: getSuitableMaxValue(value.rawValue, c5),
            parser: parseNumber,
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point3d2 {
        constructor(x2 = 0, y4 = 0, z3 = 0) {
          this.x = x2;
          this.y = y4;
          this.z = z3;
        }
        getComponents() {
          return [this.x, this.y, this.z];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x2 = obj.x;
          const y4 = obj.y;
          const z3 = obj.z;
          if (typeof x2 !== "number" || typeof y4 !== "number" || typeof z3 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v1, v22) {
          return v1.x === v22.x && v1.y === v22.y && v1.z === v22.z;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z
          };
        }
      }
      const Point3dAssembly = {
        toComponents: (p3) => p3.getComponents(),
        fromComponents: (comps) => new Point3d2(...comps)
      };
      function point3dFromUnknown(value) {
        return Point3d2.isObject(value) ? new Point3d2(value.x, value.y, value.z) : new Point3d2();
      }
      function writePoint3d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
      }
      function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point3dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z)
          ]
        });
      }
      function createAxis$1(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point3dInputPlugin = {
        id: "input-point3d",
        type: "input",
        accept: (value, params) => {
          if (!Point3d2.isObject(value)) {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            x: p3.optional.custom(parsePointDimensionParams),
            y: p3.optional.custom(parsePointDimensionParams),
            z: p3.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point3dFromUnknown,
          constraint: (args) => createConstraint$2(args.params, args.initialValue),
          equals: Point3d2.equals,
          writer: (_args) => writePoint3d
        },
        controller: (args) => {
          const value = args.value;
          const c5 = args.constraint;
          if (!(c5 instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point3dAssembly,
            axes: [
              createAxis$1(value.rawValue.x, c5.components[0]),
              createAxis$1(value.rawValue.y, c5.components[1]),
              createAxis$1(value.rawValue.z, c5.components[2])
            ],
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point4d {
        constructor(x2 = 0, y4 = 0, z3 = 0, w4 = 0) {
          this.x = x2;
          this.y = y4;
          this.z = z3;
          this.w = w4;
        }
        getComponents() {
          return [this.x, this.y, this.z, this.w];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x2 = obj.x;
          const y4 = obj.y;
          const z3 = obj.z;
          const w4 = obj.w;
          if (typeof x2 !== "number" || typeof y4 !== "number" || typeof z3 !== "number" || typeof w4 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v1, v22) {
          return v1.x === v22.x && v1.y === v22.y && v1.z === v22.z && v1.w === v22.w;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
          };
        }
      }
      const Point4dAssembly = {
        toComponents: (p3) => p3.getComponents(),
        fromComponents: (comps) => new Point4d(...comps)
      };
      function point4dFromUnknown(value) {
        return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
      }
      function writePoint4d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
        target.writeProperty("w", value.w);
      }
      function createConstraint$1(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point4dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z),
            createDimensionConstraint("w" in params ? params.w : void 0, initialValue.w)
          ]
        });
      }
      function createAxis(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point4dInputPlugin = {
        id: "input-point4d",
        type: "input",
        accept: (value, params) => {
          if (!Point4d.isObject(value)) {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            x: p3.optional.custom(parsePointDimensionParams),
            y: p3.optional.custom(parsePointDimensionParams),
            z: p3.optional.custom(parsePointDimensionParams),
            w: p3.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point4dFromUnknown,
          constraint: (args) => createConstraint$1(args.params, args.initialValue),
          equals: Point4d.equals,
          writer: (_args) => writePoint4d
        },
        controller: (args) => {
          const value = args.value;
          const c5 = args.constraint;
          if (!(c5 instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point4dAssembly,
            axes: value.rawValue.getComponents().map((comp, index2) => createAxis(comp, c5.components[index2])),
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      function createConstraint(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      const StringInputPlugin = {
        id: "input-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            options: p3.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown,
          constraint: (args) => createConstraint(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          var _a2;
          const doc = args.document;
          const value = args.value;
          const c5 = args.constraint;
          if (c5 && findConstraint(c5, ListConstraint)) {
            return new ListController(doc, {
              props: ValueMap.fromObject({
                options: (_a2 = findListItems(c5)) !== null && _a2 !== void 0 ? _a2 : []
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new TextController(doc, {
            parser: (v4) => v4,
            props: ValueMap.fromObject({
              formatter: formatString
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      const Constants = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      };
      const className$2 = ClassName("mll");
      class MultiLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$2());
          config.viewProps.bindClassModifiers(this.element);
          const textareaElem = doc.createElement("textarea");
          textareaElem.classList.add(className$2("i"));
          textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          textareaElem.readOnly = true;
          config.viewProps.bindDisabled(textareaElem);
          this.element.appendChild(textareaElem);
          this.textareaElem_ = textareaElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const elem = this.textareaElem_;
          const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
          const lines = [];
          this.value.rawValue.forEach((value) => {
            if (value !== void 0) {
              lines.push(this.formatter_(value));
            }
          });
          elem.textContent = lines.join("\n");
          if (shouldScroll) {
            elem.scrollTop = elem.scrollHeight;
          }
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class MultiLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new MultiLogView(doc, {
            formatter: config.formatter,
            lineCount: config.lineCount,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const className$1 = ClassName("sgl");
      class SingleLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$1());
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$1("i"));
          inputElem.readOnly = true;
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const values = this.value.rawValue;
          const lastValue = values[values.length - 1];
          this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class SingleLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SingleLogView(doc, {
            formatter: config.formatter,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const BooleanMonitorPlugin = {
        id: "monitor-bool",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p3.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown
        },
        controller: (args) => {
          var _a2;
          if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
              formatter: BooleanFormatter,
              value: args.value,
              viewProps: args.viewProps
            });
          }
          return new MultiLogController(args.document, {
            formatter: BooleanFormatter,
            lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const className = ClassName("grl");
      class GraphLogView {
        constructor(doc, config) {
          this.onCursorChange_ = this.onCursorChange_.bind(this);
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className());
          config.viewProps.bindClassModifiers(this.element);
          this.formatter_ = config.formatter;
          this.props_ = config.props;
          this.cursor_ = config.cursor;
          this.cursor_.emitter.on("change", this.onCursorChange_);
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className("g"));
          svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const lineElem = doc.createElementNS(SVG_NS, "polyline");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(className("t"), ClassName("tt")());
          this.element.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        get graphElement() {
          return this.svgElem_;
        }
        update_() {
          const bounds = this.svgElem_.getBoundingClientRect();
          const maxIndex = this.value.rawValue.length - 1;
          const min = this.props_.get("minValue");
          const max = this.props_.get("maxValue");
          const points = [];
          this.value.rawValue.forEach((v4, index2) => {
            if (v4 === void 0) {
              return;
            }
            const x2 = mapRange(index2, 0, maxIndex, 0, bounds.width);
            const y4 = mapRange(v4, min, max, bounds.height, 0);
            points.push([x2, y4].join(","));
          });
          this.lineElem_.setAttributeNS(null, "points", points.join(" "));
          const tooltipElem = this.tooltipElem_;
          const value = this.value.rawValue[this.cursor_.rawValue];
          if (value === void 0) {
            tooltipElem.classList.remove(className("t", "a"));
            return;
          }
          const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
          const ty = mapRange(value, min, max, bounds.height, 0);
          tooltipElem.style.left = `${tx}px`;
          tooltipElem.style.top = `${ty}px`;
          tooltipElem.textContent = `${this.formatter_(value)}`;
          if (!tooltipElem.classList.contains(className("t", "a"))) {
            tooltipElem.classList.add(className("t", "a"), className("t", "in"));
            forceReflow(tooltipElem);
            tooltipElem.classList.remove(className("t", "in"));
          }
        }
        onValueUpdate_() {
          this.update_();
        }
        onCursorChange_() {
          this.update_();
        }
      }
      class GraphLogController {
        constructor(doc, config) {
          this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
          this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
          this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
          this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
          this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
          this.props_ = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.cursor_ = createValue(-1);
          this.view = new GraphLogView(doc, {
            cursor: this.cursor_,
            formatter: config.formatter,
            lineCount: config.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          });
          if (!supportsTouch(doc)) {
            this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
            this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
          } else {
            const ph = new PointerHandler(this.view.element);
            ph.emitter.on("down", this.onGraphPointerDown_);
            ph.emitter.on("move", this.onGraphPointerMove_);
            ph.emitter.on("up", this.onGraphPointerUp_);
          }
        }
        onGraphMouseLeave_() {
          this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(ev) {
          const bounds = this.view.element.getBoundingClientRect();
          this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(ev) {
          this.onGraphPointerMove_(ev);
        }
        onGraphPointerMove_(ev) {
          if (!ev.data.point) {
            this.cursor_.rawValue = -1;
            return;
          }
          this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
          this.cursor_.rawValue = -1;
        }
      }
      function createFormatter(params) {
        return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
      }
      function createTextMonitor(args) {
        var _a2;
        if (args.value.rawValue.length === 1) {
          return new SingleLogController(args.document, {
            formatter: createFormatter(args.params),
            value: args.value,
            viewProps: args.viewProps
          });
        }
        return new MultiLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function createGraphMonitor(args) {
        var _a2, _b, _c;
        return new GraphLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
          props: ValueMap.fromObject({
            maxValue: (_b = "max" in args.params ? args.params.max : null) !== null && _b !== void 0 ? _b : 100,
            minValue: (_c = "min" in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0
          }),
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function shouldShowGraph(params) {
        return "view" in params && params.view === "graph";
      }
      const NumberMonitorPlugin = {
        id: "monitor-number",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            format: p3.optional.function,
            lineCount: p3.optional.number,
            max: p3.optional.number,
            min: p3.optional.number,
            view: p3.optional.string
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
          reader: (_args) => numberFromUnknown
        },
        controller: (args) => {
          if (shouldShowGraph(args.params)) {
            return createGraphMonitor(args);
          }
          return createTextMonitor(args);
        }
      };
      const StringMonitorPlugin = {
        id: "monitor-string",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p3.optional.number,
            multiline: p3.optional.boolean
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown
        },
        controller: (args) => {
          var _a2;
          const value = args.value;
          const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
          if (multiline) {
            return new MultiLogController(args.document, {
              formatter: formatString,
              lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
              value,
              viewProps: args.viewProps
            });
          }
          return new SingleLogController(args.document, {
            formatter: formatString,
            value,
            viewProps: args.viewProps
          });
        }
      };
      class InputBinding {
        constructor(config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.reader = config.reader;
          this.writer = config.writer;
          this.emitter = new Emitter();
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.target = config.target;
          this.read();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue !== void 0) {
            this.value.rawValue = this.reader(targetValue);
          }
        }
        write_(rawValue) {
          this.writer(this.target, rawValue);
        }
        onValueChange_(ev) {
          this.write_(ev.rawValue);
          this.emitter.emit("change", {
            options: ev.options,
            rawValue: ev.rawValue,
            sender: this
          });
        }
      }
      function createInputBindingController(plugin, args) {
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const p3 = ParamsParsers;
        const valueArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(valueArgs);
        const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
        const value = createValue(reader(result.initialValue), {
          constraint,
          equals: plugin.binding.equals
        });
        const binding = new InputBinding({
          reader,
          target: args.target,
          value,
          writer: plugin.binding.writer(valueArgs)
        });
        const disabled = p3.optional.boolean(args.params.disabled).value;
        const hidden = p3.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          constraint,
          document: args.document,
          initialValue: result.initialValue,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        const label = p3.optional.string(args.params.label).value;
        return new InputBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: label !== null && label !== void 0 ? label : args.target.key
          }),
          valueController: controller
        });
      }
      class MonitorBinding {
        constructor(config) {
          this.onTick_ = this.onTick_.bind(this);
          this.reader_ = config.reader;
          this.target = config.target;
          this.emitter = new Emitter();
          this.value = config.value;
          this.ticker = config.ticker;
          this.ticker.emitter.on("tick", this.onTick_);
          this.read();
        }
        dispose() {
          this.ticker.dispose();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue === void 0) {
            return;
          }
          const buffer = this.value.rawValue;
          const newValue = this.reader_(targetValue);
          this.value.rawValue = createPushedBuffer(buffer, newValue);
          this.emitter.emit("update", {
            rawValue: newValue,
            sender: this
          });
        }
        onTick_(_4) {
          this.read();
        }
      }
      function createTicker(document2, interval) {
        return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
      }
      function createMonitorBindingController(plugin, args) {
        var _a2, _b, _c;
        const P3 = ParamsParsers;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const bindingArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(bindingArgs);
        const bufferSize = (_b = (_a2 = P3.optional.number(args.params.bufferSize).value) !== null && _a2 !== void 0 ? _a2 : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
        const interval = P3.optional.number(args.params.interval).value;
        const binding = new MonitorBinding({
          reader,
          target: args.target,
          ticker: createTicker(args.document, interval),
          value: initializeBuffer(bufferSize)
        });
        const disabled = P3.optional.boolean(args.params.disabled).value;
        const hidden = P3.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          document: args.document,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        const label = (_c = P3.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : args.target.key;
        return new MonitorBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label
          }),
          valueController: controller
        });
      }
      class PluginPool {
        constructor() {
          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }
        getAll() {
          return [
            ...this.pluginsMap_.blades,
            ...this.pluginsMap_.inputs,
            ...this.pluginsMap_.monitors
          ];
        }
        register(r5) {
          if (r5.type === "blade") {
            this.pluginsMap_.blades.unshift(r5);
          } else if (r5.type === "input") {
            this.pluginsMap_.inputs.unshift(r5);
          } else if (r5.type === "monitor") {
            this.pluginsMap_.monitors.unshift(r5);
          }
        }
        createInput(document2, target, params) {
          const initialValue = target.read();
          if (isEmpty(initialValue)) {
            throw new TpError({
              context: {
                key: target.key
              },
              type: "nomatchingcontroller"
            });
          }
          const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
            document: document2,
            target,
            params
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createMonitor(document2, target, params) {
          const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
            document: document2,
            params,
            target
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createBlade(document2, params) {
          const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
            document: document2,
            params
          }), null);
          if (!bc) {
            throw new TpError({
              type: "nomatchingview",
              context: {
                params
              }
            });
          }
          return bc;
        }
        createBladeApi(bc) {
          if (bc instanceof InputBindingController) {
            return new InputBindingApi(bc);
          }
          if (bc instanceof MonitorBindingController) {
            return new MonitorBindingApi(bc);
          }
          if (bc instanceof RackController) {
            return new RackApi(bc, this);
          }
          const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
            controller: bc,
            pool: this
          }), null);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
      }
      function createDefaultPluginPool() {
        const pool = new PluginPool();
        [
          Point2dInputPlugin,
          Point3dInputPlugin,
          Point4dInputPlugin,
          StringInputPlugin,
          NumberInputPlugin,
          StringColorInputPlugin,
          ObjectColorInputPlugin,
          NumberColorInputPlugin,
          BooleanInputPlugin,
          BooleanMonitorPlugin,
          StringMonitorPlugin,
          NumberMonitorPlugin,
          ButtonBladePlugin,
          FolderBladePlugin,
          SeparatorBladePlugin,
          TabBladePlugin
        ].forEach((p3) => {
          pool.register(p3);
        });
        return pool;
      }
      class ListApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get options() {
          return this.controller_.valueController.props.get("options");
        }
        set options(options) {
          this.controller_.valueController.props.set("options", options);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class SliderApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get maxValue() {
          return this.controller_.valueController.sliderController.props.get("maxValue");
        }
        set maxValue(maxValue) {
          this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
        }
        get minValue() {
          return this.controller_.valueController.sliderController.props.get("minValue");
        }
        set minValue(minValue) {
          this.controller_.valueController.sliderController.props.set("minValue", minValue);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class TextApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get formatter() {
          return this.controller_.valueController.props.get("formatter");
        }
        set formatter(formatter) {
          this.controller_.valueController.props.set("formatter", formatter);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      const ListBladePlugin = function() {
        return {
          id: "list",
          type: "blade",
          accept(params) {
            const p3 = ParamsParsers;
            const result = parseParams(params, {
              options: p3.required.custom(parseListOptions),
              value: p3.required.raw,
              view: p3.required.constant("list"),
              label: p3.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            const ic = new ListController(args.document, {
              props: ValueMap.fromObject({
                options: normalizeListOptions(args.params.options)
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof ListController)) {
              return null;
            }
            return new ListApi(args.controller);
          }
        };
      }();
      function exportPresetJson(targets) {
        return targets.reduce((result, target) => {
          return Object.assign(result, {
            [target.presetKey]: target.read()
          });
        }, {});
      }
      function importPresetJson(targets, preset) {
        targets.forEach((target) => {
          const value = preset[target.presetKey];
          if (value !== void 0) {
            target.write(value);
          }
        });
      }
      class RootApi extends FolderApi {
        constructor(controller, pool) {
          super(controller, pool);
        }
        get element() {
          return this.controller_.view.element;
        }
        importPreset(preset) {
          const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding.target;
          });
          importPresetJson(targets, preset);
          this.refresh();
        }
        exportPreset() {
          const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding.target;
          });
          return exportPresetJson(targets);
        }
        refresh() {
          this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
            ibc.binding.read();
          });
          this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
            mbc.binding.read();
          });
        }
      }
      class RootController extends FolderController {
        constructor(doc, config) {
          super(doc, {
            expanded: config.expanded,
            blade: config.blade,
            props: config.props,
            root: true,
            viewProps: config.viewProps
          });
        }
      }
      const SliderBladePlugin = {
        id: "slider",
        type: "blade",
        accept(params) {
          const p3 = ParamsParsers;
          const result = parseParams(params, {
            max: p3.required.number,
            min: p3.required.number,
            view: p3.required.constant("slider"),
            format: p3.optional.function,
            label: p3.optional.string,
            value: p3.optional.number
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          var _a2, _b;
          const v4 = (_a2 = args.params.value) !== null && _a2 !== void 0 ? _a2 : 0;
          const vc = new SliderTextController(args.document, {
            baseStep: 1,
            parser: parseNumber,
            sliderProps: ValueMap.fromObject({
              maxValue: args.params.max,
              minValue: args.params.min
            }),
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(void 0, v4),
              formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString
            }),
            value: createValue(v4),
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: vc
          });
        },
        api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof SliderTextController)) {
            return null;
          }
          return new SliderApi(args.controller);
        }
      };
      const TextBladePlugin = function() {
        return {
          id: "text",
          type: "blade",
          accept(params) {
            const p3 = ParamsParsers;
            const result = parseParams(params, {
              parse: p3.required.function,
              value: p3.required.raw,
              view: p3.required.constant("text"),
              format: p3.optional.function,
              label: p3.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            var _a2;
            const ic = new TextController(args.document, {
              parser: args.params.parse,
              props: ValueMap.fromObject({
                formatter: (_a2 = args.params.format) !== null && _a2 !== void 0 ? _a2 : (v4) => String(v4)
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof TextController)) {
              return null;
            }
            return new TextApi(args.controller);
          }
        };
      }();
      function createDefaultWrapperElement(doc) {
        const elem = doc.createElement("div");
        elem.classList.add(ClassName("dfw")());
        if (doc.body) {
          doc.body.appendChild(elem);
        }
        return elem;
      }
      function embedStyle(doc, id, css) {
        if (doc.querySelector(`style[data-tp-style=${id}]`)) {
          return;
        }
        const styleElem = doc.createElement("style");
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
      }
      class Pane2 extends RootApi {
        constructor(opt_config) {
          var _a2, _b;
          const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
          const doc = (_a2 = config.document) !== null && _a2 !== void 0 ? _a2 : getWindowDocument();
          const pool = createDefaultPluginPool();
          const rootController = new RootController(doc, {
            expanded: config.expanded,
            blade: createBlade(),
            props: ValueMap.fromObject({
              title: config.title
            }),
            viewProps: ViewProps.create()
          });
          super(rootController, pool);
          this.pool_ = pool;
          this.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);
          this.containerElem_.appendChild(this.element);
          this.doc_ = doc;
          this.usesDefaultWrapper_ = !config.container;
          this.setUpDefaultPlugins_();
        }
        get document() {
          if (!this.doc_) {
            throw TpError.alreadyDisposed();
          }
          return this.doc_;
        }
        dispose() {
          const containerElem = this.containerElem_;
          if (!containerElem) {
            throw TpError.alreadyDisposed();
          }
          if (this.usesDefaultWrapper_) {
            const parentElem = containerElem.parentElement;
            if (parentElem) {
              parentElem.removeChild(containerElem);
            }
          }
          this.containerElem_ = null;
          this.doc_ = null;
          super.dispose();
        }
        registerPlugin(bundle) {
          const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
          plugins.forEach((p3) => {
            this.pool_.register(p3);
            this.embedPluginStyle_(p3);
          });
        }
        embedPluginStyle_(plugin) {
          if (plugin.css) {
            embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
          }
        }
        setUpDefaultPlugins_() {
          embedStyle(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
          this.pool_.getAll().forEach((plugin) => {
            this.embedPluginStyle_(plugin);
          });
          this.registerPlugin({
            plugins: [
              SliderBladePlugin,
              ListBladePlugin,
              TabBladePlugin,
              TextBladePlugin
            ]
          });
        }
      }
      const VERSION = new Semver("3.1.0");
      exports2.BladeApi = BladeApi;
      exports2.ButtonApi = ButtonApi;
      exports2.FolderApi = FolderApi;
      exports2.InputBindingApi = InputBindingApi;
      exports2.ListApi = ListApi;
      exports2.MonitorBindingApi = MonitorBindingApi;
      exports2.Pane = Pane2;
      exports2.SeparatorApi = SeparatorApi;
      exports2.SliderApi = SliderApi;
      exports2.TabApi = TabApi;
      exports2.TabPageApi = TabPageApi;
      exports2.TextApi = TextApi;
      exports2.TpChangeEvent = TpChangeEvent;
      exports2.VERSION = VERSION;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/stats.js/build/stats.min.js
var require_stats_min = __commonJS({
  "node_modules/stats.js/build/stats.min.js"(exports, module) {
    (function(f4, e5) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = e5() : typeof define === "function" && define.amd ? define(e5) : f4.Stats = e5();
    })(exports, function() {
      var f4 = function() {
        function e5(a6) {
          c5.appendChild(a6.dom);
          return a6;
        }
        function u5(a6) {
          for (var d4 = 0; d4 < c5.children.length; d4++)
            c5.children[d4].style.display = d4 === a6 ? "block" : "none";
          l5 = a6;
        }
        var l5 = 0, c5 = document.createElement("div");
        c5.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
        c5.addEventListener("click", function(a6) {
          a6.preventDefault();
          u5(++l5 % c5.children.length);
        }, false);
        var k3 = (performance || Date).now(), g3 = k3, a5 = 0, r5 = e5(new f4.Panel("FPS", "#0ff", "#002")), h4 = e5(new f4.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory)
          var t5 = e5(new f4.Panel("MB", "#f08", "#201"));
        u5(0);
        return { REVISION: 16, dom: c5, addPanel: e5, showPanel: u5, begin: function() {
          k3 = (performance || Date).now();
        }, end: function() {
          a5++;
          var c6 = (performance || Date).now();
          h4.update(c6 - k3, 200);
          if (c6 > g3 + 1e3 && (r5.update(1e3 * a5 / (c6 - g3), 100), g3 = c6, a5 = 0, t5)) {
            var d4 = performance.memory;
            t5.update(d4.usedJSHeapSize / 1048576, d4.jsHeapSizeLimit / 1048576);
          }
          return c6;
        }, update: function() {
          k3 = this.end();
        }, domElement: c5, setMode: u5 };
      };
      f4.Panel = function(e5, f5, l5) {
        var c5 = Infinity, k3 = 0, g3 = Math.round, a5 = g3(window.devicePixelRatio || 1), r5 = 80 * a5, h4 = 48 * a5, t5 = 3 * a5, v4 = 2 * a5, d4 = 3 * a5, m4 = 15 * a5, n3 = 74 * a5, p3 = 30 * a5, q2 = document.createElement("canvas");
        q2.width = r5;
        q2.height = h4;
        q2.style.cssText = "width:80px;height:48px";
        var b4 = q2.getContext("2d");
        b4.font = "bold " + 9 * a5 + "px Helvetica,Arial,sans-serif";
        b4.textBaseline = "top";
        b4.fillStyle = l5;
        b4.fillRect(0, 0, r5, h4);
        b4.fillStyle = f5;
        b4.fillText(e5, t5, v4);
        b4.fillRect(d4, m4, n3, p3);
        b4.fillStyle = l5;
        b4.globalAlpha = 0.9;
        b4.fillRect(d4, m4, n3, p3);
        return { dom: q2, update: function(h5, w4) {
          c5 = Math.min(c5, h5);
          k3 = Math.max(k3, h5);
          b4.fillStyle = l5;
          b4.globalAlpha = 1;
          b4.fillRect(0, 0, r5, m4);
          b4.fillStyle = f5;
          b4.fillText(g3(h5) + " " + e5 + " (" + g3(c5) + "-" + g3(k3) + ")", t5, v4);
          b4.drawImage(q2, d4 + a5, m4, n3 - a5, p3, d4, m4, n3 - a5, p3);
          b4.fillRect(d4 + n3 - a5, m4, a5, p3);
          b4.fillStyle = l5;
          b4.globalAlpha = 0.9;
          b4.fillRect(d4 + n3 - a5, m4, a5, g3((1 - h5 / w4) * p3));
        } };
      };
      return f4;
    });
  }
});

// node_modules/ua-parser-js/dist/ua-parser.min.js
var require_ua_parser_min = __commonJS({
  "node_modules/ua-parser-js/dist/ua-parser.min.js"(exports, module) {
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.2", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 255;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i4 in regexes2) {
          if (extensions[i4] && extensions[i4].length % 2 === 0) {
            mergedRegexes[i4] = extensions[i4].concat(regexes2[i4]);
          } else {
            mergedRegexes[i4] = regexes2[i4];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i4 = 0; i4 < arr.length; i4++) {
          enums[arr[i4].toUpperCase()] = arr[i4];
        }
        return enums;
      }, has2 = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i4 = 0, j3, k3, p3, q2, matches, match;
        while (i4 < arrays.length && !matches) {
          var regex = arrays[i4], props = arrays[i4 + 1];
          j3 = k3 = 0;
          while (j3 < regex.length && !matches) {
            matches = regex[j3++].exec(ua);
            if (!!matches) {
              for (p3 = 0; p3 < props.length; p3++) {
                match = matches[++k3];
                q2 = props[p3];
                if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                  if (q2.length === 2) {
                    if (typeof q2[1] == FUNC_TYPE) {
                      this[q2[0]] = q2[1].call(this, match);
                    } else {
                      this[q2[0]] = q2[1];
                    }
                  } else if (q2.length === 3) {
                    if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                      this[q2[0]] = match ? q2[1].call(this, match, q2[2]) : undefined2;
                    } else {
                      this[q2[0]] = match ? match.replace(q2[1], q2[2]) : undefined2;
                    }
                  } else if (q2.length === 4) {
                    this[q2[0]] = match ? q2[3].call(this, match.replace(q2[1], q2[2])) : undefined2;
                  }
                } else {
                  this[q2] = match ? match : undefined2;
                }
              }
            }
          }
          i4 += 2;
        }
      }, strMapper = function(str, map) {
        for (var i4 in map) {
          if (typeof map[i4] === OBJ_TYPE && map[i4].length > 0) {
            for (var j3 = 0; j3 < map[i4].length; j3++) {
              if (has2(map[i4][j3], str)) {
                return i4 === UNKNOWN ? undefined2 : i4;
              }
            }
          } else if (has2(map[i4], str)) {
            return i4 === UNKNOWN ? undefined2 : i4;
          }
        }
        return str;
      };
      var oldSafariMap = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, windowsVersionMap = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" };
      var regexes = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [NAME, VERSION], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UC" + BROWSER]], [/\bqbcore\/([\w\.]+)/i], [VERSION, [NAME, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/yabrowser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI " + BROWSER]], [/fxios\/([-\w\.]+)/i], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i], [[NAME, "360 " + BROWSER]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 " + BROWSER], VERSION], [/(comodo_dragon)\/([\w\.]+)/i], [[NAME, /_/g, " "], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [NAME, VERSION], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [VERSION, [NAME, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [NAME, VERSION]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/windows (ce|mobile); ppc;/i], [[ARCHITECTURE, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i], [[ARCHITECTURE, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/\((ip(?:hone|od)[\w ]*);/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [/(pixel c)\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, "Sharp"], [TYPE, MOBILE]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/(shield[\w ]+) b/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i], [MODEL, [VENDOR, "Sharp"], [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/((pebble))app/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(quest( 2)?)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i], [MODEL, [VENDOR, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]], os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[NAME, "Windows"], [VERSION, strMapper, windowsVersionMap]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, "Mac OS"], [VERSION, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [VERSION, NAME], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROME + "cast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[NAME, "Chromium OS"], VERSION], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]] };
      var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined2;
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions).getResult();
        }
        var _ua = ua || (typeof window2 !== UNDEF_TYPE && window2.navigator && window2.navigator.userAgent ? window2.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser.major = majorize(_browser.version);
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          return _os;
        };
        this.getResult = function() {
          return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser;
          });
        } else if (typeof window2 !== UNDEF_TYPE) {
          window2.UAParser = UAParser;
        }
      }
      var $2 = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($2 && !$2.ua) {
        var parser = new UAParser();
        $2.ua = parser.getResult();
        $2.ua.get = function() {
          return parser.getUA();
        };
        $2.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $2.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/react-device-detect/dist/lib.js
var require_lib = __commonJS({
  "node_modules/react-device-detect/dist/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React46 = require_react();
    var React__default = _interopDefault(React46);
    var UAParser = require_ua_parser_min();
    var ClientUAInstance = new UAParser();
    var browser = ClientUAInstance.getBrowser();
    var cpu = ClientUAInstance.getCPU();
    var device = ClientUAInstance.getDevice();
    var engine = ClientUAInstance.getEngine();
    var os = ClientUAInstance.getOS();
    var ua = ClientUAInstance.getUA();
    var setUa = function setUa2(userAgentString) {
      return ClientUAInstance.setUA(userAgentString);
    };
    var parseUserAgent = function parseUserAgent2(userAgent) {
      if (!userAgent) {
        console.error("No userAgent string was provided");
        return;
      }
      var UserAgentInstance = new UAParser(userAgent);
      return {
        UA: UserAgentInstance,
        browser: UserAgentInstance.getBrowser(),
        cpu: UserAgentInstance.getCPU(),
        device: UserAgentInstance.getDevice(),
        engine: UserAgentInstance.getEngine(),
        os: UserAgentInstance.getOS(),
        ua: UserAgentInstance.getUA(),
        setUserAgent: function setUserAgent2(userAgentString) {
          return UserAgentInstance.setUA(userAgentString);
        }
      };
    };
    var UAHelper = Object.freeze({
      ClientUAInstance,
      browser,
      cpu,
      device,
      engine,
      os,
      ua,
      setUa,
      parseUserAgent
    });
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        if (i4 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i4 = 0; i4 < props.length; i4++) {
        var descriptor = props[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i4 = 1; i4 < arguments.length; i4++) {
          var source = arguments[i4];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o4) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o5) {
        return o5.__proto__ || Object.getPrototypeOf(o5);
      };
      return _getPrototypeOf(o4);
    }
    function _setPrototypeOf(o4, p3) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o5, p4) {
        o5.__proto__ = p4;
        return o5;
      };
      return _setPrototypeOf(o4, p3);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i4;
      for (i4 = 0; i4 < sourceKeys.length; i4++) {
        key = sourceKeys[i4];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i4;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
          key = sourceSymbolKeys[i4];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _slicedToArray(arr, i4) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit(arr, i4) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i4 && _arr.length === i4)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray(o4, minLen) {
      if (!o4)
        return;
      if (typeof o4 === "string")
        return _arrayLikeToArray(o4, minLen);
      var n3 = Object.prototype.toString.call(o4).slice(8, -1);
      if (n3 === "Object" && o4.constructor)
        n3 = o4.constructor.name;
      if (n3 === "Map" || n3 === "Set")
        return Array.from(o4);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
        return _arrayLikeToArray(o4, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
        arr2[i4] = arr[i4];
      return arr2;
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var DeviceTypes = {
      Mobile: "mobile",
      Tablet: "tablet",
      SmartTv: "smarttv",
      Console: "console",
      Wearable: "wearable",
      Embedded: "embedded",
      Browser: void 0
    };
    var BrowserTypes = {
      Chrome: "Chrome",
      Firefox: "Firefox",
      Opera: "Opera",
      Yandex: "Yandex",
      Safari: "Safari",
      InternetExplorer: "Internet Explorer",
      Edge: "Edge",
      Chromium: "Chromium",
      Ie: "IE",
      MobileSafari: "Mobile Safari",
      EdgeChromium: "Edge Chromium",
      MIUI: "MIUI Browser",
      SamsungBrowser: "Samsung Browser"
    };
    var OsTypes = {
      IOS: "iOS",
      Android: "Android",
      WindowsPhone: "Windows Phone",
      Windows: "Windows",
      MAC_OS: "Mac OS"
    };
    var InitialDeviceTypes = {
      isMobile: false,
      isTablet: false,
      isBrowser: false,
      isSmartTV: false,
      isConsole: false,
      isWearable: false
    };
    var checkDeviceType = function checkDeviceType2(type2) {
      switch (type2) {
        case DeviceTypes.Mobile:
          return {
            isMobile: true
          };
        case DeviceTypes.Tablet:
          return {
            isTablet: true
          };
        case DeviceTypes.SmartTv:
          return {
            isSmartTV: true
          };
        case DeviceTypes.Console:
          return {
            isConsole: true
          };
        case DeviceTypes.Wearable:
          return {
            isWearable: true
          };
        case DeviceTypes.Browser:
          return {
            isBrowser: true
          };
        case DeviceTypes.Embedded:
          return {
            isEmbedded: true
          };
        default:
          return InitialDeviceTypes;
      }
    };
    var setUserAgent = function setUserAgent2(userAgent) {
      return setUa(userAgent);
    };
    var setDefaults = function setDefaults2(p3) {
      var d4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
      return p3 ? p3 : d4;
    };
    var getNavigatorInstance = function getNavigatorInstance2() {
      if (typeof window !== "undefined") {
        if (window.navigator || navigator) {
          return window.navigator || navigator;
        }
      }
      return false;
    };
    var isIOS13Check = function isIOS13Check2(type2) {
      var nav = getNavigatorInstance();
      return nav && nav.platform && (nav.platform.indexOf(type2) !== -1 || nav.platform === "MacIntel" && nav.maxTouchPoints > 1 && !window.MSStream);
    };
    var browserPayload = function browserPayload2(isBrowser3, browser2, engine2, os2, ua2) {
      return {
        isBrowser: isBrowser3,
        browserMajorVersion: setDefaults(browser2.major),
        browserFullVersion: setDefaults(browser2.version),
        browserName: setDefaults(browser2.name),
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var mobilePayload = function mobilePayload2(type2, device2, os2, ua2) {
      return _objectSpread2({}, type2, {
        vendor: setDefaults(device2.vendor),
        model: setDefaults(device2.model),
        os: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        ua: setDefaults(ua2)
      });
    };
    var smartTvPayload = function smartTvPayload2(isSmartTV2, engine2, os2, ua2) {
      return {
        isSmartTV: isSmartTV2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var consolePayload = function consolePayload2(isConsole2, engine2, os2, ua2) {
      return {
        isConsole: isConsole2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var wearablePayload = function wearablePayload2(isWearable2, engine2, os2, ua2) {
      return {
        isWearable: isWearable2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var embeddedPayload = function embeddedPayload2(isEmbedded2, device2, engine2, os2, ua2) {
      return {
        isEmbedded: isEmbedded2,
        vendor: setDefaults(device2.vendor),
        model: setDefaults(device2.model),
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    function deviceDetect(userAgent) {
      var _ref = userAgent ? parseUserAgent(userAgent) : UAHelper, device2 = _ref.device, browser2 = _ref.browser, engine2 = _ref.engine, os2 = _ref.os, ua2 = _ref.ua;
      var type2 = checkDeviceType(device2.type);
      var isBrowser3 = type2.isBrowser, isMobile3 = type2.isMobile, isTablet2 = type2.isTablet, isSmartTV2 = type2.isSmartTV, isConsole2 = type2.isConsole, isWearable2 = type2.isWearable, isEmbedded2 = type2.isEmbedded;
      if (isBrowser3) {
        return browserPayload(isBrowser3, browser2, engine2, os2, ua2);
      }
      if (isSmartTV2) {
        return smartTvPayload(isSmartTV2, engine2, os2, ua2);
      }
      if (isConsole2) {
        return consolePayload(isConsole2, engine2, os2, ua2);
      }
      if (isMobile3) {
        return mobilePayload(type2, device2, os2, ua2);
      }
      if (isTablet2) {
        return mobilePayload(type2, device2, os2, ua2);
      }
      if (isWearable2) {
        return wearablePayload(isWearable2, engine2, os2, ua2);
      }
      if (isEmbedded2) {
        return embeddedPayload(isEmbedded2, device2, engine2, os2, ua2);
      }
    }
    var isMobileType = function isMobileType2(_ref) {
      var type2 = _ref.type;
      return type2 === DeviceTypes.Mobile;
    };
    var isTabletType = function isTabletType2(_ref2) {
      var type2 = _ref2.type;
      return type2 === DeviceTypes.Tablet;
    };
    var isMobileAndTabletType = function isMobileAndTabletType2(_ref3) {
      var type2 = _ref3.type;
      return type2 === DeviceTypes.Mobile || type2 === DeviceTypes.Tablet;
    };
    var isSmartTVType = function isSmartTVType2(_ref4) {
      var type2 = _ref4.type;
      return type2 === DeviceTypes.SmartTv;
    };
    var isBrowserType = function isBrowserType2(_ref5) {
      var type2 = _ref5.type;
      return type2 === DeviceTypes.Browser;
    };
    var isWearableType = function isWearableType2(_ref6) {
      var type2 = _ref6.type;
      return type2 === DeviceTypes.Wearable;
    };
    var isConsoleType = function isConsoleType2(_ref7) {
      var type2 = _ref7.type;
      return type2 === DeviceTypes.Console;
    };
    var isEmbeddedType = function isEmbeddedType2(_ref8) {
      var type2 = _ref8.type;
      return type2 === DeviceTypes.Embedded;
    };
    var getMobileVendor = function getMobileVendor2(_ref9) {
      var vendor = _ref9.vendor;
      return setDefaults(vendor);
    };
    var getMobileModel = function getMobileModel2(_ref10) {
      var model = _ref10.model;
      return setDefaults(model);
    };
    var getDeviceType = function getDeviceType2(_ref11) {
      var type2 = _ref11.type;
      return setDefaults(type2, "browser");
    };
    var isAndroidType = function isAndroidType2(_ref12) {
      var name = _ref12.name;
      return name === OsTypes.Android;
    };
    var isWindowsType = function isWindowsType2(_ref13) {
      var name = _ref13.name;
      return name === OsTypes.Windows;
    };
    var isMacOsType = function isMacOsType2(_ref14) {
      var name = _ref14.name;
      return name === OsTypes.MAC_OS;
    };
    var isWinPhoneType = function isWinPhoneType2(_ref15) {
      var name = _ref15.name;
      return name === OsTypes.WindowsPhone;
    };
    var isIOSType = function isIOSType2(_ref16) {
      var name = _ref16.name;
      return name === OsTypes.IOS;
    };
    var getOsVersion = function getOsVersion2(_ref17) {
      var version = _ref17.version;
      return setDefaults(version);
    };
    var getOsName = function getOsName2(_ref18) {
      var name = _ref18.name;
      return setDefaults(name);
    };
    var isChromeType = function isChromeType2(_ref19) {
      var name = _ref19.name;
      return name === BrowserTypes.Chrome;
    };
    var isFirefoxType = function isFirefoxType2(_ref20) {
      var name = _ref20.name;
      return name === BrowserTypes.Firefox;
    };
    var isChromiumType = function isChromiumType2(_ref21) {
      var name = _ref21.name;
      return name === BrowserTypes.Chromium;
    };
    var isEdgeType = function isEdgeType2(_ref22) {
      var name = _ref22.name;
      return name === BrowserTypes.Edge;
    };
    var isYandexType = function isYandexType2(_ref23) {
      var name = _ref23.name;
      return name === BrowserTypes.Yandex;
    };
    var isSafariType = function isSafariType2(_ref24) {
      var name = _ref24.name;
      return name === BrowserTypes.Safari || name === BrowserTypes.MobileSafari;
    };
    var isMobileSafariType = function isMobileSafariType2(_ref25) {
      var name = _ref25.name;
      return name === BrowserTypes.MobileSafari;
    };
    var isOperaType = function isOperaType2(_ref26) {
      var name = _ref26.name;
      return name === BrowserTypes.Opera;
    };
    var isIEType = function isIEType2(_ref27) {
      var name = _ref27.name;
      return name === BrowserTypes.InternetExplorer || name === BrowserTypes.Ie;
    };
    var isMIUIType = function isMIUIType2(_ref28) {
      var name = _ref28.name;
      return name === BrowserTypes.MIUI;
    };
    var isSamsungBrowserType = function isSamsungBrowserType2(_ref29) {
      var name = _ref29.name;
      return name === BrowserTypes.SamsungBrowser;
    };
    var getBrowserFullVersion = function getBrowserFullVersion2(_ref30) {
      var version = _ref30.version;
      return setDefaults(version);
    };
    var getBrowserVersion = function getBrowserVersion2(_ref31) {
      var major = _ref31.major;
      return setDefaults(major);
    };
    var getBrowserName = function getBrowserName2(_ref32) {
      var name = _ref32.name;
      return setDefaults(name);
    };
    var getEngineName = function getEngineName2(_ref33) {
      var name = _ref33.name;
      return setDefaults(name);
    };
    var getEngineVersion = function getEngineVersion2(_ref34) {
      var version = _ref34.version;
      return setDefaults(version);
    };
    var isElectronType = function isElectronType2() {
      var nav = getNavigatorInstance();
      var ua2 = nav && nav.userAgent && nav.userAgent.toLowerCase();
      return typeof ua2 === "string" ? /electron/.test(ua2) : false;
    };
    var isEdgeChromiumType = function isEdgeChromiumType2(ua2) {
      return typeof ua2 === "string" && ua2.indexOf("Edg/") !== -1;
    };
    var getIOS13 = function getIOS132() {
      var nav = getNavigatorInstance();
      return nav && (/iPad|iPhone|iPod/.test(nav.platform) || nav.platform === "MacIntel" && nav.maxTouchPoints > 1) && !window.MSStream;
    };
    var getIPad13 = function getIPad132() {
      return isIOS13Check("iPad");
    };
    var getIphone13 = function getIphone132() {
      return isIOS13Check("iPhone");
    };
    var getIPod13 = function getIPod132() {
      return isIOS13Check("iPod");
    };
    var getUseragent = function getUseragent2(userAg) {
      return setDefaults(userAg);
    };
    function buildSelectorsObject(options) {
      var _ref = options ? options : UAHelper, device2 = _ref.device, browser2 = _ref.browser, os2 = _ref.os, engine2 = _ref.engine, ua2 = _ref.ua;
      return {
        isSmartTV: isSmartTVType(device2),
        isConsole: isConsoleType(device2),
        isWearable: isWearableType(device2),
        isEmbedded: isEmbeddedType(device2),
        isMobileSafari: isMobileSafariType(browser2) || getIPad13(),
        isChromium: isChromiumType(browser2),
        isMobile: isMobileAndTabletType(device2) || getIPad13(),
        isMobileOnly: isMobileType(device2),
        isTablet: isTabletType(device2) || getIPad13(),
        isBrowser: isBrowserType(device2),
        isDesktop: isBrowserType(device2),
        isAndroid: isAndroidType(os2),
        isWinPhone: isWinPhoneType(os2),
        isIOS: isIOSType(os2) || getIPad13(),
        isChrome: isChromeType(browser2),
        isFirefox: isFirefoxType(browser2),
        isSafari: isSafariType(browser2),
        isOpera: isOperaType(browser2),
        isIE: isIEType(browser2),
        osVersion: getOsVersion(os2),
        osName: getOsName(os2),
        fullBrowserVersion: getBrowserFullVersion(browser2),
        browserVersion: getBrowserVersion(browser2),
        browserName: getBrowserName(browser2),
        mobileVendor: getMobileVendor(device2),
        mobileModel: getMobileModel(device2),
        engineName: getEngineName(engine2),
        engineVersion: getEngineVersion(engine2),
        getUA: getUseragent(ua2),
        isEdge: isEdgeType(browser2) || isEdgeChromiumType(ua2),
        isYandex: isYandexType(browser2),
        deviceType: getDeviceType(device2),
        isIOS13: getIOS13(),
        isIPad13: getIPad13(),
        isIPhone13: getIphone13(),
        isIPod13: getIPod13(),
        isElectron: isElectronType(),
        isEdgeChromium: isEdgeChromiumType(ua2),
        isLegacyEdge: isEdgeType(browser2) && !isEdgeChromiumType(ua2),
        isWindows: isWindowsType(os2),
        isMacOs: isMacOsType(os2),
        isMIUI: isMIUIType(browser2),
        isSamsungBrowser: isSamsungBrowserType(browser2)
      };
    }
    var isSmartTV = isSmartTVType(device);
    var isConsole = isConsoleType(device);
    var isWearable = isWearableType(device);
    var isEmbedded = isEmbeddedType(device);
    var isMobileSafari = isMobileSafariType(browser) || getIPad13();
    var isChromium = isChromiumType(browser);
    var isMobile2 = isMobileAndTabletType(device) || getIPad13();
    var isMobileOnly = isMobileType(device);
    var isTablet = isTabletType(device) || getIPad13();
    var isBrowser2 = isBrowserType(device);
    var isDesktop = isBrowserType(device);
    var isAndroid = isAndroidType(os);
    var isWinPhone = isWinPhoneType(os);
    var isIOS = isIOSType(os) || getIPad13();
    var isChrome = isChromeType(browser);
    var isFirefox = isFirefoxType(browser);
    var isSafari = isSafariType(browser);
    var isOpera = isOperaType(browser);
    var isIE = isIEType(browser);
    var osVersion = getOsVersion(os);
    var osName = getOsName(os);
    var fullBrowserVersion = getBrowserFullVersion(browser);
    var browserVersion = getBrowserVersion(browser);
    var browserName = getBrowserName(browser);
    var mobileVendor = getMobileVendor(device);
    var mobileModel = getMobileModel(device);
    var engineName = getEngineName(engine);
    var engineVersion = getEngineVersion(engine);
    var getUA = getUseragent(ua);
    var isEdge = isEdgeType(browser) || isEdgeChromiumType(ua);
    var isYandex = isYandexType(browser);
    var deviceType = getDeviceType(device);
    var isIOS13 = getIOS13();
    var isIPad13 = getIPad13();
    var isIPhone13 = getIphone13();
    var isIPod13 = getIPod13();
    var isElectron = isElectronType();
    var isEdgeChromium = isEdgeChromiumType(ua);
    var isLegacyEdge = isEdgeType(browser) && !isEdgeChromiumType(ua);
    var isWindows = isWindowsType(os);
    var isMacOs = isMacOsType(os);
    var isMIUI = isMIUIType(browser);
    var isSamsungBrowser = isSamsungBrowserType(browser);
    var getSelectorsByUserAgent = function getSelectorsByUserAgent2(userAgent) {
      if (!userAgent || typeof userAgent !== "string") {
        console.error("No valid user agent string was provided");
        return;
      }
      var _UAHelper$parseUserAg = parseUserAgent(userAgent), device2 = _UAHelper$parseUserAg.device, browser2 = _UAHelper$parseUserAg.browser, os2 = _UAHelper$parseUserAg.os, engine2 = _UAHelper$parseUserAg.engine, ua2 = _UAHelper$parseUserAg.ua;
      return buildSelectorsObject({
        device: device2,
        browser: browser2,
        os: os2,
        engine: engine2,
        ua: ua2
      });
    };
    var AndroidView = function AndroidView2(_ref) {
      var renderWithFragment = _ref.renderWithFragment, children2 = _ref.children, props = _objectWithoutProperties(_ref, ["renderWithFragment", "children"]);
      return isAndroid ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var BrowserView = function BrowserView2(_ref2) {
      var renderWithFragment = _ref2.renderWithFragment, children2 = _ref2.children, props = _objectWithoutProperties(_ref2, ["renderWithFragment", "children"]);
      return isBrowser2 ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var IEView = function IEView2(_ref3) {
      var renderWithFragment = _ref3.renderWithFragment, children2 = _ref3.children, props = _objectWithoutProperties(_ref3, ["renderWithFragment", "children"]);
      return isIE ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var IOSView = function IOSView2(_ref4) {
      var renderWithFragment = _ref4.renderWithFragment, children2 = _ref4.children, props = _objectWithoutProperties(_ref4, ["renderWithFragment", "children"]);
      return isIOS ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var MobileView = function MobileView2(_ref5) {
      var renderWithFragment = _ref5.renderWithFragment, children2 = _ref5.children, props = _objectWithoutProperties(_ref5, ["renderWithFragment", "children"]);
      return isMobile2 ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var TabletView = function TabletView2(_ref6) {
      var renderWithFragment = _ref6.renderWithFragment, children2 = _ref6.children, props = _objectWithoutProperties(_ref6, ["renderWithFragment", "children"]);
      return isTablet ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var WinPhoneView = function WinPhoneView2(_ref7) {
      var renderWithFragment = _ref7.renderWithFragment, children2 = _ref7.children, props = _objectWithoutProperties(_ref7, ["renderWithFragment", "children"]);
      return isWinPhone ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var MobileOnlyView = function MobileOnlyView2(_ref8) {
      var renderWithFragment = _ref8.renderWithFragment, children2 = _ref8.children, viewClassName = _ref8.viewClassName, style3 = _ref8.style, props = _objectWithoutProperties(_ref8, ["renderWithFragment", "children", "viewClassName", "style"]);
      return isMobileOnly ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var SmartTVView = function SmartTVView2(_ref9) {
      var renderWithFragment = _ref9.renderWithFragment, children2 = _ref9.children, props = _objectWithoutProperties(_ref9, ["renderWithFragment", "children"]);
      return isSmartTV ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var ConsoleView = function ConsoleView2(_ref10) {
      var renderWithFragment = _ref10.renderWithFragment, children2 = _ref10.children, props = _objectWithoutProperties(_ref10, ["renderWithFragment", "children"]);
      return isConsole ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var WearableView = function WearableView2(_ref11) {
      var renderWithFragment = _ref11.renderWithFragment, children2 = _ref11.children, props = _objectWithoutProperties(_ref11, ["renderWithFragment", "children"]);
      return isWearable ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    var CustomView = function CustomView2(_ref12) {
      var renderWithFragment = _ref12.renderWithFragment, children2 = _ref12.children, viewClassName = _ref12.viewClassName, style3 = _ref12.style, condition = _ref12.condition, props = _objectWithoutProperties(_ref12, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
      return condition ? renderWithFragment ? React__default.createElement(React46.Fragment, null, children2) : React__default.createElement("div", props, children2) : null;
    };
    function withOrientationChange(WrappedComponent) {
      return function(_React$Component) {
        _inherits(_class, _React$Component);
        function _class(props) {
          var _this;
          _classCallCheck(this, _class);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
          _this.isEventListenerAdded = false;
          _this.handleOrientationChange = _this.handleOrientationChange.bind(_assertThisInitialized(_this));
          _this.onOrientationChange = _this.onOrientationChange.bind(_assertThisInitialized(_this));
          _this.onPageLoad = _this.onPageLoad.bind(_assertThisInitialized(_this));
          _this.state = {
            isLandscape: false,
            isPortrait: false
          };
          return _this;
        }
        _createClass(_class, [{
          key: "handleOrientationChange",
          value: function handleOrientationChange() {
            if (!this.isEventListenerAdded) {
              this.isEventListenerAdded = true;
            }
            var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
            this.setState({
              isPortrait: orientation === 0,
              isLandscape: orientation === 90
            });
          }
        }, {
          key: "onOrientationChange",
          value: function onOrientationChange() {
            this.handleOrientationChange();
          }
        }, {
          key: "onPageLoad",
          value: function onPageLoad() {
            this.handleOrientationChange();
          }
        }, {
          key: "componentDidMount",
          value: function componentDidMount() {
            if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== void 0 && isMobile2) {
              if (!this.isEventListenerAdded) {
                this.handleOrientationChange();
                window.addEventListener("load", this.onPageLoad, false);
              } else {
                window.removeEventListener("load", this.onPageLoad, false);
              }
              window.addEventListener("resize", this.onOrientationChange, false);
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            window.removeEventListener("resize", this.onOrientationChange, false);
          }
        }, {
          key: "render",
          value: function render() {
            return React__default.createElement(WrappedComponent, _extends({}, this.props, {
              isLandscape: this.state.isLandscape,
              isPortrait: this.state.isPortrait
            }));
          }
        }]);
        return _class;
      }(React__default.Component);
    }
    function useMobileOrientation() {
      var _useState = React46.useState(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        return {
          isPortrait: orientation === 0,
          isLandscape: orientation === 90,
          orientation: orientation === 0 ? "portrait" : "landscape"
        };
      }), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
      var handleOrientationChange = React46.useCallback(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        var next = {
          isPortrait: orientation === 0,
          isLandscape: orientation === 90,
          orientation: orientation === 0 ? "portrait" : "landscape"
        };
        state.orientation !== next.orientation && setState(next);
      }, [state.orientation]);
      React46.useEffect(function() {
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== void 0 && isMobile2) {
          handleOrientationChange();
          window.addEventListener("load", handleOrientationChange, false);
          window.addEventListener("resize", handleOrientationChange, false);
        }
        return function() {
          window.removeEventListener("resize", handleOrientationChange, false);
          window.removeEventListener("load", handleOrientationChange, false);
        };
      }, [handleOrientationChange]);
      return state;
    }
    function useDeviceData(userAgent) {
      var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
      return parseUserAgent(hookUserAgent);
    }
    function useDeviceSelectors(userAgent) {
      var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
      var deviceData = useDeviceData(hookUserAgent);
      var selectors = buildSelectorsObject(deviceData);
      return [selectors, deviceData];
    }
    exports.AndroidView = AndroidView;
    exports.BrowserTypes = BrowserTypes;
    exports.BrowserView = BrowserView;
    exports.ConsoleView = ConsoleView;
    exports.CustomView = CustomView;
    exports.IEView = IEView;
    exports.IOSView = IOSView;
    exports.MobileOnlyView = MobileOnlyView;
    exports.MobileView = MobileView;
    exports.OsTypes = OsTypes;
    exports.SmartTVView = SmartTVView;
    exports.TabletView = TabletView;
    exports.WearableView = WearableView;
    exports.WinPhoneView = WinPhoneView;
    exports.browserName = browserName;
    exports.browserVersion = browserVersion;
    exports.deviceDetect = deviceDetect;
    exports.deviceType = deviceType;
    exports.engineName = engineName;
    exports.engineVersion = engineVersion;
    exports.fullBrowserVersion = fullBrowserVersion;
    exports.getSelectorsByUserAgent = getSelectorsByUserAgent;
    exports.getUA = getUA;
    exports.isAndroid = isAndroid;
    exports.isBrowser = isBrowser2;
    exports.isChrome = isChrome;
    exports.isChromium = isChromium;
    exports.isConsole = isConsole;
    exports.isDesktop = isDesktop;
    exports.isEdge = isEdge;
    exports.isEdgeChromium = isEdgeChromium;
    exports.isElectron = isElectron;
    exports.isEmbedded = isEmbedded;
    exports.isFirefox = isFirefox;
    exports.isIE = isIE;
    exports.isIOS = isIOS;
    exports.isIOS13 = isIOS13;
    exports.isIPad13 = isIPad13;
    exports.isIPhone13 = isIPhone13;
    exports.isIPod13 = isIPod13;
    exports.isLegacyEdge = isLegacyEdge;
    exports.isMIUI = isMIUI;
    exports.isMacOs = isMacOs;
    exports.isMobile = isMobile2;
    exports.isMobileOnly = isMobileOnly;
    exports.isMobileSafari = isMobileSafari;
    exports.isOpera = isOpera;
    exports.isSafari = isSafari;
    exports.isSamsungBrowser = isSamsungBrowser;
    exports.isSmartTV = isSmartTV;
    exports.isTablet = isTablet;
    exports.isWearable = isWearable;
    exports.isWinPhone = isWinPhone;
    exports.isWindows = isWindows;
    exports.isYandex = isYandex;
    exports.mobileModel = mobileModel;
    exports.mobileVendor = mobileVendor;
    exports.osName = osName;
    exports.osVersion = osVersion;
    exports.parseUserAgent = parseUserAgent;
    exports.setUserAgent = setUserAgent;
    exports.useDeviceData = useDeviceData;
    exports.useDeviceSelectors = useDeviceSelectors;
    exports.useMobileOrientation = useMobileOrientation;
    exports.withOrientationChange = withOrientationChange;
  }
});

// node_modules/lingo3d/lib/engine/boxHelper.js
var boxHelper_default = {};
createEffect(() => {
  var _a2;
  const target = getSelectionTarget();
  if (!target || getCameraRendered() !== mainCamera_default)
    return;
  const boxHelper = new BoxHelper((_a2 = target.object3d) != null ? _a2 : target.outerObject3d);
  const frame2 = requestAnimationFrame(() => scene_default.add(boxHelper));
  const handle = onBeforeRender(() => boxHelper.update());
  return () => {
    cancelAnimationFrame(frame2);
    scene_default.remove(boxHelper);
    handle.cancel();
  };
}, [getSelectionTarget, getCameraRendered]);
createEffect(() => {
  const targets = getMultipleSelectionTargets();
  if (!targets.length || getCameraRendered() !== mainCamera_default)
    return;
  const boxHelpers = [];
  for (const target of targets) {
    const boxHelper = new BoxHelper(target.outerObject3d);
    scene_default.add(boxHelper);
    boxHelpers.push(boxHelper);
  }
  const handle = onBeforeRender(() => {
    for (const boxHelper of boxHelpers)
      boxHelper.update();
  });
  return () => {
    for (const boxHelper of boxHelpers)
      scene_default.remove(boxHelper);
    handle.cancel();
  };
}, [getMultipleSelectionTargets, getCameraRendered]);

// node_modules/lingo3d/lib/display/primitives/Cube.js
var boxGeometry = new BoxGeometry(diameterScaled, diameterScaled, diameterScaled, 1, 1, 1);
var Cube = class extends Primitive_default {
  constructor() {
    super(boxGeometry);
  }
};
__publicField(Cube, "componentName", "cube");

// node_modules/lingo3d/lib/display/core/utils/Reresolvable.js
var cleanupMap = /* @__PURE__ */ new WeakMap();
var runCleanup = (cb2) => {
  if (cleanupMap.has(cb2)) {
    cleanupMap.get(cb2)();
    cleanupMap.delete(cb2);
  }
};
var run = (cb2, val) => {
  runCleanup(cb2);
  const cleanup = cb2(val);
  cleanup && cleanupMap.set(cb2, cleanup);
};
var Reresolvable = class {
  constructor() {
    __publicField(this, "done");
    __publicField(this, "value");
    __publicField(this, "callbacks", []);
  }
  then(cb2) {
    this.callbacks.push(cb2);
    this.done && run(cb2, this.value);
    return new Cancellable(() => {
      pull(this.callbacks, cb2);
      runCleanup(cb2);
    });
  }
  resolve(val) {
    this.done = true;
    this.value = val;
    for (const cb2 of this.callbacks)
      run(cb2, val);
  }
};

// node_modules/lingo3d/lib/display/core/Loaded.js
var Loaded = class extends ObjectManager {
  constructor() {
    super(new Mesh(boxGeometry, wireframeMaterial));
    __publicField(this, "loadedGroup", new Group());
    __publicField(this, "loaded", new Reresolvable());
    __publicField(this, "_src");
    __publicField(this, "srcCount", 0);
    __publicField(this, "_onLoad");
    __publicField(this, "widthSet");
    __publicField(this, "heightSet");
    __publicField(this, "depthSet");
    __publicField(this, "_boxVisible");
    __publicField(this, "_outline");
    __publicField(this, "_bloom");
    __publicField(this, "_reflection");
    __publicField(this, "managerSet");
    this.outerObject3d.add(this.loadedGroup);
  }
  get src() {
    return this._src;
  }
  set src(val) {
    if (this._src === val)
      return;
    this._src = val;
    const srcCount = ++this.srcCount;
    this.loaded.done && this.loadedGroup.clear();
    if (!val)
      return;
    this.load(val).then((loaded) => {
      if (srcCount !== this.srcCount || this.done)
        return;
      const loadedObject3d = this.resolveLoaded(loaded);
      this.loadedGroup.add(loadedObject3d);
      this.loaded.resolve(loadedObject3d);
      this.object3d.visible = !!this._boxVisible;
    });
  }
  get onLoad() {
    return this._onLoad;
  }
  set onLoad(cb2) {
    this._onLoad = cb2;
    this.cancelHandle("onLoad", cb2 && (() => this.loaded.then(cb2)));
  }
  get width() {
    return super.width;
  }
  set width(val) {
    super.width = val;
    this.widthSet = true;
  }
  get height() {
    return super.height;
  }
  set height(val) {
    super.height = val;
    this.heightSet = true;
  }
  get depth() {
    return super.depth;
  }
  set depth(val) {
    super.depth = val;
    this.depthSet = true;
  }
  get innerRotationX() {
    return super.innerRotationX;
  }
  set innerRotationX(val) {
    super.innerRotationX = val;
    this.loadedGroup.rotation.x = this.object3d.rotation.x;
  }
  get innerRotationY() {
    return super.innerRotationY;
  }
  set innerRotationY(val) {
    super.innerRotationY = val;
    this.loadedGroup.rotation.y = this.object3d.rotation.y;
  }
  get innerRotationZ() {
    return super.innerRotationZ;
  }
  set innerRotationZ(val) {
    super.innerRotationZ = val;
    this.loadedGroup.rotation.z = this.object3d.rotation.z;
  }
  get innerX() {
    return super.innerX;
  }
  set innerX(val) {
    super.innerX = val;
    this.loadedGroup.position.x = this.object3d.position.x;
  }
  get innerY() {
    return super.innerY;
  }
  set innerY(val) {
    super.innerY = val;
    this.loadedGroup.position.y = this.object3d.position.y;
  }
  get innerZ() {
    return super.innerZ;
  }
  set innerZ(val) {
    super.innerZ = val;
    this.loadedGroup.position.z = this.object3d.position.z;
  }
  get innerVisible() {
    return this.loadedGroup.visible;
  }
  set innerVisible(val) {
    this.loadedGroup.visible = val;
  }
  get frustumCulled() {
    return this.outerObject3d.frustumCulled;
  }
  set frustumCulled(val) {
    if (this.outerObject3d.frustumCulled === val)
      return;
    this.outerObject3d.frustumCulled = val;
    this.cancelHandle("frustumCulled", () => this.loaded.then(() => {
      super.frustumCulled = val;
    }));
  }
  get physics() {
    var _a2;
    return (_a2 = this._physics) != null ? _a2 : false;
  }
  set physics(val) {
    if (this._physics === val)
      return;
    this._physics = val;
    const handle = this.cancelHandle("physics", () => this.loaded.then(() => {
      this.initPhysics(val, handle);
    }));
  }
  get boxVisible() {
    var _a2;
    return (_a2 = this._boxVisible) != null ? _a2 : this.object3d.visible;
  }
  set boxVisible(val) {
    this._boxVisible = val;
    this.object3d.visible = val;
  }
  get outline() {
    return !!this._outline;
  }
  set outline(val) {
    if (this._outline === val)
      return;
    this._outline = val;
    this.cancelHandle("outline", () => this.loaded.then((loaded) => {
      if (!val)
        return;
      addOutline(loaded);
      return () => {
        deleteOutline(loaded);
      };
    }));
  }
  get bloom() {
    return !!this._bloom;
  }
  set bloom(val) {
    if (this._bloom === val)
      return;
    this._bloom = val;
    this.cancelHandle("bloom", () => this.loaded.then((loaded) => {
      if (!val)
        return;
      addBloom(loaded);
      return () => {
        deleteBloom(loaded);
      };
    }));
  }
  get reflection() {
    return !!this._reflection;
  }
  set reflection(val) {
    if (this._reflection === val)
      return;
    this._reflection = val;
    this.cancelHandle("reflection", () => this.loaded.then((loaded) => {
      if (!val)
        return;
      addSSR(loaded);
      return () => {
        deleteSSR(loaded);
      };
    }));
  }
  addToRaycastSet(set) {
    const handle = new Cancellable();
    queueMicrotask(() => {
      if (handle.done)
        return;
      if (this._physics === "map" || this._physics === "map-debug")
        handle.watch(this.loaded.then((loaded) => {
          if (!this.managerSet) {
            this.managerSet = true;
            loaded.traverse((child) => {
              var _a2, _b;
              return (_b = (_a2 = child.userData).manager) != null ? _b : _a2.manager = this;
            });
          }
          set.add(loaded);
          return () => {
            set.delete(loaded);
          };
        }));
      else
        handle.watch(super.addToRaycastSet(set));
    });
    return handle;
  }
  refreshFactors() {
    this.cancelHandle("refreshFactors", () => this.loaded.then(() => super.refreshFactors()));
  }
};

// node_modules/lingo3d/lib/engine/skeletonHelper.js
var skeletonHelper_default = {};
createEffect(() => {
  const target = getSelectionTarget();
  if (!(target instanceof Loaded) || getCameraRendered() !== mainCamera_default)
    return;
  const skinnedMesh = target.loadedGroup.children[0];
  if (!skinnedMeshSet.has(skinnedMesh))
    return;
  const helper = new SkeletonHelper(skinnedMesh);
  scene_default.add(helper);
  return () => {
    scene_default.remove(helper);
  };
}, [getSelectionTarget, getCameraRendered]);

// node_modules/lingo3d/lib/states/useOrbitControls.js
var [setOrbitControls, getOrbitControls] = store(false);

// node_modules/lingo3d/lib/states/useBokehRefresh.js
var [setBokehRefresh, getBokehRefresh] = store({});

// node_modules/lingo3d/lib/states/useBokeh.js
var bokehDefault = false;
var [setBokeh, getBokeh] = store(bokehDefault);
createEffect(() => {
  var _a2;
  setBokeh((_a2 = getCameraRendered().userData.bokeh) != null ? _a2 : bokehDefault);
}, [getCameraRendered, getBokehRefresh]);

// node_modules/lingo3d/lib/states/useBokehAperture.js
var bokehApertureDefault = 0.03;
var [setBokehAperture, getBokehAperture] = store(bokehApertureDefault);
createEffect(() => {
  var _a2;
  setBokehAperture((_a2 = getCameraRendered().userData.bokehAperture) != null ? _a2 : bokehApertureDefault);
}, [getCameraRendered, getBokehRefresh]);

// node_modules/lingo3d/lib/states/useBokehFocus.js
var bokehFocusDefault = 1;
var [setBokehFocus, getBokehFocus] = store(bokehFocusDefault);
createEffect(() => {
  var _a2;
  setBokehFocus((_a2 = getCameraRendered().userData.bokehFocus) != null ? _a2 : bokehFocusDefault);
}, [getCameraRendered, getBokehRefresh]);

// node_modules/lingo3d/lib/states/useBokehMaxBlur.js
var bokehMaxBlurDefault = 0.01;
var [setBokehMaxBlur, getBokehMaxBlur] = store(bokehMaxBlurDefault);
createEffect(() => {
  var _a2;
  setBokehMaxBlur((_a2 = getCameraRendered().userData.bokehMaxBlur) != null ? _a2 : bokehMaxBlurDefault);
}, [getCameraRendered, getBokehRefresh]);

// node_modules/lingo3d/lib/interface/ICameraBase.js
var cameraBaseSchema = {
  ...objectManagerSchema,
  mouseControl: [Boolean, String],
  fov: Number,
  zoom: Number,
  near: Number,
  far: Number,
  active: Boolean,
  transition: [Boolean, Number],
  bokeh: Boolean,
  bokehFocus: Number,
  bokehMaxBlur: Number,
  bokehAperture: Number,
  minPolarAngle: Number,
  maxPolarAngle: Number,
  minAzimuthAngle: Number,
  maxAzimuthAngle: Number,
  enableDamping: Boolean
};
var cameraBaseDefaults = {
  ...objectManagerDefaults,
  mouseControl: false,
  fov: 75,
  zoom: 1,
  near: camNear,
  far: camFar,
  active: false,
  transition: [void 0, false],
  bokeh: bokehDefault,
  bokehFocus: bokehFocusDefault,
  bokehMaxBlur: bokehMaxBlurDefault,
  bokehAperture: bokehApertureDefault,
  minPolarAngle: MIN_POLAR_ANGLE,
  maxPolarAngle: MAX_POLAR_ANGLE,
  minAzimuthAngle: [-Infinity, -999999999],
  maxAzimuthAngle: [Infinity, 999999999],
  enableDamping: false
};

// node_modules/lingo3d/lib/interface/IOrbitCamera.js
var orbitCameraSchema = {
  ...cameraBaseSchema,
  targetId: String,
  enableZoom: Boolean,
  autoRotate: [Boolean, Number]
};
var orbitCameraDefaults = {
  ...cameraBaseDefaults,
  innerZ: 500,
  mouseControl: "drag",
  targetId: void 0,
  enableZoom: false,
  autoRotate: false
};

// node_modules/lingo3d/lib/events/onKeyClear.js
var [emitKeyClear, onKeyClear] = event_default();
window.addEventListener("blur", () => emitKeyClear());
window.addEventListener("focus", () => emitKeyClear());
document.addEventListener("visibilitychange", () => emitKeyClear());
var isPressed = /* @__PURE__ */ new Set();
onKeyClear(() => isPressed.clear());
var queueMouseDownClear = false;
document.addEventListener("keydown", (e5) => {
  if (e5.key === "Shift" || e5.key === "Meta")
    isPressed.add(e5.key);
  if (isPressed.has("Meta") && isPressed.has("Shift")) {
    emitKeyClear();
    queueMouseDownClear = true;
  }
});
document.addEventListener("keyup", (e5) => {
  if (e5.key === "Shift" || e5.key === "Meta")
    isPressed.delete(e5.key);
});
document.addEventListener("mousedown", () => {
  if (queueMouseDownClear) {
    queueMouseDownClear = false;
    emitKeyClear();
  }
});

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/pillShape.js
async function pillShape_default() {
  const { Sphere: Sphere3, Cylinder: Cylinder3, Vec3 } = await loadCannon_default();
  const { x: x2, y: y4 } = getActualScale_default(this);
  const radius2 = x2 * 0.5;
  const halfHeight = y4 * 0.5;
  const shape0 = new Sphere3(radius2);
  const shape1 = new Sphere3(radius2);
  const shape2 = new Cylinder3(radius2, radius2, Math.abs(y4 - x2));
  this.cannonBody.addShape(shape0, new Vec3(0, -halfHeight + radius2, 0));
  this.cannonBody.addShape(shape1, new Vec3(0, halfHeight - radius2, 0));
  this.cannonBody.addShape(shape2);
}

// node_modules/lingo3d/lib/states/useCameraList.js
var [setCameraList, getCameraList] = store([]);
var pushCameraList = push(setCameraList, getCameraList);
var pullCameraList = pull2(setCameraList, getCameraList);

// node_modules/lingo3d/lib/interface/ISprite.js
var spriteSchema = {
  ...objectManagerSchema,
  ...texturedBasicSchema
};
var spriteDefaults = {
  ...objectManagerDefaults,
  ...texturedBasicDefaults,
  scaleZ: 0,
  depth: 0
};

// node_modules/lingo3d/lib/display/Sprite.js
var Sprite2 = class extends ObjectManager {
  constructor() {
    const material = new SpriteMaterial({ transparent: true });
    super(new Sprite(material));
    __publicField(this, "material");
    this.material = material;
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.material.dispose();
    return this;
  }
  get depth() {
    return 0;
  }
  set depth(_4) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(_4) {
  }
};
__publicField(Sprite2, "componentName", "sprite");
__publicField(Sprite2, "defaults", spriteDefaults);
__publicField(Sprite2, "schema", spriteSchema);
applyMixins(Sprite2, [TexturedBasicMixin]);
var Sprite_default = Sprite2;

// node_modules/lingo3d/lib/display/core/utils/makeCameraSprite.js
var makeCameraSprite_default = () => {
  const sprite = new Sprite_default();
  sprite.texture = `data:image/png;base64,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`;
  appendableRoot.delete(sprite);
  sprite.scale = 0.5;
  return sprite;
};

// node_modules/lingo3d/lib/display/core/CameraBase/index.js
var PI_2 = Math.PI * 0.5;
var CameraBase = class extends ObjectManager {
  constructor(camera) {
    super(new Group());
    __publicField(this, "camera");
    __publicField(this, "_physicsShape", pillShape_default);
    __publicField(this, "orbitMode");
    __publicField(this, "gyrateHandle");
    __publicField(this, "updateAngle", debounce(() => this.gyrate(0, 0), 0, "trailing"));
    __publicField(this, "_minPolarAngle", MIN_POLAR_ANGLE);
    __publicField(this, "_maxPolarAngle", MAX_POLAR_ANGLE);
    __publicField(this, "_minAzimuthAngle", -Infinity);
    __publicField(this, "_maxAzimuthAngle", Infinity);
    __publicField(this, "enableDamping", false);
    __publicField(this, "mouseControlState", new Reactive(false));
    __publicField(this, "mouseControlInit");
    __publicField(this, "_gyroControl");
    this.camera = camera;
    this.object3d.add(camera);
    this.camera.userData.manager = this;
    pushCameraList(this.camera);
    this.createEffect(() => {
      if (getCameraRendered() !== mainCamera_default || getCameraRendered() === this.camera)
        return;
      const helper = new CameraHelper(this.camera);
      scene_default.add(helper);
      const sprite = makeCameraSprite_default();
      helper.add(sprite.outerObject3d);
      const handle = onSelectionTarget(({ target }) => {
        target === sprite && emitSelectionTarget(this);
      });
      return () => {
        helper.dispose();
        scene_default.remove(helper);
        sprite.dispose();
        handle.cancel();
      };
    }, [getCameraRendered]);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    pullCameraStack(this.camera);
    pullCameraList(this.camera);
    return this;
  }
  lookAt(a0, a1, a22) {
    super.lookAt(a0, a1, a22);
    const angle2 = euler.setFromQuaternion(this.outerObject3d.quaternion);
    angle2.x += Math.PI;
    angle2.z += Math.PI;
    this.outerObject3d.setRotationFromEuler(angle2);
  }
  get fov() {
    return this.camera.fov;
  }
  set fov(val) {
    var _a2, _b;
    this.camera.fov = val;
    (_b = (_a2 = this.camera).updateProjectionMatrix) == null ? void 0 : _b.call(_a2);
  }
  get zoom() {
    return this.camera.zoom;
  }
  set zoom(val) {
    var _a2, _b;
    this.camera.zoom = val;
    (_b = (_a2 = this.camera).updateProjectionMatrix) == null ? void 0 : _b.call(_a2);
  }
  get near() {
    return this.camera.near;
  }
  set near(val) {
    var _a2, _b;
    this.camera.near = val;
    (_b = (_a2 = this.camera).updateProjectionMatrix) == null ? void 0 : _b.call(_a2);
  }
  get far() {
    return this.camera.far;
  }
  set far(val) {
    var _a2, _b;
    this.camera.far = val;
    (_b = (_a2 = this.camera).updateProjectionMatrix) == null ? void 0 : _b.call(_a2);
  }
  activate() {
    const cameraFrom = last(getCameraStack());
    if (cameraFrom === this.camera)
      return;
    pullCameraStack(this.camera);
    pushCameraStack(this.camera);
    setCameraFrom(cameraFrom);
  }
  get active() {
    return last(getCameraStack()) === this.camera;
  }
  set active(val) {
    val && this.activate();
  }
  get transition() {
    return this.camera.userData.transition;
  }
  set transition(val) {
    this.camera.userData.transition = val;
  }
  get bokeh() {
    var _a2;
    return (_a2 = this.camera.userData.bokeh) != null ? _a2 : bokehDefault;
  }
  set bokeh(val) {
    this.camera.userData.bokeh = val;
    setBokehRefresh({});
  }
  get bokehFocus() {
    var _a2;
    return (_a2 = this.camera.userData.bokehFocus) != null ? _a2 : bokehFocusDefault;
  }
  set bokehFocus(val) {
    this.camera.userData.bokehFocus = val;
    setBokehRefresh({});
  }
  get bokehMaxBlur() {
    var _a2;
    return (_a2 = this.camera.userData.bokehMaxBlur) != null ? _a2 : bokehMaxBlurDefault;
  }
  set bokehMaxBlur(val) {
    this.camera.userData.bokehMaxBlur = val;
    setBokehRefresh({});
  }
  get bokehAperture() {
    var _a2;
    return (_a2 = this.camera.userData.bokehAperture) != null ? _a2 : bokehApertureDefault;
  }
  set bokehAperture(val) {
    this.camera.userData.bokehAperture = val;
    setBokehRefresh({});
  }
  getRay() {
    return ray.set(getWorldPosition_default(this.camera), this.camera.getWorldDirection(vector3));
  }
  append(object) {
    this._append(object);
    this.camera.add(object.outerObject3d);
  }
  attach(object) {
    this._append(object);
    this.camera.attach(object.outerObject3d);
  }
  get width() {
    return this.object3d.scale.x * scaleUp;
  }
  set width(val) {
    const num = val * scaleDown;
    this.object3d.scale.x = num;
    this.camera.scale.x = 1 / num;
  }
  get height() {
    return this.object3d.scale.y * scaleUp;
  }
  set height(val) {
    const num = val * scaleDown;
    this.object3d.scale.y = num;
    this.camera.scale.y = 1 / num;
  }
  get depth() {
    return this.object3d.scale.z * scaleUp;
  }
  set depth(val) {
    const num = val * scaleDown;
    this.object3d.scale.z = num;
    this.camera.scale.z = 1 / num;
  }
  _gyrate(movementX, movementY, inner) {
    const manager = inner ? this.object3d : this.outerObject3d;
    euler.setFromQuaternion(manager.quaternion);
    euler.y -= movementX * 2e-3;
    euler.y = Math.max(PI_2 - this._maxAzimuthAngle * deg2Rad, Math.min(PI_2 - this._minAzimuthAngle * deg2Rad, euler.y));
    euler.x -= movementY * 2e-3;
    euler.x = Math.max(PI_2 - this._maxPolarAngle * deg2Rad, Math.min(PI_2 - this._minPolarAngle * deg2Rad, euler.x));
    manager.setRotationFromEuler(euler);
    !inner && this.physicsRotate();
  }
  gyrate(movementX, movementY, noDamping) {
    var _a2;
    if (this.enableDamping) {
      movementX *= 0.5;
      movementY *= 0.5;
    }
    if (this.orbitMode)
      this._gyrate(movementX, movementY);
    else {
      this._gyrate(movementX, 0);
      this._gyrate(0, movementY, true);
    }
    if (!this.enableDamping || noDamping || !(movementX || movementY))
      return;
    (_a2 = this.gyrateHandle) == null ? void 0 : _a2.cancel();
    let factor = 1;
    const handle = this.gyrateHandle = this.beforeRender(() => {
      factor *= 0.95;
      this._gyrate(movementX * factor, movementY * factor);
      factor <= 1e-3 && handle.cancel();
    });
  }
  get minPolarAngle() {
    return this._minPolarAngle;
  }
  set minPolarAngle(val) {
    this._minPolarAngle = val;
    this.updateAngle();
  }
  get maxPolarAngle() {
    return this._maxPolarAngle;
  }
  set maxPolarAngle(val) {
    this._maxPolarAngle = val;
    this.updateAngle();
  }
  get minAzimuthAngle() {
    return this._minAzimuthAngle;
  }
  set minAzimuthAngle(val) {
    this._minAzimuthAngle = val;
    this.updateAngle();
  }
  get maxAzimuthAngle() {
    return this._maxAzimuthAngle;
  }
  set maxAzimuthAngle(val) {
    this._maxAzimuthAngle = val;
    this.updateAngle();
  }
  setPolarAngle(angle2) {
    const { _minPolarAngle, _maxPolarAngle } = this;
    this.minPolarAngle = this.maxPolarAngle = angle2;
    this.queueMicrotask(() => {
      this.minPolarAngle = _minPolarAngle;
      this.maxPolarAngle = _maxPolarAngle;
    });
  }
  setAzimuthAngle(angle2) {
    const { _minAzimuthAngle, _maxAzimuthAngle } = this;
    this.minAzimuthAngle = this.maxAzimuthAngle = angle2;
    this.queueMicrotask(() => {
      this.minAzimuthAngle = _minAzimuthAngle;
      this.maxAzimuthAngle = _maxAzimuthAngle;
    });
  }
  get mouseControl() {
    return this.mouseControlState.get();
  }
  set mouseControl(val) {
    this.mouseControlState.set(val);
    if (!val || this.mouseControlInit)
      return;
    this.mouseControlInit = true;
    import("./enableMouseControl-5R4VLCID.js").then((module) => module.default.call(this));
  }
  get gyroControl() {
    return !!this._gyroControl;
  }
  set gyroControl(val) {
    if (this._gyroControl === val)
      return;
    this._gyroControl = val;
    const deviceEuler = euler;
    const deviceQuaternion = quaternion;
    const screenTransform = quaternion_;
    const worldTransform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    const quat = getWorldQuaternion_default(this.object3d);
    const orient = 0;
    const cb2 = (e5) => {
      var _a2, _b, _c;
      this.object3d.quaternion.copy(quat);
      deviceEuler.set(((_a2 = e5.beta) != null ? _a2 : 0) * deg2Rad, ((_b = e5.alpha) != null ? _b : 0) * deg2Rad, -((_c = e5.gamma) != null ? _c : 0) * deg2Rad, "YXZ");
      this.object3d.quaternion.multiply(deviceQuaternion.setFromEuler(deviceEuler));
      const minusHalfAngle = -orient * 0.5;
      screenTransform.set(0, Math.sin(minusHalfAngle), 0, Math.cos(minusHalfAngle));
      this.object3d.quaternion.multiply(screenTransform);
      this.object3d.quaternion.multiply(worldTransform);
    };
    val && window.addEventListener("deviceorientation", cb2);
    this.cancelHandle("gyroControl", val && (() => new Cancellable(() => window.removeEventListener("deviceorientation", cb2))));
  }
};

// node_modules/lingo3d/lib/display/core/OrbitCameraBase.js
var attachSet = /* @__PURE__ */ new WeakSet();
var OrbitCameraBase = class extends CameraBase {
  constructor(camera) {
    super(camera);
    __publicField(this, "manualTarget");
    __publicField(this, "targetState", new Reactive(void 0));
    __publicField(this, "retarget", debounce(() => {
      var _a2;
      let target = this.manualTarget;
      for (const child of (_a2 = this.children) != null ? _a2 : [])
        if (target) {
          if (child.outerObject3d.parent !== this.camera)
            this.camera[attachSet.has(child) ? "attach" : "add"](child.outerObject3d);
        } else if (isMeshItem(child)) {
          target = child;
          const { parent } = this.outerObject3d;
          if (parent && child.outerObject3d.parent !== parent)
            parent[attachSet.has(target) ? "attach" : "add"](target.outerObject3d);
        }
      this.targetState.set(target);
    }, 0, "trailing"));
    this.createEffect(() => {
      const target = this.targetState.get();
      if (!target)
        return;
      const handle = onSceneGraphChange(() => target.parent !== this && this.retarget());
      return () => {
        handle.cancel();
      };
    }, [this.targetState.get]);
  }
  append(object) {
    this._append(object);
    attachSet.delete(object);
    this.retarget();
  }
  attach(object) {
    this._append(object);
    attachSet.add(object);
    this.retarget();
  }
};

// node_modules/lingo3d/lib/display/cameras/OrbitCamera.js
var OrbitCamera = class extends OrbitCameraBase {
  constructor(camera = new PerspectiveCamera(75, 1, camNear, camFar)) {
    super(camera);
    __publicField(this, "targetIdState", new Reactive(void 0));
    __publicField(this, "enableZoomState", new Reactive(false));
    __publicField(this, "enableFlyState", new Reactive(false));
    __publicField(this, "autoRotateState", new Reactive(false));
    this.innerZ = 500;
    this.orbitMode = true;
    this.mouseControl = "drag";
    this.camera.rotation.y = 0;
    this.createEffect(() => {
      const targetId = this.targetIdState.get();
      if (!targetId)
        return;
      const handle = new Cancellable();
      const timeout = setTimeout(() => {
        const find = () => {
          var _a2;
          const [found] = (_a2 = idMap.get(targetId)) != null ? _a2 : [void 0];
          if (found) {
            this.manualTarget = found;
            this.targetState.set(found);
          }
          return found;
        };
        if (find())
          return;
        handle.watch(onSceneGraphChange(() => setTimeout(() => find() && handle.cancel())));
      });
      return () => {
        clearTimeout(timeout);
        handle.cancel();
      };
    }, [this.targetIdState.get]);
    this.createEffect(() => {
      const target = this.targetState.get();
      if (!target)
        return;
      const handle = onBeforeRender(() => {
        this.placeAt(vec2Point(getCenter_default(getObject3d(target))));
      });
      return () => {
        handle.cancel();
      };
    }, [this.targetState.get]);
    this.createEffect(() => {
      const autoRotate = this.autoRotateState.get();
      if (getCameraRendered() !== camera || !autoRotate)
        return;
      const speed = typeof autoRotate === "number" ? autoRotate : 2;
      const handle = onBeforeRender(() => {
        this.gyrate(speed, 0, true);
      });
      return () => {
        handle.cancel();
      };
    }, [getCameraRendered, this.autoRotateState.get]);
    this.createEffect(() => {
      if (getTransformControlsDragging() || getCameraRendered() !== camera || !this.mouseControlState.get())
        return;
      const handle = new Cancellable();
      if (this.enableZoomState.get()) {
        const cb2 = (e5) => {
          e5.preventDefault();
          this.innerZ += e5.deltaY;
          if (this.innerZ < 0)
            this.innerZ = 0;
        };
        container.addEventListener("wheel", cb2);
        handle.then(() => container.removeEventListener("wheel", cb2));
      }
      if (this.enableFlyState.get()) {
        const downSet = /* @__PURE__ */ new Set();
        handle.watch(onBeforeRender(() => {
          if (downSet.has("w"))
            this.translateZ(downSet.has("Shift") ? -50 : -10);
          else if (downSet.has("s"))
            this.translateZ(downSet.has("Shift") ? 50 : 10);
          if (downSet.has("a"))
            this.moveRight(-10);
          else if (downSet.has("d"))
            this.moveRight(10);
          if (downSet.has("w") || downSet.has("s") || downSet.has("a") || downSet.has("d")) {
            const worldPos = vec2Point(getWorldPosition_default(this.object3d));
            this.innerZ = 0;
            this.placeAt(worldPos);
          }
          if (downSet.has("ArrowDown"))
            this.y -= 10;
          else if (downSet.has("ArrowUp"))
            this.y += 10;
        }));
        const handleKeyDown = (e5) => {
          downSet.add(e5.key.length === 1 ? e5.key.toLowerCase() : e5.key);
        };
        const handleKeyUp = (e5) => {
          downSet.delete(e5.key.length === 1 ? e5.key.toLowerCase() : e5.key);
        };
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
        handle.watch(onKeyClear(() => downSet.clear()));
        handle.then(() => {
          document.removeEventListener("keydown", handleKeyDown);
          document.removeEventListener("keyup", handleKeyUp);
        });
      }
      return () => {
        handle.cancel();
      };
    }, [
      getCameraRendered,
      getTransformControlsDragging,
      this.enableZoomState.get,
      this.enableFlyState.get,
      this.mouseControlState.get
    ]);
  }
  get targetId() {
    return this.targetIdState.get();
  }
  set targetId(val) {
    this.targetIdState.set(val);
  }
  get enableZoom() {
    return this.enableZoomState.get();
  }
  set enableZoom(val) {
    this.enableZoomState.set(val);
  }
  get enableFly() {
    return this.enableFlyState.get();
  }
  set enableFly(val) {
    this.enableFlyState.set(val);
  }
  get autoRotate() {
    return this.autoRotateState.get();
  }
  set autoRotate(val) {
    this.autoRotateState.set(val);
  }
};
__publicField(OrbitCamera, "componentName", "orbitCamera");
__publicField(OrbitCamera, "defaults", orbitCameraDefaults);
__publicField(OrbitCamera, "schema", orbitCameraSchema);

// node_modules/lingo3d/lib/events/onEditorCenterView.js
var [emitEditorCenterView, onEditorCenterView] = event_default();

// node_modules/lingo3d/lib/states/useCameraDistance.js
var [setCameraDistance, getCameraDistance] = store(0);

// node_modules/lingo3d/lib/engine/mainOrbitCamera.js
var mainOrbitCamera = new OrbitCamera(mainCamera_default);
var mainOrbitCamera_default = mainOrbitCamera;
mainOrbitCamera.enableZoom = true;
mainOrbitCamera.enableFly = true;
mainOrbitCamera.mouseControl = false;
appendableRoot.delete(mainOrbitCamera);
onEditorCenterView((manager) => {
  const pos = manager.getWorldPosition();
  mainOrbitCamera.x = pos.x;
  mainOrbitCamera.y = pos.y;
  mainOrbitCamera.z = pos.z;
  const size = getActualScale_default(manager);
  mainOrbitCamera.innerZ = Math.max(size.x, size.y, size.z, 1) * scaleUp + 50;
});
getOrbitControls((val) => {
  if (val)
    return;
  mainOrbitCamera.setPolarAngle(90);
  mainOrbitCamera.setAzimuthAngle(90);
});
createEffect(() => {
  if (!getOrbitControls() || getCameraRendered() !== mainCamera_default || getTransformControlsDragging())
    return;
  mainOrbitCamera.mouseControl = "drag";
  container.style.cursor = "grab";
  return () => {
    mainOrbitCamera.mouseControl = false;
    container.style.cursor = "auto";
  };
}, [getOrbitControls, getTransformControlsDragging, getCameraRendered]);
createEffect(() => {
  if (getCameraRendered() !== mainCamera_default || getOrbitControls())
    return;
  const handle = getCameraDistance((cameraDistance) => mainOrbitCamera.innerZ = cameraDistance);
  return () => {
    handle.cancel();
  };
}, [getCameraRendered, getOrbitControls]);

// node_modules/lingo3d/lib/events/onTransformControls.js
var [emitTransformControls, onTransformControls] = event_default();

// node_modules/lingo3d/lib/states/useTransformControlsMode.js
var [setTransformControlsMode, getTransformControlsMode] = store("translate");

// node_modules/lingo3d/lib/states/useTransformControlsSpace.js
var [setTransformControlsSpace, getTransformControlsSpace] = store("world");

// node_modules/lingo3d/lib/states/useTransformControlsSnap.js
var [setTransformControlsSnap, getTransformControlsSnap] = store(null);

// node_modules/lingo3d/lib/engine/transformControls.js
var transformControls_default = {};
var lazyTransformControls = lazy(async () => {
  const { TransformControls } = await import("./TransformControls-2S5XRPFE.js");
  const transformControls = new TransformControls(getCameraRendered(), container);
  getCameraRendered((camera) => transformControls.camera = camera);
  transformControls.enabled = false;
  let dragging = false;
  transformControls.addEventListener("dragging-changed", ({ value }) => {
    dragging = value;
    setTransformControlsDragging(dragging);
    emitTransformControls(dragging ? "start" : "stop");
  });
  transformControls.addEventListener("change", () => dragging && emitTransformControls("move"));
  return transformControls;
});
createEffect(() => {
  const target = getSelectionTarget();
  const mode = getTransformControlsMode();
  const space = getTransformControlsSpace();
  const snap2 = getTransformControlsSnap();
  if (!target || getCameraRendered() !== mainCamera_default)
    return;
  const handle = new Cancellable();
  lazyTransformControls().then((transformControls) => {
    if (mode === "select") {
      transformControls.enabled = false;
      return;
    }
    transformControls.setMode(mode);
    transformControls.setSpace(space);
    transformControls.setScaleSnap(snap2);
    transformControls.setRotationSnap(snap2);
    transformControls.setTranslationSnap(snap2);
    scene_default.add(transformControls);
    transformControls.attach(target.outerObject3d);
    transformControls.enabled = true;
    handle.then(() => {
      scene_default.remove(transformControls);
      transformControls.detach();
      transformControls.enabled = false;
    });
  });
  return () => {
    handle.cancel();
  };
}, [getSelectionTarget, getTransformControlsMode, getTransformControlsSpace, getTransformControlsSnap, getCameraRendered]);

// node_modules/lingo3d/lib/states/useGridHelper.js
var [setGridHelper, getGridHelper] = store(false);

// node_modules/lingo3d/lib/states/useGridHelperSize.js
var [setGridHelperSize, getGridHelperSize] = store(10);

// node_modules/lingo3d/lib/engine/gridHelper.js
var gridHelper_default = {};
createEffect(() => {
  if (!getGridHelper())
    return;
  const size = getGridHelperSize();
  const gridHelper = new GridHelper(size, size);
  scene_default.add(gridHelper);
  return () => {
    scene_default.remove(gridHelper);
  };
}, [getGridHelper, getGridHelperSize]);

// node_modules/lingo3d/lib/states/useViewportSize.js
var [setViewportSize, getViewportSize] = store(void 0);

// node_modules/lingo3d/lib/states/useReferencePlane.js
var [setReferencePlane, getReferencePlane] = store(false);

// node_modules/lingo3d/lib/engine/referencePlane.js
var referencePlane = new Mesh(new PlaneGeometry(diameterScaled, diameterScaled, 4, 4), wireframeMaterial);
var referencePlane_default = referencePlane;
createEffect(() => {
  var _a2;
  if (!getReferencePlane() || getCameraRendered() !== mainCamera_default)
    return;
  scene_default.add(referencePlane);
  const [w4, h4] = (_a2 = getViewportSize()) != null ? _a2 : getResolution();
  referencePlane.scale.x = w4 * scaleDown;
  referencePlane.scale.y = h4 * scaleDown;
  const handle = onBeforeRender(() => {
    referencePlane.quaternion.copy(mainCamera_default.quaternion);
    referencePlane.position.copy(mainCamera_default.position);
    referencePlane.translateZ(-4.9);
  });
  return () => {
    handle.cancel();
    scene_default.remove(referencePlane);
  };
}, [getReferencePlane, getViewportSize, getResolution, getCameraRendered]);

// node_modules/lingo3d/lib/states/useSkyShaderOptions.js
var [setSkyShaderOptions, getSkyShaderOptions] = store({
  turbidity: 10,
  rayleigh: 3,
  mieCoefficient: 5e-3,
  mieDirectionalG: 0.5,
  inclination: 0.49,
  azimuth: 0.25
});

// node_modules/three/examples/jsm/objects/Sky.js
var Sky = class extends Mesh {
  constructor() {
    const shader = Sky.SkyShader;
    const material = new ShaderMaterial({
      name: "SkyShader",
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: UniformsUtils.clone(shader.uniforms),
      side: BackSide,
      depthWrite: false
    });
    super(new BoxGeometry(1, 1, 1), material);
  }
};
Sky.prototype.isSky = true;
Sky.SkyShader = {
  uniforms: {
    "turbidity": { value: 2 },
    "rayleigh": { value: 1 },
    "mieCoefficient": { value: 5e-3 },
    "mieDirectionalG": { value: 0.8 },
    "sunPosition": { value: new Vector3() },
    "up": { value: new Vector3(0, 1, 0) }
  },
  vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
  fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPos );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
};

// node_modules/lingo3d/lib/states/useSkyShader.js
var [setSkyShader, getSkyShader] = store(false);

// node_modules/lingo3d/lib/engine/skyShader.js
var skyShader_default = {};
var lazySky = lazy(() => {
  const sky = new Sky();
  sky.scale.setScalar(45e4);
  getSkyShaderOptions((effectController) => {
    const { uniforms: uniforms4 } = sky.material;
    uniforms4["turbidity"].value = effectController.turbidity;
    uniforms4["rayleigh"].value = effectController.rayleigh;
    uniforms4["mieCoefficient"].value = effectController.mieCoefficient;
    uniforms4["mieDirectionalG"].value = effectController.mieDirectionalG;
    const theta = Math.PI * (effectController.inclination - 0.5);
    const phi = 2 * Math.PI * (effectController.azimuth - 0.5);
    vector3.x = Math.cos(phi);
    vector3.y = Math.sin(phi) * Math.sin(theta);
    vector3.z = Math.sin(phi) * Math.cos(theta);
    uniforms4["sunPosition"].value.copy(vector3);
  });
  return sky;
});
var enabledOld = false;
getSkyShader((enabled) => {
  if (enabledOld === enabled)
    return;
  enabledOld = enabled;
  if (enabled)
    scene_default.add(lazySky());
  else
    scene_default.remove(lazySky());
});

// node_modules/lingo3d/lib/states/useOutline.js
var [setOutline, getOutline] = store(false);

// node_modules/lingo3d/lib/states/useSelectiveBloom.js
var [setSelectiveBloom, getSelectiveBloom] = store(false);

// node_modules/lingo3d/lib/states/useSSR.js
var [setSSR, getSSR] = store(false);

// node_modules/lingo3d/lib/engine/renderLoop/resize.js
var resize_default = {};
var getZ = (height, camera) => Math.abs(height * 0.5 / Math.cos(camera.fov * 0.6 * deg2Rad));
createEffect(() => {
  var _a2;
  const [vw2, vh2] = (_a2 = getViewportSize()) != null ? _a2 : getResolution();
  const [resX, resY, aspect] = updateCameraAspect(getCameraRendered());
  const size0 = {
    width: resX,
    height: vh2 - (vw2 - resX) * vh2 / vw2
  };
  const size1 = {
    width: vw2 - (vh2 - resY) * vw2 / vh2,
    height: resY
  };
  const val0 = Math.min(resX - size0.width, resY - size0.height);
  const val1 = Math.min(resX - size1.width, resY - size1.height);
  if (val0 > val1) {
    setCameraDistance(getZ(vw2 / aspect, mainCamera_default));
  } else {
    setCameraDistance(getZ(vh2, mainCamera_default));
  }
}, [getResolution, getViewportSize, getCameraRendered, getVR]);

// node_modules/lingo3d/lib/states/useBloom.js
var [setBloom, getBloom] = store(false);

// node_modules/lingo3d/lib/states/useAmbientOcclusion.js
var [setAmbientOcclusion, getAmbientOcclusion] = store(false);

// node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js
var LuminosityHighPassShader = {
  shaderID: "luminosityHighPass",
  uniforms: {
    "tDiffuse": { value: null },
    "luminosityThreshold": { value: 1 },
    "smoothWidth": { value: 1 },
    "defaultColor": { value: new Color(0) },
    "defaultOpacity": { value: 0 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};

// node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js
var UnrealBloomPass = class extends Pass {
  constructor(resolution, strength, radius2, threshold) {
    super();
    this.strength = strength !== void 0 ? strength : 1;
    this.radius = radius2;
    this.threshold = threshold;
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    this.clearColor = new Color(0, 0, 0);
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    let resx = Math.round(this.resolution.x / 2);
    let resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(resx, resy);
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.renderTargetBright.texture.generateMipmaps = false;
    for (let i4 = 0; i4 < this.nMips; i4++) {
      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy);
      renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i4;
      renderTargetHorizonal.texture.generateMipmaps = false;
      this.renderTargetsHorizontal.push(renderTargetHorizonal);
      const renderTargetVertical = new WebGLRenderTarget(resx, resy);
      renderTargetVertical.texture.name = "UnrealBloomPass.v" + i4;
      renderTargetVertical.texture.generateMipmaps = false;
      this.renderTargetsVertical.push(renderTargetVertical);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    if (LuminosityHighPassShader === void 0)
      console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
    const highPassShader = LuminosityHighPassShader;
    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
    this.highPassUniforms["luminosityThreshold"].value = threshold;
    this.highPassUniforms["smoothWidth"].value = 0.01;
    this.materialHighPassFilter = new ShaderMaterial({
      uniforms: this.highPassUniforms,
      vertexShader: highPassShader.vertexShader,
      fragmentShader: highPassShader.fragmentShader,
      defines: {}
    });
    this.separableBlurMaterials = [];
    const kernelSizeArray = [3, 5, 7, 9, 11];
    resx = Math.round(this.resolution.x / 2);
    resy = Math.round(this.resolution.y / 2);
    for (let i4 = 0; i4 < this.nMips; i4++) {
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i4]));
      this.separableBlurMaterials[i4].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this.getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    this.compositeMaterial.needsUpdate = true;
    const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    if (CopyShader === void 0) {
      console.error("THREE.UnrealBloomPass relies on CopyShader");
    }
    const copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.basic = new MeshBasicMaterial();
    this.fsQuad = new FullScreenQuad(null);
  }
  dispose() {
    for (let i4 = 0; i4 < this.renderTargetsHorizontal.length; i4++) {
      this.renderTargetsHorizontal[i4].dispose();
    }
    for (let i4 = 0; i4 < this.renderTargetsVertical.length; i4++) {
      this.renderTargetsVertical[i4].dispose();
    }
    this.renderTargetBright.dispose();
  }
  setSize(width, height) {
    let resx = Math.round(width / 2);
    let resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i4 = 0; i4 < this.nMips; i4++) {
      this.renderTargetsHorizontal[i4].setSize(resx, resy);
      this.renderTargetsVertical[i4].setSize(resx, resy);
      this.separableBlurMaterials[i4].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this.fsQuad.material = this.basic;
      this.basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this.fsQuad.render(renderer);
    let inputRenderTarget = this.renderTargetBright;
    for (let i4 = 0; i4 < this.nMips; i4++) {
      this.fsQuad.material = this.separableBlurMaterials[i4];
      this.separableBlurMaterials[i4].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i4].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i4]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterials[i4].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i4].texture;
      this.separableBlurMaterials[i4].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i4]);
      renderer.clear();
      this.fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i4];
    }
    this.fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  getSeperableBlurMaterial(kernelRadius) {
    return new ShaderMaterial({
      defines: {
        "KERNEL_RADIUS": kernelRadius,
        "SIGMA": kernelRadius
      },
      uniforms: {
        "colorTexture": { value: null },
        "texSize": { value: new Vector2(0.5, 0.5) },
        "direction": { value: new Vector2(0.5, 0.5) }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  getCompositeMaterial(nMips) {
    return new ShaderMaterial({
      defines: {
        "NUM_MIPS": nMips
      },
      uniforms: {
        "blurTexture1": { value: null },
        "blurTexture2": { value: null },
        "blurTexture3": { value: null },
        "blurTexture4": { value: null },
        "blurTexture5": { value: null },
        "bloomStrength": { value: 1 },
        "bloomFactors": { value: null },
        "bloomTintColors": { value: null },
        "bloomRadius": { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
};
UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);

// node_modules/lingo3d/lib/states/useBloomRadius.js
var [setBloomRadius, getBloomRadius] = store(0);

// node_modules/lingo3d/lib/states/useBloomStrength.js
var [setBloomStrength, getBloomStrength] = store(1.5);

// node_modules/lingo3d/lib/states/useBloomThreshold.js
var [setBloomThreshold, getBloomThreshold] = store(0);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/bloomPass.js
var bloomPass = new UnrealBloomPass(new Vector2(), 1.5, 0, 0);
var bloomPass_default = bloomPass;
getBloomRadius((val) => bloomPass.radius = val);
getBloomStrength((val) => bloomPass.strength = val);
getBloomThreshold((val) => bloomPass.threshold = val);

// node_modules/three/examples/jsm/shaders/BokehShader.js
var BokehShader = {
  defines: {
    "DEPTH_PACKING": 1,
    "PERSPECTIVE_CAMERA": 1
  },
  uniforms: {
    "tColor": { value: null },
    "tDepth": { value: null },
    "focus": { value: 1 },
    "aspect": { value: 1 },
    "aperture": { value: 0.025 },
    "maxblur": { value: 0.01 },
    "nearClip": { value: 1 },
    "farClip": { value: 1e3 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
};

// node_modules/three/examples/jsm/postprocessing/BokehPass.js
var BokehPass = class extends Pass {
  constructor(scene, camera, params) {
    super();
    this.scene = scene;
    this.camera = camera;
    const focus = params.focus !== void 0 ? params.focus : 1;
    const aspect = params.aspect !== void 0 ? params.aspect : camera.aspect;
    const aperture = params.aperture !== void 0 ? params.aperture : 0.025;
    const maxblur = params.maxblur !== void 0 ? params.maxblur : 1;
    const width = params.width || window.innerWidth || 1;
    const height = params.height || window.innerHeight || 1;
    this.renderTargetDepth = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.renderTargetDepth.texture.name = "BokehPass.depth";
    this.materialDepth = new MeshDepthMaterial();
    this.materialDepth.depthPacking = RGBADepthPacking;
    this.materialDepth.blending = NoBlending;
    if (BokehShader === void 0) {
      console.error("THREE.BokehPass relies on BokehShader");
    }
    const bokehShader = BokehShader;
    const bokehUniforms = UniformsUtils.clone(bokehShader.uniforms);
    bokehUniforms["tDepth"].value = this.renderTargetDepth.texture;
    bokehUniforms["focus"].value = focus;
    bokehUniforms["aspect"].value = aspect;
    bokehUniforms["aperture"].value = aperture;
    bokehUniforms["maxblur"].value = maxblur;
    bokehUniforms["nearClip"].value = camera.near;
    bokehUniforms["farClip"].value = camera.far;
    this.materialBokeh = new ShaderMaterial({
      defines: Object.assign({}, bokehShader.defines),
      uniforms: bokehUniforms,
      vertexShader: bokehShader.vertexShader,
      fragmentShader: bokehShader.fragmentShader
    });
    this.uniforms = bokehUniforms;
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(this.materialBokeh);
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    this.scene.overrideMaterial = this.materialDepth;
    renderer.getClearColor(this._oldClearColor);
    const oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(16777215);
    renderer.setClearAlpha(1);
    renderer.setRenderTarget(this.renderTargetDepth);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.uniforms["tColor"].value = readBuffer.texture;
    this.uniforms["nearClip"].value = this.camera.near;
    this.uniforms["farClip"].value = this.camera.far;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.scene.overrideMaterial = null;
    renderer.setClearColor(this._oldClearColor);
    renderer.setClearAlpha(oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/bokehPass.js
var bokehPass = new BokehPass(scene_default, getCameraRendered(), {});
var bokehPass_default = bokehPass;
getCameraRendered((camera) => bokehPass.camera = camera);
var uniforms = bokehPass.uniforms;
getBokehFocus((val) => uniforms["focus"].value = val);
getBokehAperture((val) => uniforms["aperture"].value = val);
getBokehMaxBlur((val) => uniforms["maxblur"].value = val);

// node_modules/three/examples/jsm/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/renderPass.js
var renderPass = new RenderPass(scene_default, getCameraRendered());
var renderPass_default = renderPass;
getCameraRendered((camera) => renderPass.camera = camera);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/selectiveBloomPass/index.js
createEffect(() => {
  const selectiveBloomComposer = getSelectiveBloomComposer();
  if (!selectiveBloomComposer)
    return;
  selectiveBloomComposer.addPass(renderPass_default);
  selectiveBloomComposer.addPass(bloomPass_default);
  return () => {
    selectiveBloomComposer.removePass(renderPass_default);
    selectiveBloomComposer.removePass(bloomPass_default);
  };
}, [getSelectiveBloomComposer]);
var selectiveBloomPass = new ShaderPass(new ShaderMaterial({
  uniforms: {
    baseTexture: { value: null },
    bloomTexture: { value: null }
  },
  vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
  fragmentShader: `
            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main() {
                gl_FragColor = texture2D(baseTexture, vUv) + texture2D(bloomTexture, vUv);
            }
        `,
  defines: {}
}), "baseTexture");
var { uniforms: uniforms2 } = selectiveBloomPass;
getSelectiveBloomComposer((composer) => composer && (uniforms2["bloomTexture"].value = composer.renderTarget2.texture));
var selectiveBloomPass_default = selectiveBloomPass;

// node_modules/three/examples/jsm/shaders/SAOShader.js
var SAOShader = {
  defines: {
    "NUM_SAMPLES": 7,
    "NUM_RINGS": 4,
    "NORMAL_TEXTURE": 0,
    "DIFFUSE_TEXTURE": 0,
    "DEPTH_PACKING": 1,
    "PERSPECTIVE_CAMERA": 1
  },
  uniforms: {
    "tDepth": { value: null },
    "tDiffuse": { value: null },
    "tNormal": { value: null },
    "size": { value: new Vector2(512, 512) },
    "cameraNear": { value: 1 },
    "cameraFar": { value: 100 },
    "cameraProjectionMatrix": { value: new Matrix4() },
    "cameraInverseProjectionMatrix": { value: new Matrix4() },
    "scale": { value: 1 },
    "intensity": { value: 0.1 },
    "bias": { value: 0.5 },
    "minResolution": { value: 0 },
    "kernelRadius": { value: 100 },
    "randomSeed": { value: 0 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,
  fragmentShader: `

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`
};

// node_modules/three/examples/jsm/shaders/DepthLimitedBlurShader.js
var DepthLimitedBlurShader = {
  defines: {
    "KERNEL_RADIUS": 4,
    "DEPTH_PACKING": 1,
    "PERSPECTIVE_CAMERA": 1
  },
  uniforms: {
    "tDiffuse": { value: null },
    "size": { value: new Vector2(512, 512) },
    "sampleUvOffsets": { value: [new Vector2(0, 0)] },
    "sampleWeights": { value: [1] },
    "tDepth": { value: null },
    "cameraNear": { value: 10 },
    "cameraFar": { value: 1e3 },
    "depthCutoff": { value: 10 }
  },
  vertexShader: `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,
  fragmentShader: `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`
};
var BlurShaderUtils = {
  createSampleWeights: function(kernelRadius, stdDev) {
    const weights = [];
    for (let i4 = 0; i4 <= kernelRadius; i4++) {
      weights.push(gaussian(i4, stdDev));
    }
    return weights;
  },
  createSampleOffsets: function(kernelRadius, uvIncrement) {
    const offsets = [];
    for (let i4 = 0; i4 <= kernelRadius; i4++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i4));
    }
    return offsets;
  },
  configure: function(material, kernelRadius, stdDev, uvIncrement) {
    material.defines["KERNEL_RADIUS"] = kernelRadius;
    material.uniforms["sampleUvOffsets"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    material.uniforms["sampleWeights"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    material.needsUpdate = true;
  }
};
function gaussian(x2, stdDev) {
  return Math.exp(-(x2 * x2) / (2 * (stdDev * stdDev))) / (Math.sqrt(2 * Math.PI) * stdDev);
}

// node_modules/three/examples/jsm/shaders/UnpackDepthRGBAShader.js
var UnpackDepthRGBAShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`
};

// node_modules/three/examples/jsm/postprocessing/SAOPass.js
var SAOPass = class extends Pass {
  constructor(scene, camera, useDepthTexture = false, useNormals = false, resolution = new Vector2(256, 256)) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.supportsDepthTextureExtension = useDepthTexture;
    this.supportsNormalTexture = useNormals;
    this.originalClearColor = new Color();
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.params = {
      output: 0,
      saoBias: 0.5,
      saoIntensity: 0.18,
      saoScale: 1,
      saoKernelRadius: 100,
      saoMinResolution: 0,
      saoBlur: true,
      saoBlurRadius: 8,
      saoBlurStdDev: 4,
      saoBlurDepthCutoff: 0.01
    };
    this.resolution = new Vector2(resolution.x, resolution.y);
    this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    this.beautyRenderTarget = this.saoRenderTarget.clone();
    this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.depthRenderTarget = this.normalRenderTarget.clone();
    let depthTexture;
    if (this.supportsDepthTextureExtension) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      this.beautyRenderTarget.depthTexture = depthTexture;
      this.beautyRenderTarget.depthBuffer = true;
    }
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.depthPacking = RGBADepthPacking;
    this.depthMaterial.blending = NoBlending;
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    if (SAOShader === void 0) {
      console.error("THREE.SAOPass relies on SAOShader");
    }
    this.saoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SAOShader.defines),
      fragmentShader: SAOShader.fragmentShader,
      vertexShader: SAOShader.vertexShader,
      uniforms: UniformsUtils.clone(SAOShader.uniforms)
    });
    this.saoMaterial.extensions.derivatives = true;
    this.saoMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.saoMaterial.defines["NORMAL_TEXTURE"] = this.supportsNormalTexture ? 1 : 0;
    this.saoMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.saoMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.saoMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.blending = NoBlending;
    if (DepthLimitedBlurShader === void 0) {
      console.error("THREE.SAOPass relies on DepthLimitedBlurShader");
    }
    this.vBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.vBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.vBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.vBlurMaterial.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
    this.vBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.vBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.vBlurMaterial.blending = NoBlending;
    this.hBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.hBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.hBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.hBlurMaterial.uniforms["tDiffuse"].value = this.blurIntermediateRenderTarget.texture;
    this.hBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.hBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.hBlurMaterial.blending = NoBlending;
    if (CopyShader === void 0) {
      console.error("THREE.SAOPass relies on CopyShader");
    }
    this.materialCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: NoBlending
    });
    this.materialCopy.transparent = true;
    this.materialCopy.depthTest = false;
    this.materialCopy.depthWrite = false;
    this.materialCopy.blending = CustomBlending;
    this.materialCopy.blendSrc = DstColorFactor;
    this.materialCopy.blendDst = ZeroFactor;
    this.materialCopy.blendEquation = AddEquation;
    this.materialCopy.blendSrcAlpha = DstAlphaFactor;
    this.materialCopy.blendDstAlpha = ZeroFactor;
    this.materialCopy.blendEquationAlpha = AddEquation;
    if (UnpackDepthRGBAShader === void 0) {
      console.error("THREE.SAOPass relies on UnpackDepthRGBAShader");
    }
    this.depthCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
      vertexShader: UnpackDepthRGBAShader.vertexShader,
      fragmentShader: UnpackDepthRGBAShader.fragmentShader,
      blending: NoBlending
    });
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms["tDiffuse"].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms["bias"].value = this.params.saoBias;
    this.saoMaterial.uniforms["intensity"].value = this.params.saoIntensity;
    this.saoMaterial.uniforms["scale"].value = this.params.saoScale;
    this.saoMaterial.uniforms["kernelRadius"].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms["minResolution"].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.saoMaterial.uniforms["cameraFar"].value = this.camera.far;
    const depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.hBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.vBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.vBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.hBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.hBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));
      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }
    renderer.setClearColor(0);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    if (!this.supportsDepthTextureExtension) {
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);
    }
    if (this.supportsNormalTexture) {
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    }
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);
    }
    let outputMaterial = this.materialCopy;
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms["tDiffuse"].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms["tDiffuse"].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms["size"].value.set(width, height);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms["size"].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms["size"].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
};
SAOPass.OUTPUT = {
  "Beauty": 1,
  "Default": 0,
  "SAO": 2,
  "Depth": 3,
  "Normal": 4
};

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/saoPass.js
var saoPass = new SAOPass(scene_default, getCameraRendered(), false, true);
var saoPass_default = saoPass;
saoPass.params.saoKernelRadius = 80;
saoPass.params.saoBlurStdDev = 5;
getAmbientOcclusion((ao) => saoPass.params.saoScale = ao === "light" ? 3e3 : 2e3);
getCameraRendered((camera) => saoPass.camera = camera);

// node_modules/lingo3d/lib/states/useLensIor.js
var [setLensIor, getLensIor] = store(0.8);

// node_modules/lingo3d/lib/states/useLensBand.js
var [setLensBand, getLensBand] = store(0.01);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/lensDistortionPass.js
var lensDistortionPass = new ShaderPass(new ShaderMaterial({
  defines: {
    BAND_MODE: 2,
    CHROMA_SAMPLES: 1
  },
  uniforms: {
    tDiffuse: { value: null },
    baseIor: { value: 0.8 },
    bandOffset: { value: 0.01 },
    jitterIntensity: { value: 1 },
    jitterOffset: { value: 0 }
  },
  vertexShader: `

		varying vec2 vUv;
		varying vec3 viewDir;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			viewDir = normalize( ( modelViewMatrix * vec4( position, 1.0 ) ).xyz );

		}

	`,
  fragmentShader: `

		varying vec2 vUv;
		varying vec3 viewDir;
		uniform float baseIor;
		uniform float bandOffset;
		uniform float jitterIntensity;
		uniform float jitterOffset;
		uniform sampler2D tDiffuse;

		#include <common>
		void main() {

			vec3 normal = vec3( ( 2.0 * vUv - vec2( 1.0 ) ), 1.0 );
			normal.z = 1.0;
			normal = normalize( normal );

			vec3 color;

			// if NO BANDS
			#if BAND_MODE == 0

			vec3 refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor );
			color = texture2D( tDiffuse, vUv + refracted.xy ).rgb;

			// if RGB or RYGCBV BANDS
			#else

			float index, randValue, offsetValue;
			float r, g, b, r_ior, g_ior, b_ior;
			vec3 r_refracted, g_refracted, b_refracted;
			vec4 r_sample, g_sample, b_sample;

			#if BAND_MODE == 2
			float y, c, v, y_ior, c_ior, v_ior;
			vec3 y_refracted, c_refracted, v_refracted;
			vec4 y_sample, c_sample, v_sample;
			#endif

			for ( int i = 0; i < CHROMA_SAMPLES; i ++ ) {

				index = float( i );
				randValue = rand( sin( index + 1. ) * gl_FragCoord.xy + vec2( jitterOffset, - jitterOffset ) ) - 0.5;
				offsetValue = index / float( CHROMA_SAMPLES ) + randValue * jitterIntensity;
				#if BAND_MODE == 1
				randValue *= 2.0;
				#endif

				// Paper describing functions for creating yellow, cyan, and violet bands and reforming
				// them into RGB:
				// https://web.archive.org/web/20061108181225/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf
				r_ior = 1.0 + bandOffset * ( 0.0 + offsetValue );
				g_ior = 1.0 + bandOffset * ( 2.0 + offsetValue );
				b_ior = 1.0 + bandOffset * ( 4.0 + offsetValue );

				r_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / r_ior );
				g_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / g_ior );
				b_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / b_ior );

				r_sample = texture2D( tDiffuse, vUv + r_refracted.xy );
				g_sample = texture2D( tDiffuse, vUv + g_refracted.xy );
				b_sample = texture2D( tDiffuse, vUv + b_refracted.xy );

				#if BAND_MODE == 2
				y_ior = 1.0 + bandOffset * ( 1.0 + offsetValue );
				c_ior = 1.0 + bandOffset * ( 3.0 + offsetValue );
				v_ior = 1.0 + bandOffset * ( 5.0 + offsetValue );

				y_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / y_ior );
				c_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / c_ior );
				v_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / v_ior );

				y_sample = texture2D( tDiffuse, vUv + y_refracted.xy );
				c_sample = texture2D( tDiffuse, vUv + c_refracted.xy );
				v_sample = texture2D( tDiffuse, vUv + v_refracted.xy );

				r = r_sample.r / 2.0;
				y = ( 2.0 * y_sample.r + 2.0 * y_sample.g - y_sample.b ) / 6.0;
				g = g_sample.g / 2.0;
				c = ( 2.0 * c_sample.g + 2.0 * c_sample.b - c_sample.r ) / 6.0;
				b = b_sample.b / 2.0;
				v = ( 2.0 * v_sample.b + 2.0 * v_sample.r - v_sample.g ) / 6.0;

				color.r += r + ( 2.0 * v + 2.0 * y - c ) / 3.0;
				color.g += g + ( 2.0 * y + 2.0 * c - v ) / 3.0;
				color.b += b + ( 2.0 * c + 2.0 * v - y ) / 3.0;
				#else
				color.r += r_sample.r;
				color.g += g_sample.g;
				color.b += b_sample.b;
				#endif

			}

			color /= float( CHROMA_SAMPLES );

			#endif

			gl_FragColor = vec4( color, 1.0 );

		}

	`
}));
var { uniforms: uniforms3 } = lensDistortionPass;
getLensIor((val) => uniforms3["baseIor"].value = val);
getLensBand((val) => uniforms3["bandOffset"].value = val);
var lensDistortionPass_default = lensDistortionPass;

// node_modules/lingo3d/lib/states/useLensDistortion.js
var [setLensDistortion, getLensDistortion] = store(false);

// node_modules/lingo3d/lib/states/useEffectComposer.js
var [setEffectComposer, getEffectComposer] = store(void 0);
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  if (getAntiAlias() !== "MSAA") {
    setEffectComposer(new EffectComposer(renderer));
    return;
  }
  const msaaRenderTarget = new WebGLRenderTarget(WIDTH, HEIGHT, { samples: 4 });
  const handle = getResolution(([w4, h4]) => msaaRenderTarget.setSize(w4, h4));
  setEffectComposer(new EffectComposer(renderer, msaaRenderTarget));
  return () => {
    msaaRenderTarget.dispose();
    handle.cancel();
  };
}, [getRenderer, getAntiAlias]);
createEffect(() => {
  const effectComposer = getEffectComposer();
  if (!effectComposer)
    return;
  const [w4, h4] = getResolution();
  effectComposer.setSize(w4, h4);
  effectComposer.setPixelRatio(getPixelRatioComputed());
}, [getEffectComposer, getResolution, getPixelRatioComputed]);

// node_modules/three/examples/jsm/shaders/SMAAShader.js
var SMAAEdgesShader = {
  defines: {
    "SMAA_THRESHOLD": "0.1"
  },
  uniforms: {
    "tDiffuse": { value: null },
    "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`
};
var SMAAWeightsShader = {
  defines: {
    "SMAA_MAX_SEARCH_STEPS": "8",
    "SMAA_AREATEX_MAX_DISTANCE": "16",
    "SMAA_AREATEX_PIXEL_SIZE": "( 1.0 / vec2( 160.0, 560.0 ) )",
    "SMAA_AREATEX_SUBTEX_SIZE": "( 1.0 / 7.0 )"
  },
  uniforms: {
    "tDiffuse": { value: null },
    "tArea": { value: null },
    "tSearch": { value: null },
    "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`
};
var SMAABlendShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "tColor": { value: null },
    "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`
};

// node_modules/three/examples/jsm/postprocessing/SMAAPass.js
var SMAAPass = class extends Pass {
  constructor(width, height) {
    super();
    this.edgesRT = new WebGLRenderTarget(width, height, {
      depthBuffer: false
    });
    this.edgesRT.texture.name = "SMAAPass.edges";
    this.weightsRT = new WebGLRenderTarget(width, height, {
      depthBuffer: false
    });
    this.weightsRT.texture.name = "SMAAPass.weights";
    const scope = this;
    const areaTextureImage = new Image();
    areaTextureImage.src = this.getAreaTexture();
    areaTextureImage.onload = function() {
      scope.areaTexture.needsUpdate = true;
    };
    this.areaTexture = new Texture();
    this.areaTexture.name = "SMAAPass.area";
    this.areaTexture.image = areaTextureImage;
    this.areaTexture.minFilter = LinearFilter;
    this.areaTexture.generateMipmaps = false;
    this.areaTexture.flipY = false;
    const searchTextureImage = new Image();
    searchTextureImage.src = this.getSearchTexture();
    searchTextureImage.onload = function() {
      scope.searchTexture.needsUpdate = true;
    };
    this.searchTexture = new Texture();
    this.searchTexture.name = "SMAAPass.search";
    this.searchTexture.image = searchTextureImage;
    this.searchTexture.magFilter = NearestFilter;
    this.searchTexture.minFilter = NearestFilter;
    this.searchTexture.generateMipmaps = false;
    this.searchTexture.flipY = false;
    if (SMAAEdgesShader === void 0) {
      console.error("THREE.SMAAPass relies on SMAAShader");
    }
    this.uniformsEdges = UniformsUtils.clone(SMAAEdgesShader.uniforms);
    this.uniformsEdges["resolution"].value.set(1 / width, 1 / height);
    this.materialEdges = new ShaderMaterial({
      defines: Object.assign({}, SMAAEdgesShader.defines),
      uniforms: this.uniformsEdges,
      vertexShader: SMAAEdgesShader.vertexShader,
      fragmentShader: SMAAEdgesShader.fragmentShader
    });
    this.uniformsWeights = UniformsUtils.clone(SMAAWeightsShader.uniforms);
    this.uniformsWeights["resolution"].value.set(1 / width, 1 / height);
    this.uniformsWeights["tDiffuse"].value = this.edgesRT.texture;
    this.uniformsWeights["tArea"].value = this.areaTexture;
    this.uniformsWeights["tSearch"].value = this.searchTexture;
    this.materialWeights = new ShaderMaterial({
      defines: Object.assign({}, SMAAWeightsShader.defines),
      uniforms: this.uniformsWeights,
      vertexShader: SMAAWeightsShader.vertexShader,
      fragmentShader: SMAAWeightsShader.fragmentShader
    });
    this.uniformsBlend = UniformsUtils.clone(SMAABlendShader.uniforms);
    this.uniformsBlend["resolution"].value.set(1 / width, 1 / height);
    this.uniformsBlend["tDiffuse"].value = this.weightsRT.texture;
    this.materialBlend = new ShaderMaterial({
      uniforms: this.uniformsBlend,
      vertexShader: SMAABlendShader.vertexShader,
      fragmentShader: SMAABlendShader.fragmentShader
    });
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer) {
    this.uniformsEdges["tDiffuse"].value = readBuffer.texture;
    this.fsQuad.material = this.materialEdges;
    renderer.setRenderTarget(this.edgesRT);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialWeights;
    renderer.setRenderTarget(this.weightsRT);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    this.uniformsBlend["tColor"].value = readBuffer.texture;
    this.fsQuad.material = this.materialBlend;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
  setSize(width, height) {
    this.edgesRT.setSize(width, height);
    this.weightsRT.setSize(width, height);
    this.materialEdges.uniforms["resolution"].value.set(1 / width, 1 / height);
    this.materialWeights.uniforms["resolution"].value.set(1 / width, 1 / height);
    this.materialBlend.uniforms["resolution"].value.set(1 / width, 1 / height);
  }
  getAreaTexture() {
    return "data:image/png;base64,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";
  }
  getSearchTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
  }
};

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/smaaPass.js
var smaaPass_default = new SMAAPass(WIDTH, HEIGHT);

// node_modules/lingo3d/lib/engine/renderLoop/effectComposer/index.js
var effectComposer_default = {};
createEffect(() => {
  const effectComposer = getEffectComposer();
  if (!effectComposer)
    return;
  const passes = [renderPass_default];
  if (getSSR())
    passes.push(ssrPass_default);
  if (getAmbientOcclusion())
    passes.push(saoPass_default);
  if (getBloom())
    passes.push(bloomPass_default);
  if (getSelectiveBloom())
    passes.push(selectiveBloomPass_default);
  if (getBokeh())
    passes.push(bokehPass_default);
  if (getOutline())
    passes.push(outlinePass_default);
  if (getLensDistortion())
    passes.push(lensDistortionPass_default);
  if (getAntiAlias() === "SSAA" || getAntiAlias() === "SMAA")
    passes.push(smaaPass_default);
  for (const pass of passes)
    effectComposer.addPass(pass);
  setEffectComposerPassCount(passes.length - 1);
  return () => {
    for (const pass of passes)
      effectComposer.removePass(pass);
    setEffectComposerPassCount(0);
  };
}, [getEffectComposer, getSSR, getAmbientOcclusion, getBloom, getSelectiveBloom, getBokeh, getOutline, getLensDistortion, getAntiAlias]);

// node_modules/lingo3d/lib/events/onRender.js
var [emitRender, onRender] = event_default();

// node_modules/lingo3d/lib/events/onRender2.js
var [emitRender2, onRender2] = event_default();

// node_modules/lingo3d/lib/engine/renderLoop/index.js
preventTreeShake([resize_default, effectComposer_default]);
var renderLoop_default = {};
createEffect(() => {
  const renderer = getRenderer();
  if (!renderer)
    return;
  const camera = getCameraRendered();
  const secondaryCamera = getSecondaryCamera();
  if (secondaryCamera) {
    const [resX, resY] = getResolution();
    const width = resX * 1;
    const height = resY * 0.5;
    secondaryCamera.aspect = camera.aspect = width / height;
    camera.updateProjectionMatrix();
    secondaryCamera.updateProjectionMatrix();
    const handle2 = loop(() => {
      emitBeforeRender();
      emitRender();
      emitRender2();
      renderer.setViewport(0, 0, width, height);
      renderer.setScissor(0, 0, width, height);
      renderer.setScissorTest(true);
      renderer.render(scene_default, secondaryCamera);
      renderer.setViewport(0, height, width, height);
      renderer.setScissor(0, height, width, height);
      renderer.render(scene_default, camera);
      emitAfterRender();
    });
    return () => {
      handle2.cancel();
      renderer.setViewport(0, 0, resX, resY);
      renderer.setScissor(0, 0, resX, resY);
      renderer.setScissorTest(false);
      camera.aspect = resX / resY;
      camera.updateProjectionMatrix();
    };
  }
  const vr = getVR();
  if (vr === "webxr") {
    const handle2 = loop(() => {
      emitBeforeRender();
      emitRender();
      emitRender2();
      renderer.render(scene_default, camera);
      emitAfterRender();
    });
    return () => {
      handle2.cancel();
    };
  }
  if (vr) {
    const focus = new Cube();
    focus.scale = 0.5;
    focus.visible = false;
    const focalDistannce = 1e3;
    const parallax = -focalDistannce * 0.5;
    const [resX, resY] = getResolution();
    const width = resX * 0.5;
    const height = resY * 1;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    const camManager = new SimpleObjectManager_default(camera);
    const handle2 = loop(() => {
      emitBeforeRender();
      emitRender();
      emitRender2();
      renderer.setViewport(0, 0, width, height);
      renderer.setScissor(0, 0, width, height);
      renderer.setScissorTest(true);
      focus.outerObject3d.position.copy(getWorldPosition_default(camera));
      focus.outerObject3d.quaternion.copy(camera.quaternion);
      focus.translateZ(-focalDistannce);
      const focalPosition = focus.outerObject3d.position.clone();
      const quat = camera.quaternion.clone();
      const pos = camera.position.clone();
      focus.moveRight(parallax);
      camManager.moveRight(-3);
      camera.lookAt(focus.outerObject3d.position);
      renderer.render(scene_default, camera);
      focus.outerObject3d.position.copy(focalPosition);
      camera.quaternion.copy(quat);
      camera.position.copy(pos);
      renderer.setViewport(width, 0, width, height);
      renderer.setScissor(width, 0, width, height);
      focus.moveRight(-parallax);
      camManager.moveRight(3);
      camera.lookAt(focus.outerObject3d.position);
      renderer.render(scene_default, camera);
      focus.outerObject3d.position.copy(focalPosition);
      camera.quaternion.copy(quat);
      camera.position.copy(pos);
      emitAfterRender();
    });
    return () => {
      focus.dispose();
      handle2.cancel();
      renderer.setViewport(0, 0, resX, resY);
      renderer.setScissor(0, 0, resX, resY);
      renderer.setScissorTest(false);
      camera.aspect = resX / resY;
      camera.updateProjectionMatrix();
    };
  }
  const effectComposer = getEffectComposer();
  if (!effectComposer)
    return;
  let selectiveBloomInitialized = false;
  let ssrInitialized = false;
  let outlineInitialized = false;
  const handle = loop(() => {
    emitBeforeRender();
    emitRender();
    emitRender2();
    if (bloomPtr[0]) {
      if (!selectiveBloomInitialized) {
        setSelectiveBloom(true);
        selectiveBloomInitialized = true;
      }
      renderSelectiveBloom_default();
    }
    if (ssrPtr[0] && !ssrInitialized) {
      setSSR(true);
      setAntiAlias("SMAA");
      ssrInitialized = true;
    }
    if (outlinePtr[0] && !outlineInitialized) {
      setOutline(true);
      outlineInitialized = true;
    }
    effectComposer.render();
    emitAfterRender();
  });
  return () => {
    handle.cancel();
  };
}, [getVR, getCameraRendered, getSecondaryCamera, getResolution, getRenderer, getEffectComposer]);

// node_modules/lingo3d/lib/engine/index.js
preventTreeShake([renderLoop_default, skyShader_default, referencePlane_default, gridHelper_default, transformControls_default, mainOrbitCamera_default, boxHelper_default, skeletonHelper_default]);
var engine_default = {};
"__THREE__" in window && (window.__THREE__ += " - Lingo3D Beta");

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/sphereShape.js
async function sphereShape_default() {
  const { Sphere: Sphere3 } = await loadCannon_default();
  const shape = new Sphere3(getActualScale_default(this).x * 0.5);
  this.cannonBody.addShape(shape);
}

// node_modules/lingo3d/lib/display/primitives/Sphere.js
var geometry = new SphereGeometry(radiusScaled, 16, 16);
var Sphere = class extends Primitive_default {
  constructor() {
    super(geometry);
    __publicField(this, "_physicsShape", sphereShape_default);
  }
};
__publicField(Sphere, "componentName", "sphere");

// node_modules/lingo3d/lib/display/primitives/Cone.js
var geometry2 = new ConeGeometry(radiusScaled, diameterScaled, 16);
var Cone = class extends Primitive_default {
  constructor() {
    super(geometry2);
  }
};
__publicField(Cone, "componentName", "cone");

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/cylinderShape.js
async function cylinderShape_default() {
  const { Cylinder: Cylinder3 } = await loadCannon_default();
  const { x: x2, y: y4 } = getActualScale_default(this);
  const radius2 = x2 * 0.5;
  const shape = new Cylinder3(radius2, radius2, y4);
  this.cannonBody.addShape(shape);
}

// node_modules/lingo3d/lib/display/primitives/Cylinder.js
var geometry3 = new CylinderGeometry(radiusScaled, radiusScaled, diameterScaled, 16);
var Cylinder = class extends Primitive_default {
  constructor() {
    super(geometry3);
    __publicField(this, "_physicsShape", cylinderShape_default);
  }
};
__publicField(Cylinder, "componentName", "cylinder");

// node_modules/lingo3d/lib/display/primitives/Octahedron.js
var geometry4 = new OctahedronGeometry(radiusScaled);
var Octahedron = class extends Primitive_default {
  constructor() {
    super(geometry4);
  }
};
__publicField(Octahedron, "componentName", "octahedron");

// node_modules/lingo3d/lib/display/primitives/Tetrahedron.js
var geometry5 = new TetrahedronGeometry(61 * scaleDown);
geometry5.rotateY(45 * deg2Rad);
geometry5.rotateX(125 * deg2Rad);
geometry5.translate(0, -0.2, 0.2);
var Tetrahedron = class extends Primitive_default {
  constructor() {
    super(geometry5);
  }
};
__publicField(Tetrahedron, "componentName", "tetrahedron");

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/torusShape.js
async function torusShape_default() {
  const { Box, Vec3 } = await loadCannon_default();
  const actualScale = getActualScale_default(this);
  const scale0 = actualScale.clone().multiply(vector3.set(0.15, 0.5, 0.1));
  const scale1 = actualScale.clone().multiply(vector3_.set(0.5, 0.15, 0.1));
  const shape0 = new Box(scale0);
  const shape1 = new Box(scale1);
  this.cannonBody.addShape(shape0, new Vec3(-scale1.x, 0, 0));
  this.cannonBody.addShape(shape0, new Vec3(scale1.x, 0, 0));
  this.cannonBody.addShape(shape1, new Vec3(0, -scale0.y, 0));
  this.cannonBody.addShape(shape1, new Vec3(0, scale0.y, 0));
}

// node_modules/lingo3d/lib/display/primitives/Torus.js
var geometry6 = new TorusGeometry(40 * scaleDown, 10 * scaleDown, 8, 16);
var Torus = class extends Primitive_default {
  constructor() {
    super(geometry6);
    __publicField(this, "_physicsShape", torusShape_default);
  }
};
__publicField(Torus, "componentName", "torus");

// node_modules/lingo3d/lib/interface/IPlane.js
var planeSchema = {
  ...primitiveSchema
};
var planeDefaults = {
  ...primitiveDefaults,
  scaleZ: 0,
  depth: 0
};

// node_modules/lingo3d/lib/display/primitives/Plane.js
var planeGeometry = new PlaneGeometry(diameterScaled, diameterScaled, 1, 1);
var Plane = class extends Primitive_default {
  constructor() {
    super(planeGeometry, true);
    this.object3d.scale.z = flatGeomScaleZ;
  }
  get depth() {
    return 0;
  }
  set depth(_4) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(_4) {
  }
};
__publicField(Plane, "componentName", "plane");
__publicField(Plane, "defaults", planeDefaults);
__publicField(Plane, "schema", planeSchema);

// node_modules/lingo3d/lib/display/core/mixins/PhysicsMixin/cannon/shapes/circleShape.js
async function circleShape_default() {
  const { Sphere: Sphere3 } = await loadCannon_default();
  this.cannonBody.addShape(new Sphere3(getActualScale_default(this).x * 0.5));
}

// node_modules/lingo3d/lib/interface/ICircle.js
var circleSchema = {
  ...primitiveSchema
};
var circleDefaults = {
  ...primitiveDefaults,
  scaleZ: 0,
  depth: 0
};

// node_modules/lingo3d/lib/display/primitives/Circle.js
var circleGeometry = new CircleGeometry(radiusScaled, 32);
var Circle = class extends Primitive_default {
  constructor() {
    super(circleGeometry, true);
    __publicField(this, "_physicsShape", circleShape_default);
    this.object3d.scale.z = flatGeomScaleZ;
  }
  get depth() {
    return 0;
  }
  set depth(_4) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(_4) {
  }
};
__publicField(Circle, "componentName", "circle");
__publicField(Circle, "defaults", circleDefaults);
__publicField(Circle, "schema", circleSchema);

// node_modules/lingo3d/lib/display/utils/measure.js
var measure_default = (gltf) => {
  const gltfSize = new Vector3();
  box3.setFromObject(gltf).getSize(gltfSize);
  return gltfSize;
};

// node_modules/lingo3d/lib/display/utils/fit.js
var cache = /* @__PURE__ */ new Map();
var fit_default = (gltf, src) => {
  const cached = cache.get(src);
  if (cached) {
    const [ratio2, center2, result2] = cached;
    gltf.scale.multiplyScalar(ratio2);
    gltf.position.copy(center2).multiplyScalar(-1);
    return result2.clone();
  }
  const gltfSize = measure_default(gltf);
  const ratio = 1 / gltfSize.y;
  gltf.scale.multiplyScalar(ratio);
  const center = getCenter_default(gltf);
  gltf.position.copy(center).multiplyScalar(-1);
  const result = gltfSize.multiplyScalar(ratio);
  cache.set(src, [ratio, center, result.clone()]);
  return result;
};

// node_modules/lingo3d/lib/interface/ILoaded.js
var loadedSchema = {
  ...objectManagerSchema,
  src: String,
  onLoad: Function,
  boxVisible: Boolean
};
var loadedDefaults = {
  ...objectManagerDefaults,
  src: void 0,
  onLoad: void 0,
  boxVisible: false
};

// node_modules/lingo3d/lib/interface/IModel.js
var modelSchema = {
  ...loadedSchema,
  loadedScale: Number,
  loadedX: Number,
  loadedY: Number,
  loadedZ: Number
};
var modelDefaults = {
  ...loadedDefaults,
  loadedScale: void 0,
  loadedX: void 0,
  loadedY: void 0,
  loadedZ: void 0
};

// node_modules/lingo3d/lib/display/utils/loaders/lazyLoad.js
var lazyLoadFBX = lazy(() => import("./loadFBX-AOA3MZEH.js"));
var lazyLoadGLTF = lazy(() => import("./loadGLTF-TZBMUJUH.js"));

// node_modules/lingo3d/lib/display/Model.js
var Model = class extends Loaded {
  constructor() {
    super(...arguments);
    __publicField(this, "loadedAnims");
    __publicField(this, "_loadedScale");
    __publicField(this, "_loadedPos");
    __publicField(this, "_loadedX");
    __publicField(this, "_loadedY");
    __publicField(this, "_loadedZ");
  }
  async loadAnimation(url2, name = url2) {
    var _a2, _b;
    ((_a2 = this.loadedAnims) != null ? _a2 : this.loadedAnims = {})[name] = url2;
    const resolvable = new Resolvable();
    ((_b = this.loadingAnims) != null ? _b : this.loadingAnims = []).push(resolvable);
    let data;
    try {
      data = await this.load(url2);
    } catch {
      resolvable.resolve();
      return;
    }
    const clip = data.animations[0];
    clip && (this.animations[name] = this.watch(new AnimationManager(clip, await this.loaded)));
    resolvable.resolve();
  }
  get animations() {
    var _a2;
    return (_a2 = this.animationManagers) != null ? _a2 : this.animationManagers = {};
  }
  set animations(val) {
    for (const [key, value] of Object.entries(val))
      if (typeof value === "string")
        this.loadAnimation(value, key);
      else
        this.animations[key] = value;
  }
  async load(url2) {
    var _a2;
    const resolvable = new Resolvable();
    ((_a2 = this.loadingAnims) != null ? _a2 : this.loadingAnims = []).push(resolvable);
    let result;
    try {
      if (objectURLMapperPtr[0](url2).toLowerCase().endsWith(".fbx"))
        result = await (await lazyLoadFBX()).default(url2, true);
      else
        result = await (await lazyLoadGLTF()).default(url2, true);
    } catch {
      resolvable.resolve();
      return new Group();
    }
    resolvable.resolve();
    return result;
  }
  get loadedScale() {
    return this._loadedScale;
  }
  set loadedScale(val) {
    this._loadedScale = val;
  }
  get loadedX() {
    return this._loadedX;
  }
  set loadedX(val) {
    this._loadedX = val;
    this._loadedPos = true;
  }
  get loadedY() {
    return this._loadedY;
  }
  set loadedY(val) {
    this._loadedY = val;
    this._loadedPos = true;
  }
  get loadedZ() {
    return this._loadedZ;
  }
  set loadedZ(val) {
    this._loadedZ = val;
    this._loadedPos = true;
  }
  resolveLoaded(loadedObject3d) {
    for (const clip of loadedObject3d.animations)
      this.animations[clip.name] = this.watch(new AnimationManager(clip, loadedObject3d));
    if (this._loadedScale)
      loadedObject3d.scale.multiplyScalar(this._loadedScale);
    else {
      const size = fit_default(loadedObject3d, this._src);
      !this.widthSet && (this.object3d.scale.x = size.x);
      !this.heightSet && (this.object3d.scale.y = size.y);
      !this.depthSet && (this.object3d.scale.z = size.z);
    }
    if (this._loadedPos) {
      let { x: x2, y: y4, z: z3 } = loadedObject3d.position;
      this._loadedX && (x2 = this._loadedX * scaleDown);
      this._loadedY && (y4 = this._loadedY * scaleDown);
      this._loadedZ && (z3 = this._loadedZ * scaleDown);
      loadedObject3d.position.set(x2, y4, z3);
    }
    return loadedObject3d;
  }
  find(name, hiddenFromSceneGraph) {
    const child = super.find(name, hiddenFromSceneGraph);
    child && (child.model = this);
    return child;
  }
  findAll(name) {
    const children2 = super.findAll(name);
    for (const child of children2)
      child.model = this;
    return children2;
  }
};
__publicField(Model, "componentName", "model");
__publicField(Model, "defaults", modelDefaults);
__publicField(Model, "schema", modelSchema);

// node_modules/xstate/es/_virtual/_tslib.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t5) {
    for (var s5, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
      s5 = arguments[i4];
      for (var p3 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p3))
          t5[p3] = s5[p3];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
function __rest(s5, e5) {
  var t5 = {};
  for (var p3 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p3) && e5.indexOf(p3) < 0)
      t5[p3] = s5[p3];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s5); i4 < p3.length; i4++) {
      if (e5.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p3[i4]))
        t5[p3[i4]] = s5[p3[i4]];
    }
  return t5;
}
function __values(o4) {
  var s5 = typeof Symbol === "function" && Symbol.iterator, m4 = s5 && o4[s5], i4 = 0;
  if (m4)
    return m4.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o4, n3) {
  var m4 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m4)
    return o4;
  var i4 = m4.call(o4), r5, ar = [], e5;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r5 = i4.next()).done)
      ar.push(r5.value);
  } catch (error3) {
    e5 = { error: error3 };
  } finally {
    try {
      if (r5 && !r5.done && (m4 = i4["return"]))
        m4.call(i4);
    } finally {
      if (e5)
        throw e5.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/xstate/es/types.js
var ActionTypes;
(function(ActionTypes2) {
  ActionTypes2["Start"] = "xstate.start";
  ActionTypes2["Stop"] = "xstate.stop";
  ActionTypes2["Raise"] = "xstate.raise";
  ActionTypes2["Send"] = "xstate.send";
  ActionTypes2["Cancel"] = "xstate.cancel";
  ActionTypes2["NullEvent"] = "";
  ActionTypes2["Assign"] = "xstate.assign";
  ActionTypes2["After"] = "xstate.after";
  ActionTypes2["DoneState"] = "done.state";
  ActionTypes2["DoneInvoke"] = "done.invoke";
  ActionTypes2["Log"] = "xstate.log";
  ActionTypes2["Init"] = "xstate.init";
  ActionTypes2["Invoke"] = "xstate.invoke";
  ActionTypes2["ErrorExecution"] = "error.execution";
  ActionTypes2["ErrorCommunication"] = "error.communication";
  ActionTypes2["ErrorPlatform"] = "error.platform";
  ActionTypes2["ErrorCustom"] = "xstate.error";
  ActionTypes2["Update"] = "xstate.update";
  ActionTypes2["Pure"] = "xstate.pure";
  ActionTypes2["Choose"] = "xstate.choose";
})(ActionTypes || (ActionTypes = {}));
var SpecialTargets;
(function(SpecialTargets2) {
  SpecialTargets2["Parent"] = "#_parent";
  SpecialTargets2["Internal"] = "#_internal";
})(SpecialTargets || (SpecialTargets = {}));

// node_modules/xstate/es/actionTypes.js
var start = ActionTypes.Start;
var stop = ActionTypes.Stop;
var raise = ActionTypes.Raise;
var send = ActionTypes.Send;
var cancel = ActionTypes.Cancel;
var nullEvent = ActionTypes.NullEvent;
var assign = ActionTypes.Assign;
var after = ActionTypes.After;
var doneState = ActionTypes.DoneState;
var log = ActionTypes.Log;
var init = ActionTypes.Init;
var invoke = ActionTypes.Invoke;
var errorExecution = ActionTypes.ErrorExecution;
var errorPlatform = ActionTypes.ErrorPlatform;
var error = ActionTypes.ErrorCustom;
var update = ActionTypes.Update;
var choose = ActionTypes.Choose;
var pure = ActionTypes.Pure;

// node_modules/xstate/es/constants.js
var STATE_DELIMITER = ".";
var EMPTY_ACTIVITY_MAP = {};
var DEFAULT_GUARD_TYPE = "xstate.guard";
var TARGETLESS_KEY = "";

// node_modules/xstate/es/environment.js
var IS_PRODUCTION = false;

// node_modules/xstate/es/utils.js
var _a;
function matchesState(parentStateId, childStateId, delimiter) {
  if (delimiter === void 0) {
    delimiter = STATE_DELIMITER;
  }
  var parentStateValue = toStateValue(parentStateId, delimiter);
  var childStateValue = toStateValue(childStateId, delimiter);
  if (isString(childStateValue)) {
    if (isString(parentStateValue)) {
      return childStateValue === parentStateValue;
    }
    return false;
  }
  if (isString(parentStateValue)) {
    return parentStateValue in childStateValue;
  }
  return Object.keys(parentStateValue).every(function(key) {
    if (!(key in childStateValue)) {
      return false;
    }
    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function getEventType(event2) {
  try {
    return isString(event2) || typeof event2 === "number" ? "".concat(event2) : event2.type;
  } catch (e5) {
    throw new Error("Events must be strings or objects with a string event.type property.");
  }
}
function toStatePath(stateId, delimiter) {
  try {
    if (isArray(stateId)) {
      return stateId;
    }
    return stateId.toString().split(delimiter);
  } catch (e5) {
    throw new Error("'".concat(stateId, "' is not a valid state path."));
  }
}
function isStateLike(state) {
  return typeof state === "object" && "value" in state && "context" in state && "event" in state && "_event" in state;
}
function toStateValue(stateValue, delimiter) {
  if (isStateLike(stateValue)) {
    return stateValue.value;
  }
  if (isArray(stateValue)) {
    return pathToStateValue(stateValue);
  }
  if (typeof stateValue !== "string") {
    return stateValue;
  }
  var statePath = toStatePath(stateValue, delimiter);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }
  var value = {};
  var marker = value;
  for (var i4 = 0; i4 < statePath.length - 1; i4++) {
    if (i4 === statePath.length - 2) {
      marker[statePath[i4]] = statePath[i4 + 1];
    } else {
      marker[statePath[i4]] = {};
      marker = marker[statePath[i4]];
    }
  }
  return value;
}
function mapValues(collection, iteratee) {
  var result = {};
  var collectionKeys = Object.keys(collection);
  for (var i4 = 0; i4 < collectionKeys.length; i4++) {
    var key = collectionKeys[i4];
    result[key] = iteratee(collection[key], key, collection, i4);
  }
  return result;
}
function mapFilterValues(collection, iteratee, predicate) {
  var e_1, _a2;
  var result = {};
  try {
    for (var _b = __values(Object.keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var item = collection[key];
      if (!predicate(item)) {
        continue;
      }
      result[key] = iteratee(item, key, collection);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return result;
}
var path = function(props) {
  return function(object) {
    var e_2, _a2;
    var result = object;
    try {
      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        result = result[prop];
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a2 = props_1.return))
          _a2.call(props_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return result;
  };
};
function nestedPath(props, accessorProp) {
  return function(object) {
    var e_3, _a2;
    var result = object;
    try {
      for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
        var prop = props_2_1.value;
        result = result[accessorProp][prop];
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (props_2_1 && !props_2_1.done && (_a2 = props_2.return))
          _a2.call(props_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return result;
  };
}
function toStatePaths(stateValue) {
  if (!stateValue) {
    return [[]];
  }
  if (isString(stateValue)) {
    return [[stateValue]];
  }
  var result = flatten(Object.keys(stateValue).map(function(key) {
    var subStateValue = stateValue[key];
    if (typeof subStateValue !== "string" && (!subStateValue || !Object.keys(subStateValue).length)) {
      return [[key]];
    }
    return toStatePaths(stateValue[key]).map(function(subPath) {
      return [key].concat(subPath);
    });
  }));
  return result;
}
function flatten(array) {
  var _a2;
  return (_a2 = []).concat.apply(_a2, __spreadArray([], __read(array), false));
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }
  return [value];
}
function toArray(value) {
  if (value === void 0) {
    return [];
  }
  return toArrayStrict(value);
}
function mapContext(mapper, context, _event) {
  var e_5, _a2;
  if (isFunction(mapper)) {
    return mapper(context, _event.data);
  }
  var result = {};
  try {
    for (var _b = __values(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var subMapper = mapper[key];
      if (isFunction(subMapper)) {
        result[key] = subMapper(context, _event.data);
      } else {
        result[key] = subMapper;
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return result;
}
function isBuiltInEvent(eventType) {
  return /^(done|error)\./.test(eventType);
}
function isPromiseLike(value) {
  if (value instanceof Promise) {
    return true;
  }
  if (value !== null && (isFunction(value) || typeof value === "object") && isFunction(value.then)) {
    return true;
  }
  return false;
}
function isBehavior(value) {
  return value !== null && typeof value === "object" && "transition" in value && typeof value.transition === "function";
}
function partition(items, predicate) {
  var e_6, _a2;
  var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;
      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_6_1) {
    e_6 = {
      error: e_6_1
    };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
        _a2.call(items_1);
    } finally {
      if (e_6)
        throw e_6.error;
    }
  }
  return [truthy, falsy];
}
function updateHistoryStates(hist, stateValue) {
  return mapValues(hist.states, function(subHist, key) {
    if (!subHist) {
      return void 0;
    }
    var subStateValue = (isString(stateValue) ? void 0 : stateValue[key]) || (subHist ? subHist.current : void 0);
    if (!subStateValue) {
      return void 0;
    }
    return {
      current: subStateValue,
      states: updateHistoryStates(subHist, subStateValue)
    };
  });
}
function updateHistoryValue(hist, stateValue) {
  return {
    current: stateValue,
    states: updateHistoryStates(hist, stateValue)
  };
}
function updateContext(context, _event, assignActions, state) {
  if (!IS_PRODUCTION) {
    warn(!!context, "Attempting to update undefined context");
  }
  var updatedContext = context ? assignActions.reduce(function(acc, assignAction) {
    var e_7, _a2;
    var assignment = assignAction.assignment;
    var meta = {
      state,
      action: assignAction,
      _event
    };
    var partialUpdate = {};
    if (isFunction(assignment)) {
      partialUpdate = assignment(acc, _event.data, meta);
    } else {
      try {
        for (var _b = __values(Object.keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var propAssignment = assignment[key];
          partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_7)
            throw e_7.error;
        }
      }
    }
    return Object.assign({}, acc, partialUpdate);
  }, context) : context;
  return updatedContext;
}
var warn = function() {
};
if (!IS_PRODUCTION) {
  warn = function(condition, message) {
    var error3 = condition instanceof Error ? condition : void 0;
    if (!error3 && condition) {
      return;
    }
    if (console !== void 0) {
      var args = ["Warning: ".concat(message)];
      if (error3) {
        args.push(error3);
      }
      console.warn.apply(console, args);
    }
  };
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function toGuard(condition, guardMap) {
  if (!condition) {
    return void 0;
  }
  if (isString(condition)) {
    return {
      type: DEFAULT_GUARD_TYPE,
      name: condition,
      predicate: guardMap ? guardMap[condition] : void 0
    };
  }
  if (isFunction(condition)) {
    return {
      type: DEFAULT_GUARD_TYPE,
      name: condition.name,
      predicate: condition
    };
  }
  return condition;
}
function isObservable(value) {
  try {
    return "subscribe" in value && isFunction(value.subscribe);
  } catch (e5) {
    return false;
  }
}
var symbolObservable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var interopSymbols = (_a = {}, _a[symbolObservable] = function() {
  return this;
}, _a[Symbol.observable] = function() {
  return this;
}, _a);
function isMachine(value) {
  return !!value && "__xstatenode" in value;
}
function isActor(value) {
  return !!value && typeof value.send === "function";
}
var uniqueId = function() {
  var currentId = 0;
  return function() {
    currentId++;
    return currentId.toString(16);
  };
}();
function toEventObject(event2, payload) {
  if (isString(event2) || typeof event2 === "number") {
    return __assign({
      type: event2
    }, payload);
  }
  return event2;
}
function toSCXMLEvent(event2, scxmlEvent) {
  if (!isString(event2) && "$$type" in event2 && event2.$$type === "scxml") {
    return event2;
  }
  var eventObject = toEventObject(event2);
  return __assign({
    name: eventObject.type,
    data: eventObject,
    $$type: "scxml",
    type: "external"
  }, scxmlEvent);
}
function toTransitionConfigArray(event2, configLike) {
  var transitions = toArrayStrict(configLike).map(function(transitionLike) {
    if (typeof transitionLike === "undefined" || typeof transitionLike === "string" || isMachine(transitionLike)) {
      return {
        target: transitionLike,
        event: event2
      };
    }
    return __assign(__assign({}, transitionLike), {
      event: event2
    });
  });
  return transitions;
}
function normalizeTarget(target) {
  if (target === void 0 || target === TARGETLESS_KEY) {
    return void 0;
  }
  return toArray(target);
}
function reportUnhandledExceptionOnInvocation(originalError, currentError, id) {
  if (!IS_PRODUCTION) {
    var originalStackTrace = originalError.stack ? " Stacktrace was '".concat(originalError.stack, "'") : "";
    if (originalError === currentError) {
      console.error("Missing onError handler for invocation '".concat(id, "', error was '").concat(originalError, "'.").concat(originalStackTrace));
    } else {
      var stackTrace = currentError.stack ? " Stacktrace was '".concat(currentError.stack, "'") : "";
      console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(id, "'. ") + "Original error: '".concat(originalError, "'. ").concat(originalStackTrace, " Current error is '").concat(currentError, "'.").concat(stackTrace));
    }
  }
}
function evaluateGuard(machine, guard, context, _event, state) {
  var guards = machine.options.guards;
  var guardMeta = {
    state,
    cond: guard,
    _event
  };
  if (guard.type === DEFAULT_GUARD_TYPE) {
    return ((guards === null || guards === void 0 ? void 0 : guards[guard.name]) || guard.predicate)(context, _event.data, guardMeta);
  }
  var condFn = guards === null || guards === void 0 ? void 0 : guards[guard.type];
  if (!condFn) {
    throw new Error("Guard '".concat(guard.type, "' is not implemented on machine '").concat(machine.id, "'."));
  }
  return condFn(context, _event.data, guardMeta);
}
function toInvokeSource(src) {
  if (typeof src === "string") {
    return {
      type: src
    };
  }
  return src;
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  if (typeof nextHandler === "object") {
    return nextHandler;
  }
  var noop = function() {
    return void 0;
  };
  return {
    next: nextHandler,
    error: errorHandler || noop,
    complete: completionHandler || noop
  };
}
function createInvokeId(stateNodeId, index2) {
  return "".concat(stateNodeId, ":invocation[").concat(index2, "]");
}

// node_modules/xstate/es/actions.js
var initEvent = toSCXMLEvent({
  type: init
});
function getActionFunction(actionType, actionFunctionMap) {
  return actionFunctionMap ? actionFunctionMap[actionType] || void 0 : void 0;
}
function toActionObject(action, actionFunctionMap) {
  var actionObject;
  if (isString(action) || typeof action === "number") {
    var exec = getActionFunction(action, actionFunctionMap);
    if (isFunction(exec)) {
      actionObject = {
        type: action,
        exec
      };
    } else if (exec) {
      actionObject = exec;
    } else {
      actionObject = {
        type: action,
        exec: void 0
      };
    }
  } else if (isFunction(action)) {
    actionObject = {
      type: action.name || action.toString(),
      exec: action
    };
  } else {
    var exec = getActionFunction(action.type, actionFunctionMap);
    if (isFunction(exec)) {
      actionObject = __assign(__assign({}, action), {
        exec
      });
    } else if (exec) {
      var actionType = exec.type || action.type;
      actionObject = __assign(__assign(__assign({}, exec), action), {
        type: actionType
      });
    } else {
      actionObject = action;
    }
  }
  return actionObject;
}
var toActionObjects = function(action, actionFunctionMap) {
  if (!action) {
    return [];
  }
  var actions = isArray(action) ? action : [action];
  return actions.map(function(subAction) {
    return toActionObject(subAction, actionFunctionMap);
  });
};
function toActivityDefinition(action) {
  var actionObject = toActionObject(action);
  return __assign(__assign({
    id: isString(action) ? action : actionObject.id
  }, actionObject), {
    type: actionObject.type
  });
}
function raise2(event2) {
  if (!isString(event2)) {
    return send2(event2, {
      to: SpecialTargets.Internal
    });
  }
  return {
    type: raise,
    event: event2
  };
}
function resolveRaise(action) {
  return {
    type: raise,
    _event: toSCXMLEvent(action.event)
  };
}
function send2(event2, options) {
  return {
    to: options ? options.to : void 0,
    type: send,
    event: isFunction(event2) ? event2 : toEventObject(event2),
    delay: options ? options.delay : void 0,
    id: options && options.id !== void 0 ? options.id : isFunction(event2) ? event2.name : getEventType(event2)
  };
}
function resolveSend(action, ctx, _event, delaysMap) {
  var meta = {
    _event
  };
  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;
  if (isString(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }
  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;
  return __assign(__assign({}, action), {
    to: resolvedTarget,
    _event: resolvedEvent,
    event: resolvedEvent.data,
    delay: resolvedDelay
  });
}
var resolveLog = function(action, ctx, _event) {
  return __assign(__assign({}, action), {
    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {
      _event
    })
  });
};
var cancel2 = function(sendId) {
  return {
    type: cancel,
    sendId
  };
};
function start2(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: ActionTypes.Start,
    activity: activityDef,
    exec: void 0
  };
}
function stop2(actorRef) {
  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);
  return {
    type: ActionTypes.Stop,
    activity,
    exec: void 0
  };
}
function resolveStop(action, context, _event) {
  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;
  var resolvedActorRef = typeof actorRefOrString === "string" ? {
    id: actorRefOrString
  } : actorRefOrString;
  var actionObject = {
    type: ActionTypes.Stop,
    activity: resolvedActorRef
  };
  return actionObject;
}
function after2(delayRef, id) {
  var idSuffix = id ? "#".concat(id) : "";
  return "".concat(ActionTypes.After, "(").concat(delayRef, ")").concat(idSuffix);
}
function done(id, data) {
  var type2 = "".concat(ActionTypes.DoneState, ".").concat(id);
  var eventObject = {
    type: type2,
    data
  };
  eventObject.toString = function() {
    return type2;
  };
  return eventObject;
}
function doneInvoke(id, data) {
  var type2 = "".concat(ActionTypes.DoneInvoke, ".").concat(id);
  var eventObject = {
    type: type2,
    data
  };
  eventObject.toString = function() {
    return type2;
  };
  return eventObject;
}
function error2(id, data) {
  var type2 = "".concat(ActionTypes.ErrorPlatform, ".").concat(id);
  var eventObject = {
    type: type2,
    data
  };
  eventObject.toString = function() {
    return type2;
  };
  return eventObject;
}
function resolveActions(machine, currentState, currentContext, _event, actions, preserveActionOrder) {
  if (preserveActionOrder === void 0) {
    preserveActionOrder = false;
  }
  var _a2 = __read(preserveActionOrder ? [[], actions] : partition(actions, function(action) {
    return action.type === assign;
  }), 2), assignActions = _a2[0], otherActions = _a2[1];
  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;
  var preservedContexts = preserveActionOrder ? [currentContext] : void 0;
  var resolvedActions = flatten(otherActions.map(function(actionObject) {
    var _a3;
    switch (actionObject.type) {
      case raise:
        return resolveRaise(actionObject);
      case send:
        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays);
        if (!IS_PRODUCTION) {
          warn(!isString(actionObject.delay) || typeof sendAction.delay === "number", "No delay reference for delay expression '".concat(actionObject.delay, "' was found on machine '").concat(machine.id, "'"));
        }
        return sendAction;
      case log:
        return resolveLog(actionObject, updatedContext, _event);
      case choose: {
        var chooseAction = actionObject;
        var matchedActions = (_a3 = chooseAction.conds.find(function(condition) {
          var guard = toGuard(condition.cond, machine.options.guards);
          return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);
        })) === null || _a3 === void 0 ? void 0 : _a3.actions;
        if (!matchedActions) {
          return [];
        }
        var _b = __read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions), preserveActionOrder), 2), resolvedActionsFromChoose = _b[0], resolvedContextFromChoose = _b[1];
        updatedContext = resolvedContextFromChoose;
        preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
        return resolvedActionsFromChoose;
      }
      case pure: {
        var matchedActions = actionObject.get(updatedContext, _event.data);
        if (!matchedActions) {
          return [];
        }
        var _c = __read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions), preserveActionOrder), 2), resolvedActionsFromPure = _c[0], resolvedContext = _c[1];
        updatedContext = resolvedContext;
        preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
        return resolvedActionsFromPure;
      }
      case stop: {
        return resolveStop(actionObject, updatedContext, _event);
      }
      case assign: {
        updatedContext = updateContext(updatedContext, _event, [actionObject], currentState);
        preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
        break;
      }
      default:
        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);
        var exec_1 = resolvedActionObject.exec;
        if (exec_1 && preservedContexts) {
          var contextIndex_1 = preservedContexts.length - 1;
          resolvedActionObject = __assign(__assign({}, resolvedActionObject), {
            exec: function(_ctx) {
              var args = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }
              exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));
            }
          });
        }
        return resolvedActionObject;
    }
  }).filter(function(a5) {
    return !!a5;
  }));
  return [resolvedActions, updatedContext];
}

// node_modules/xstate/es/serviceScope.js
var serviceStack = [];
var provide = function(service, fn) {
  serviceStack.push(service);
  var result = fn(service);
  serviceStack.pop();
  return result;
};

// node_modules/xstate/es/Actor.js
function createNullActor(id) {
  var _a2;
  return _a2 = {
    id,
    send: function() {
      return void 0;
    },
    subscribe: function() {
      return {
        unsubscribe: function() {
          return void 0;
        }
      };
    },
    getSnapshot: function() {
      return void 0;
    },
    toJSON: function() {
      return {
        id
      };
    }
  }, _a2[symbolObservable] = function() {
    return this;
  }, _a2;
}
function createInvocableActor(invokeDefinition, machine, context, _event) {
  var _a2;
  var invokeSrc = toInvokeSource(invokeDefinition.src);
  var serviceCreator = (_a2 = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a2 === void 0 ? void 0 : _a2[invokeSrc.type];
  var resolvedData = invokeDefinition.data ? mapContext(invokeDefinition.data, context, _event) : void 0;
  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id);
  tempActor.meta = invokeDefinition;
  return tempActor;
}
function createDeferredActor(entity, id, data) {
  var tempActor = createNullActor(id);
  tempActor.deferred = true;
  if (isMachine(entity)) {
    var initialState_1 = tempActor.state = provide(void 0, function() {
      return (data ? entity.withContext(data) : entity).initialState;
    });
    tempActor.getSnapshot = function() {
      return initialState_1;
    };
  }
  return tempActor;
}
function isActor2(item) {
  try {
    return typeof item.send === "function";
  } catch (e5) {
    return false;
  }
}
function isSpawnedActor(item) {
  return isActor2(item) && "id" in item;
}
function toActorRef(actorRefLike) {
  var _a2;
  return __assign((_a2 = {
    subscribe: function() {
      return {
        unsubscribe: function() {
          return void 0;
        }
      };
    },
    id: "anonymous",
    getSnapshot: function() {
      return void 0;
    }
  }, _a2[symbolObservable] = function() {
    return this;
  }, _a2), actorRefLike);
}

// node_modules/xstate/es/stateUtils.js
var isLeafNode = function(stateNode) {
  return stateNode.type === "atomic" || stateNode.type === "final";
};
function getChildren(stateNode) {
  return Object.keys(stateNode.states).map(function(key) {
    return stateNode.states[key];
  }).filter(function(sn) {
    return sn.type !== "history";
  });
}
function getAllStateNodes(stateNode) {
  var stateNodes = [stateNode];
  if (isLeafNode(stateNode)) {
    return stateNodes;
  }
  return stateNodes.concat(flatten(getChildren(stateNode).map(getAllStateNodes)));
}
function getConfiguration(prevStateNodes, stateNodes) {
  var e_1, _a2, e_2, _b, e_3, _c, e_4, _d;
  var prevConfiguration = new Set(prevStateNodes);
  var prevAdjList = getAdjList(prevConfiguration);
  var configuration = new Set(stateNodes);
  try {
    for (var configuration_1 = __values(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
      var s5 = configuration_1_1.value;
      var m4 = s5.parent;
      while (m4 && !configuration.has(m4)) {
        configuration.add(m4);
        m4 = m4.parent;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (configuration_1_1 && !configuration_1_1.done && (_a2 = configuration_1.return))
        _a2.call(configuration_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var adjList = getAdjList(configuration);
  try {
    for (var configuration_2 = __values(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
      var s5 = configuration_2_1.value;
      if (s5.type === "compound" && (!adjList.get(s5) || !adjList.get(s5).length)) {
        if (prevAdjList.get(s5)) {
          prevAdjList.get(s5).forEach(function(sn) {
            return configuration.add(sn);
          });
        } else {
          s5.initialStateNodes.forEach(function(sn) {
            return configuration.add(sn);
          });
        }
      } else {
        if (s5.type === "parallel") {
          try {
            for (var _e = (e_3 = void 0, __values(getChildren(s5))), _f = _e.next(); !_f.done; _f = _e.next()) {
              var child = _f.value;
              if (!configuration.has(child)) {
                configuration.add(child);
                if (prevAdjList.get(child)) {
                  prevAdjList.get(child).forEach(function(sn) {
                    return configuration.add(sn);
                  });
                } else {
                  child.initialStateNodes.forEach(function(sn) {
                    return configuration.add(sn);
                  });
                }
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_f && !_f.done && (_c = _e.return))
                _c.call(_e);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        }
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return))
        _b.call(configuration_2);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  try {
    for (var configuration_3 = __values(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
      var s5 = configuration_3_1.value;
      var m4 = s5.parent;
      while (m4 && !configuration.has(m4)) {
        configuration.add(m4);
        m4 = m4.parent;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return))
        _d.call(configuration_3);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return configuration;
}
function getValueFromAdj(baseNode, adjList) {
  var childStateNodes = adjList.get(baseNode);
  if (!childStateNodes) {
    return {};
  }
  if (baseNode.type === "compound") {
    var childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isLeafNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }
  var stateValue = {};
  childStateNodes.forEach(function(csn) {
    stateValue[csn.key] = getValueFromAdj(csn, adjList);
  });
  return stateValue;
}
function getAdjList(configuration) {
  var e_5, _a2;
  var adjList = /* @__PURE__ */ new Map();
  try {
    for (var configuration_4 = __values(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
      var s5 = configuration_4_1.value;
      if (!adjList.has(s5)) {
        adjList.set(s5, []);
      }
      if (s5.parent) {
        if (!adjList.has(s5.parent)) {
          adjList.set(s5.parent, []);
        }
        adjList.get(s5.parent).push(s5);
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (configuration_4_1 && !configuration_4_1.done && (_a2 = configuration_4.return))
        _a2.call(configuration_4);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return adjList;
}
function getValue(rootNode, configuration) {
  var config = getConfiguration([rootNode], configuration);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function has(iterable, item) {
  if (Array.isArray(iterable)) {
    return iterable.some(function(member) {
      return member === item;
    });
  }
  if (iterable instanceof Set) {
    return iterable.has(item);
  }
  return false;
}
function nextEvents(configuration) {
  return __spreadArray([], __read(new Set(flatten(__spreadArray([], __read(configuration.map(function(sn) {
    return sn.ownEvents;
  })), false)))), false);
}
function isInFinalState(configuration, stateNode) {
  if (stateNode.type === "compound") {
    return getChildren(stateNode).some(function(s5) {
      return s5.type === "final" && has(configuration, s5);
    });
  }
  if (stateNode.type === "parallel") {
    return getChildren(stateNode).every(function(sn) {
      return isInFinalState(configuration, sn);
    });
  }
  return false;
}
function getMeta(configuration) {
  if (configuration === void 0) {
    configuration = [];
  }
  return configuration.reduce(function(acc, stateNode) {
    if (stateNode.meta !== void 0) {
      acc[stateNode.id] = stateNode.meta;
    }
    return acc;
  }, {});
}
function getTagsFromConfiguration(configuration) {
  return new Set(flatten(configuration.map(function(sn) {
    return sn.tags;
  })));
}

// node_modules/xstate/es/State.js
function stateValuesEqual(a5, b4) {
  if (a5 === b4) {
    return true;
  }
  if (a5 === void 0 || b4 === void 0) {
    return false;
  }
  if (isString(a5) || isString(b4)) {
    return a5 === b4;
  }
  var aKeys = Object.keys(a5);
  var bKeys = Object.keys(b4);
  return aKeys.length === bKeys.length && aKeys.every(function(key) {
    return stateValuesEqual(a5[key], b4[key]);
  });
}
function isStateConfig(state) {
  if (typeof state !== "object" || state === null) {
    return false;
  }
  return "value" in state && "_event" in state;
}
function bindActionToState(action, state) {
  var exec = action.exec;
  var boundAction = __assign(__assign({}, action), {
    exec: exec !== void 0 ? function() {
      return exec(state.context, state.event, {
        action,
        state,
        _event: state._event
      });
    } : void 0
  });
  return boundAction;
}
var State = function() {
  function State2(config) {
    var _this = this;
    var _a2;
    this.actions = [];
    this.activities = EMPTY_ACTIVITY_MAP;
    this.meta = {};
    this.events = [];
    this.value = config.value;
    this.context = config.context;
    this._event = config._event;
    this._sessionid = config._sessionid;
    this.event = this._event.data;
    this.historyValue = config.historyValue;
    this.history = config.history;
    this.actions = config.actions || [];
    this.activities = config.activities || EMPTY_ACTIVITY_MAP;
    this.meta = getMeta(config.configuration);
    this.events = config.events || [];
    this.matches = this.matches.bind(this);
    this.toStrings = this.toStrings.bind(this);
    this.configuration = config.configuration;
    this.transitions = config.transitions;
    this.children = config.children;
    this.done = !!config.done;
    this.tags = (_a2 = Array.isArray(config.tags) ? new Set(config.tags) : config.tags) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Set();
    this.machine = config.machine;
    Object.defineProperty(this, "nextEvents", {
      get: function() {
        return nextEvents(_this.configuration);
      }
    });
  }
  State2.from = function(stateValue, context) {
    if (stateValue instanceof State2) {
      if (stateValue.context !== context) {
        return new State2({
          value: stateValue.value,
          context,
          _event: stateValue._event,
          _sessionid: null,
          historyValue: stateValue.historyValue,
          history: stateValue.history,
          actions: [],
          activities: stateValue.activities,
          meta: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        });
      }
      return stateValue;
    }
    var _event = initEvent;
    return new State2({
      value: stateValue,
      context,
      _event,
      _sessionid: null,
      historyValue: void 0,
      history: void 0,
      actions: [],
      activities: void 0,
      meta: void 0,
      events: [],
      configuration: [],
      transitions: [],
      children: {}
    });
  };
  State2.create = function(config) {
    return new State2(config);
  };
  State2.inert = function(stateValue, context) {
    if (stateValue instanceof State2) {
      if (!stateValue.actions.length) {
        return stateValue;
      }
      var _event = initEvent;
      return new State2({
        value: stateValue.value,
        context,
        _event,
        _sessionid: null,
        historyValue: stateValue.historyValue,
        history: stateValue.history,
        activities: stateValue.activities,
        configuration: stateValue.configuration,
        transitions: [],
        children: {}
      });
    }
    return State2.from(stateValue, context);
  };
  State2.prototype.toStrings = function(stateValue, delimiter) {
    var _this = this;
    if (stateValue === void 0) {
      stateValue = this.value;
    }
    if (delimiter === void 0) {
      delimiter = ".";
    }
    if (isString(stateValue)) {
      return [stateValue];
    }
    var valueKeys = Object.keys(stateValue);
    return valueKeys.concat.apply(valueKeys, __spreadArray([], __read(valueKeys.map(function(key) {
      return _this.toStrings(stateValue[key], delimiter).map(function(s5) {
        return key + delimiter + s5;
      });
    })), false));
  };
  State2.prototype.toJSON = function() {
    var _a2 = this;
    _a2.configuration;
    _a2.transitions;
    var tags = _a2.tags;
    _a2.machine;
    var jsonValues = __rest(_a2, ["configuration", "transitions", "tags", "machine"]);
    return __assign(__assign({}, jsonValues), {
      tags: Array.from(tags)
    });
  };
  State2.prototype.matches = function(parentStateValue) {
    return matchesState(parentStateValue, this.value);
  };
  State2.prototype.hasTag = function(tag) {
    return this.tags.has(tag);
  };
  State2.prototype.can = function(event2) {
    var _a2;
    if (IS_PRODUCTION) {
      warn(!!this.machine, "state.can(...) used outside of a machine-created State object; this will always return false.");
    }
    var transitionData = (_a2 = this.machine) === null || _a2 === void 0 ? void 0 : _a2.getTransitionData(this, event2);
    return !!(transitionData === null || transitionData === void 0 ? void 0 : transitionData.transitions.length) && transitionData.transitions.some(function(t5) {
      return t5.target !== void 0 || t5.actions.length;
    });
  };
  return State2;
}();

// node_modules/xstate/es/scheduler.js
var defaultOptions = {
  deferEvents: false
};
var Scheduler = function() {
  function Scheduler2(options) {
    this.processingEvent = false;
    this.queue = [];
    this.initialized = false;
    this.options = __assign(__assign({}, defaultOptions), options);
  }
  Scheduler2.prototype.initialize = function(callback) {
    this.initialized = true;
    if (callback) {
      if (!this.options.deferEvents) {
        this.schedule(callback);
        return;
      }
      this.process(callback);
    }
    this.flushEvents();
  };
  Scheduler2.prototype.schedule = function(task) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(task);
      return;
    }
    if (this.queue.length !== 0) {
      throw new Error("Event queue should be empty when it is not processing events");
    }
    this.process(task);
    this.flushEvents();
  };
  Scheduler2.prototype.clear = function() {
    this.queue = [];
  };
  Scheduler2.prototype.flushEvents = function() {
    var nextCallback = this.queue.shift();
    while (nextCallback) {
      this.process(nextCallback);
      nextCallback = this.queue.shift();
    }
  };
  Scheduler2.prototype.process = function(callback) {
    this.processingEvent = true;
    try {
      callback();
    } catch (e5) {
      this.clear();
      throw e5;
    } finally {
      this.processingEvent = false;
    }
  };
  return Scheduler2;
}();

// node_modules/xstate/es/registry.js
var children = /* @__PURE__ */ new Map();
var sessionIdIndex = 0;
var registry = {
  bookId: function() {
    return "x:".concat(sessionIdIndex++);
  },
  register: function(id, actor) {
    children.set(id, actor);
    return id;
  },
  get: function(id) {
    return children.get(id);
  },
  free: function(id) {
    children.delete(id);
  }
};

// node_modules/xstate/es/devTools.js
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (!IS_PRODUCTION) {
    console.warn("XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues");
  }
}
function getDevTools() {
  var global2 = getGlobal();
  if (global2 && "__xstate__" in global2) {
    return global2.__xstate__;
  }
  return void 0;
}
function registerService(service) {
  if (!getGlobal()) {
    return;
  }
  var devTools = getDevTools();
  if (devTools) {
    devTools.register(service);
  }
}

// node_modules/xstate/es/behaviors.js
function spawnBehavior(behavior, options) {
  if (options === void 0) {
    options = {};
  }
  var state = behavior.initialState;
  var observers2 = /* @__PURE__ */ new Set();
  var mailbox = [];
  var flushing = false;
  var flush = function() {
    if (flushing) {
      return;
    }
    flushing = true;
    while (mailbox.length > 0) {
      var event_1 = mailbox.shift();
      state = behavior.transition(state, event_1, actorCtx);
      observers2.forEach(function(observer) {
        return observer.next(state);
      });
    }
    flushing = false;
  };
  var actor = toActorRef({
    id: options.id,
    send: function(event2) {
      mailbox.push(event2);
      flush();
    },
    getSnapshot: function() {
      return state;
    },
    subscribe: function(next, handleError, complete) {
      var observer = toObserver(next, handleError, complete);
      observers2.add(observer);
      observer.next(state);
      return {
        unsubscribe: function() {
          observers2.delete(observer);
        }
      };
    }
  });
  var actorCtx = {
    parent: options.parent,
    self: actor,
    id: options.id || "anonymous",
    observers: observers2
  };
  state = behavior.start ? behavior.start(actorCtx) : state;
  return actor;
}

// node_modules/xstate/es/interpreter.js
var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
var InterpreterStatus;
(function(InterpreterStatus2) {
  InterpreterStatus2[InterpreterStatus2["NotStarted"] = 0] = "NotStarted";
  InterpreterStatus2[InterpreterStatus2["Running"] = 1] = "Running";
  InterpreterStatus2[InterpreterStatus2["Stopped"] = 2] = "Stopped";
})(InterpreterStatus || (InterpreterStatus = {}));
var Interpreter = function() {
  function Interpreter2(machine, options) {
    var _this = this;
    if (options === void 0) {
      options = Interpreter2.defaultOptions;
    }
    this.machine = machine;
    this.delayedEventsMap = {};
    this.listeners = /* @__PURE__ */ new Set();
    this.contextListeners = /* @__PURE__ */ new Set();
    this.stopListeners = /* @__PURE__ */ new Set();
    this.doneListeners = /* @__PURE__ */ new Set();
    this.eventListeners = /* @__PURE__ */ new Set();
    this.sendListeners = /* @__PURE__ */ new Set();
    this.initialized = false;
    this.status = InterpreterStatus.NotStarted;
    this.children = /* @__PURE__ */ new Map();
    this.forwardTo = /* @__PURE__ */ new Set();
    this.init = this.start;
    this.send = function(event2, payload) {
      if (isArray(event2)) {
        _this.batch(event2);
        return _this.state;
      }
      var _event = toSCXMLEvent(toEventObject(event2, payload));
      if (_this.status === InterpreterStatus.Stopped) {
        if (!IS_PRODUCTION) {
          warn(false, 'Event "'.concat(_event.name, '" was sent to stopped service "').concat(_this.machine.id, '". This service has already reached its final state, and will not transition.\nEvent: ').concat(JSON.stringify(_event.data)));
        }
        return _this.state;
      }
      if (_this.status !== InterpreterStatus.Running && !_this.options.deferEvents) {
        throw new Error('Event "'.concat(_event.name, '" was sent to uninitialized service "').concat(_this.machine.id, '". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ').concat(JSON.stringify(_event.data)));
      }
      _this.scheduler.schedule(function() {
        _this.forward(_event);
        var nextState = _this.nextState(_event);
        _this.update(nextState, _event);
      });
      return _this._state;
    };
    this.sendTo = function(event2, to) {
      var isParent = _this.parent && (to === SpecialTargets.Parent || _this.parent.id === to);
      var target = isParent ? _this.parent : isString(to) ? _this.children.get(to) || registry.get(to) : isActor(to) ? to : void 0;
      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '".concat(to, "' from service '").concat(_this.id, "'."));
        }
        if (!IS_PRODUCTION) {
          warn(false, "Service '".concat(_this.id, "' has no parent: unable to send event ").concat(event2.type));
        }
        return;
      }
      if ("machine" in target) {
        target.send(__assign(__assign({}, event2), {
          name: event2.name === error ? "".concat(error2(_this.id)) : event2.name,
          origin: _this.sessionId
        }));
      } else {
        target.send(event2.data);
      }
    };
    var resolvedOptions = __assign(__assign({}, Interpreter2.defaultOptions), options);
    var clock = resolvedOptions.clock, logger = resolvedOptions.logger, parent = resolvedOptions.parent, id = resolvedOptions.id;
    var resolvedId = id !== void 0 ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.sessionId = registry.bookId();
  }
  Object.defineProperty(Interpreter2.prototype, "initialState", {
    get: function() {
      var _this = this;
      if (this._initialState) {
        return this._initialState;
      }
      return provide(this, function() {
        _this._initialState = _this.machine.initialState;
        return _this._initialState;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Interpreter2.prototype, "state", {
    get: function() {
      if (!IS_PRODUCTION) {
        warn(this.status !== InterpreterStatus.NotStarted, "Attempted to read state from uninitialized service '".concat(this.id, "'. Make sure the service is started first."));
      }
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  Interpreter2.prototype.execute = function(state, actionsConfig) {
    var e_1, _a2;
    try {
      for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  Interpreter2.prototype.update = function(state, _event) {
    var e_2, _a2, e_3, _b, e_4, _c, e_5, _d;
    var _this = this;
    state._sessionid = this.sessionId;
    this._state = state;
    if (this.options.execute) {
      this.execute(this.state);
    }
    this.children.forEach(function(child) {
      _this.state.children[child.id] = child;
    });
    if (this.devTools) {
      this.devTools.send(_event.data, state);
    }
    if (state.event) {
      try {
        for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a2 = _e.return))
            _a2.call(_e);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    try {
      for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return))
          _b.call(_g);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    try {
      for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : void 0);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return))
          _c.call(_j);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    var isDone = isInFinalState(state.configuration || [], this.machine);
    if (this.state.configuration && isDone) {
      var finalChildStateNode = state.configuration.find(function(sn) {
        return sn.type === "final" && sn.parent === _this.machine;
      });
      var doneData = finalChildStateNode && finalChildStateNode.doneData ? mapContext(finalChildStateNode.doneData, state.context, _event) : void 0;
      try {
        for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener(doneInvoke(this.id, doneData));
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return))
            _d.call(_l);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      this.stop();
    }
  };
  Interpreter2.prototype.onTransition = function(listener) {
    this.listeners.add(listener);
    if (this.status === InterpreterStatus.Running) {
      listener(this.state, this.state.event);
    }
    return this;
  };
  Interpreter2.prototype.subscribe = function(nextListenerOrObserver, _4, completeListener) {
    var _this = this;
    if (!nextListenerOrObserver) {
      return {
        unsubscribe: function() {
          return void 0;
        }
      };
    }
    var listener;
    var resolvedCompleteListener = completeListener;
    if (typeof nextListenerOrObserver === "function") {
      listener = nextListenerOrObserver;
    } else {
      listener = nextListenerOrObserver.next.bind(nextListenerOrObserver);
      resolvedCompleteListener = nextListenerOrObserver.complete.bind(nextListenerOrObserver);
    }
    this.listeners.add(listener);
    if (this.status !== InterpreterStatus.NotStarted) {
      listener(this.state);
    }
    if (resolvedCompleteListener) {
      if (this.status === InterpreterStatus.Stopped) {
        resolvedCompleteListener();
      } else {
        this.onDone(resolvedCompleteListener);
      }
    }
    return {
      unsubscribe: function() {
        listener && _this.listeners.delete(listener);
        resolvedCompleteListener && _this.doneListeners.delete(resolvedCompleteListener);
      }
    };
  };
  Interpreter2.prototype.onEvent = function(listener) {
    this.eventListeners.add(listener);
    return this;
  };
  Interpreter2.prototype.onSend = function(listener) {
    this.sendListeners.add(listener);
    return this;
  };
  Interpreter2.prototype.onChange = function(listener) {
    this.contextListeners.add(listener);
    return this;
  };
  Interpreter2.prototype.onStop = function(listener) {
    this.stopListeners.add(listener);
    return this;
  };
  Interpreter2.prototype.onDone = function(listener) {
    this.doneListeners.add(listener);
    return this;
  };
  Interpreter2.prototype.off = function(listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  Interpreter2.prototype.start = function(initialState) {
    var _this = this;
    if (this.status === InterpreterStatus.Running) {
      return this;
    }
    this.machine._init();
    registry.register(this.sessionId, this);
    this.initialized = true;
    this.status = InterpreterStatus.Running;
    var resolvedState = initialState === void 0 ? this.initialState : provide(this, function() {
      return isStateConfig(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(State.from(initialState, _this.machine.context));
    });
    if (this.options.devTools) {
      this.attachDev();
    }
    this.scheduler.initialize(function() {
      _this.update(resolvedState, initEvent);
    });
    return this;
  };
  Interpreter2.prototype.stop = function() {
    var e_6, _a2, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
    var _this = this;
    try {
      for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a2 = _f.return))
          _a2.call(_f);
      } finally {
        if (e_6)
          throw e_6.error;
      }
    }
    try {
      for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value;
        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return))
          _b.call(_h);
      } finally {
        if (e_7)
          throw e_7.error;
      }
    }
    try {
      for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return))
          _c.call(_k);
      } finally {
        if (e_8)
          throw e_8.error;
      }
    }
    try {
      for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return))
          _d.call(_m);
      } finally {
        if (e_9)
          throw e_9.error;
      }
    }
    if (!this.initialized) {
      return this;
    }
    __spreadArray([], __read(this.state.configuration), false).sort(function(a5, b4) {
      return b4.order - a5.order;
    }).forEach(function(stateNode) {
      var e_11, _a3;
      try {
        for (var _b2 = __values(stateNode.definition.exit), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var action = _c2.value;
          _this.exec(action, _this.state);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a3 = _b2.return))
            _a3.call(_b2);
        } finally {
          if (e_11)
            throw e_11.error;
        }
      }
    });
    this.children.forEach(function(child) {
      if (isFunction(child.stop)) {
        child.stop();
      }
    });
    this.children.clear();
    try {
      for (var _p = __values(Object.keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return))
          _e.call(_p);
      } finally {
        if (e_10)
          throw e_10.error;
      }
    }
    this.scheduler.clear();
    this.scheduler = new Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.initialized = false;
    this.status = InterpreterStatus.Stopped;
    this._initialState = void 0;
    registry.free(this.sessionId);
    return this;
  };
  Interpreter2.prototype.batch = function(events) {
    var _this = this;
    if (this.status === InterpreterStatus.NotStarted && this.options.deferEvents) {
      if (!IS_PRODUCTION) {
        warn(false, "".concat(events.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, '" and are deferred. Make sure .start() is called for this service.\nEvent: ').concat(JSON.stringify(event)));
      }
    } else if (this.status !== InterpreterStatus.Running) {
      throw new Error("".concat(events.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, '". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.'));
    }
    this.scheduler.schedule(function() {
      var e_12, _a2;
      var nextState = _this.state;
      var batchChanged = false;
      var batchedActions = [];
      var _loop_1 = function(event_12) {
        var _event = toSCXMLEvent(event_12);
        _this.forward(_event);
        nextState = provide(_this, function() {
          return _this.machine.transition(nextState, _event);
        });
        batchedActions.push.apply(batchedActions, __spreadArray([], __read(nextState.actions.map(function(a5) {
          return bindActionToState(a5, nextState);
        })), false));
        batchChanged = batchChanged || !!nextState.changed;
      };
      try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;
          _loop_1(event_1);
        }
      } catch (e_12_1) {
        e_12 = {
          error: e_12_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a2 = events_1.return))
            _a2.call(events_1);
        } finally {
          if (e_12)
            throw e_12.error;
        }
      }
      nextState.changed = batchChanged;
      nextState.actions = batchedActions;
      _this.update(nextState, toSCXMLEvent(events[events.length - 1]));
    });
  };
  Interpreter2.prototype.sender = function(event2) {
    return this.send.bind(this, event2);
  };
  Interpreter2.prototype.nextState = function(event2) {
    var _this = this;
    var _event = toSCXMLEvent(event2);
    if (_event.name.indexOf(errorPlatform) === 0 && !this.state.nextEvents.some(function(nextEvent) {
      return nextEvent.indexOf(errorPlatform) === 0;
    })) {
      throw _event.data.data;
    }
    var nextState = provide(this, function() {
      return _this.machine.transition(_this.state, _event);
    });
    return nextState;
  };
  Interpreter2.prototype.forward = function(event2) {
    var e_13, _a2;
    try {
      for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);
        if (!child) {
          throw new Error("Unable to forward event '".concat(event2, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(id, "'."));
        }
        child.send(event2);
      }
    } catch (e_13_1) {
      e_13 = {
        error: e_13_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_13)
          throw e_13.error;
      }
    }
  };
  Interpreter2.prototype.defer = function(sendAction) {
    var _this = this;
    this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function() {
      if (sendAction.to) {
        _this.sendTo(sendAction._event, sendAction.to);
      } else {
        _this.send(sendAction._event);
      }
    }, sendAction.delay);
  };
  Interpreter2.prototype.cancel = function(sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };
  Interpreter2.prototype.exec = function(action, state, actionFunctionMap) {
    if (actionFunctionMap === void 0) {
      actionFunctionMap = this.machine.options.actions;
    }
    var context = state.context, _event = state._event;
    var actionOrExec = action.exec || getActionFunction(action.type, actionFunctionMap);
    var exec = isFunction(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;
    if (exec) {
      try {
        return exec(context, _event.data, {
          action,
          state: this.state,
          _event
        });
      } catch (err) {
        if (this.parent) {
          this.parent.send({
            type: "xstate.error",
            data: err
          });
        }
        throw err;
      }
    }
    switch (action.type) {
      case send:
        var sendAction = action;
        if (typeof sendAction.delay === "number") {
          this.defer(sendAction);
          return;
        } else {
          if (sendAction.to) {
            this.sendTo(sendAction._event, sendAction.to);
          } else {
            this.send(sendAction._event);
          }
        }
        break;
      case cancel:
        this.cancel(action.sendId);
        break;
      case start: {
        if (this.status !== InterpreterStatus.Running) {
          return;
        }
        var activity = action.activity;
        if (!this.state.activities[activity.id || activity.type]) {
          break;
        }
        if (activity.type === ActionTypes.Invoke) {
          var invokeSource = toInvokeSource(activity.src);
          var serviceCreator = this.machine.options.services ? this.machine.options.services[invokeSource.type] : void 0;
          var id = activity.id, data = activity.data;
          if (!IS_PRODUCTION) {
            warn(!("forward" in activity), "`forward` property is deprecated (found in invocation of '".concat(activity.src, "' in in machine '").concat(this.machine.id, "'). ") + "Please use `autoForward` instead.");
          }
          var autoForward = "autoForward" in activity ? activity.autoForward : !!activity.forward;
          if (!serviceCreator) {
            if (!IS_PRODUCTION) {
              warn(false, "No service found for invocation '".concat(activity.src, "' in machine '").concat(this.machine.id, "'."));
            }
            return;
          }
          var resolvedData = data ? mapContext(data, context, _event) : void 0;
          if (typeof serviceCreator === "string") {
            return;
          }
          var source = isFunction(serviceCreator) ? serviceCreator(context, _event.data, {
            data: resolvedData,
            src: invokeSource,
            meta: activity.meta
          }) : serviceCreator;
          if (!source) {
            return;
          }
          var options = void 0;
          if (isMachine(source)) {
            source = resolvedData ? source.withContext(resolvedData) : source;
            options = {
              autoForward
            };
          }
          this.spawn(source, id, options);
        } else {
          this.spawnActivity(activity);
        }
        break;
      }
      case stop: {
        this.stopChild(action.activity.id);
        break;
      }
      case log:
        var label = action.label, value = action.value;
        if (label) {
          this.logger(label, value);
        } else {
          this.logger(value);
        }
        break;
      default:
        if (!IS_PRODUCTION) {
          warn(false, "No implementation found for action type '".concat(action.type, "'"));
        }
        break;
    }
    return void 0;
  };
  Interpreter2.prototype.removeChild = function(childId) {
    var _a2;
    this.children.delete(childId);
    this.forwardTo.delete(childId);
    (_a2 = this.state) === null || _a2 === void 0 ? true : delete _a2.children[childId];
  };
  Interpreter2.prototype.stopChild = function(childId) {
    var child = this.children.get(childId);
    if (!child) {
      return;
    }
    this.removeChild(childId);
    if (isFunction(child.stop)) {
      child.stop();
    }
  };
  Interpreter2.prototype.spawn = function(entity, name, options) {
    if (isPromiseLike(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if (isFunction(entity)) {
      return this.spawnCallback(entity, name);
    } else if (isSpawnedActor(entity)) {
      return this.spawnActor(entity, name);
    } else if (isObservable(entity)) {
      return this.spawnObservable(entity, name);
    } else if (isMachine(entity)) {
      return this.spawnMachine(entity, __assign(__assign({}, options), {
        id: name
      }));
    } else if (isBehavior(entity)) {
      return this.spawnBehavior(entity, name);
    } else {
      throw new Error('Unable to spawn entity "'.concat(name, '" of type "').concat(typeof entity, '".'));
    }
  };
  Interpreter2.prototype.spawnMachine = function(machine, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    var childService = new Interpreter2(machine, __assign(__assign({}, this.options), {
      parent: this,
      id: options.id || machine.id
    }));
    var resolvedOptions = __assign(__assign({}, DEFAULT_SPAWN_OPTIONS), options);
    if (resolvedOptions.sync) {
      childService.onTransition(function(state) {
        _this.send(update, {
          state,
          id: childService.id
        });
      });
    }
    var actor = childService;
    this.children.set(childService.id, actor);
    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }
    childService.onDone(function(doneEvent) {
      _this.removeChild(childService.id);
      _this.send(toSCXMLEvent(doneEvent, {
        origin: childService.id
      }));
    }).start();
    return actor;
  };
  Interpreter2.prototype.spawnBehavior = function(behavior, id) {
    var actorRef = spawnBehavior(behavior, {
      id,
      parent: this
    });
    this.children.set(id, actorRef);
    return actorRef;
  };
  Interpreter2.prototype.spawnPromise = function(promise, id) {
    var _a2;
    var _this = this;
    var canceled = false;
    var resolvedData;
    promise.then(function(response) {
      if (!canceled) {
        resolvedData = response;
        _this.removeChild(id);
        _this.send(toSCXMLEvent(doneInvoke(id, response), {
          origin: id
        }));
      }
    }, function(errorData) {
      if (!canceled) {
        _this.removeChild(id);
        var errorEvent = error2(id, errorData);
        try {
          _this.send(toSCXMLEvent(errorEvent, {
            origin: id
          }));
        } catch (error3) {
          reportUnhandledExceptionOnInvocation(errorData, error3, id);
          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }
          if (_this.machine.strict) {
            _this.stop();
          }
        }
      }
    });
    var actor = (_a2 = {
      id,
      send: function() {
        return void 0;
      },
      subscribe: function(next, handleError, complete) {
        var observer = toObserver(next, handleError, complete);
        var unsubscribed = false;
        promise.then(function(response) {
          if (unsubscribed) {
            return;
          }
          observer.next(response);
          if (unsubscribed) {
            return;
          }
          observer.complete();
        }, function(err) {
          if (unsubscribed) {
            return;
          }
          observer.error(err);
        });
        return {
          unsubscribe: function() {
            return unsubscribed = true;
          }
        };
      },
      stop: function() {
        canceled = true;
      },
      toJSON: function() {
        return {
          id
        };
      },
      getSnapshot: function() {
        return resolvedData;
      }
    }, _a2[symbolObservable] = function() {
      return this;
    }, _a2);
    this.children.set(id, actor);
    return actor;
  };
  Interpreter2.prototype.spawnCallback = function(callback, id) {
    var _a2;
    var _this = this;
    var canceled = false;
    var receivers = /* @__PURE__ */ new Set();
    var listeners = /* @__PURE__ */ new Set();
    var emitted;
    var receive = function(e5) {
      emitted = e5;
      listeners.forEach(function(listener) {
        return listener(e5);
      });
      if (canceled) {
        return;
      }
      _this.send(toSCXMLEvent(e5, {
        origin: id
      }));
    };
    var callbackStop;
    try {
      callbackStop = callback(receive, function(newListener) {
        receivers.add(newListener);
      });
    } catch (err) {
      this.send(error2(id, err));
    }
    if (isPromiseLike(callbackStop)) {
      return this.spawnPromise(callbackStop, id);
    }
    var actor = (_a2 = {
      id,
      send: function(event2) {
        return receivers.forEach(function(receiver) {
          return receiver(event2);
        });
      },
      subscribe: function(next) {
        var observer = toObserver(next);
        listeners.add(observer.next);
        return {
          unsubscribe: function() {
            listeners.delete(observer.next);
          }
        };
      },
      stop: function() {
        canceled = true;
        if (isFunction(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function() {
        return {
          id
        };
      },
      getSnapshot: function() {
        return emitted;
      }
    }, _a2[symbolObservable] = function() {
      return this;
    }, _a2);
    this.children.set(id, actor);
    return actor;
  };
  Interpreter2.prototype.spawnObservable = function(source, id) {
    var _a2;
    var _this = this;
    var emitted;
    var subscription = source.subscribe(function(value) {
      emitted = value;
      _this.send(toSCXMLEvent(value, {
        origin: id
      }));
    }, function(err) {
      _this.removeChild(id);
      _this.send(toSCXMLEvent(error2(id, err), {
        origin: id
      }));
    }, function() {
      _this.removeChild(id);
      _this.send(toSCXMLEvent(doneInvoke(id), {
        origin: id
      }));
    });
    var actor = (_a2 = {
      id,
      send: function() {
        return void 0;
      },
      subscribe: function(next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function() {
        return subscription.unsubscribe();
      },
      getSnapshot: function() {
        return emitted;
      },
      toJSON: function() {
        return {
          id
        };
      }
    }, _a2[symbolObservable] = function() {
      return this;
    }, _a2);
    this.children.set(id, actor);
    return actor;
  };
  Interpreter2.prototype.spawnActor = function(actor, name) {
    this.children.set(name, actor);
    return actor;
  };
  Interpreter2.prototype.spawnActivity = function(activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : void 0;
    if (!implementation) {
      if (!IS_PRODUCTION) {
        warn(false, "No implementation found for activity '".concat(activity.type, "'"));
      }
      return;
    }
    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };
  Interpreter2.prototype.spawnEffect = function(id, dispose) {
    var _a2;
    this.children.set(id, (_a2 = {
      id,
      send: function() {
        return void 0;
      },
      subscribe: function() {
        return {
          unsubscribe: function() {
            return void 0;
          }
        };
      },
      stop: dispose || void 0,
      getSnapshot: function() {
        return void 0;
      },
      toJSON: function() {
        return {
          id
        };
      }
    }, _a2[symbolObservable] = function() {
      return this;
    }, _a2));
  };
  Interpreter2.prototype.attachDev = function() {
    var global2 = getGlobal();
    if (this.options.devTools && global2) {
      if (global2.__REDUX_DEVTOOLS_EXTENSION__) {
        var devToolsOptions = typeof this.options.devTools === "object" ? this.options.devTools : void 0;
        this.devTools = global2.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign(__assign({
          name: this.id,
          autoPause: true,
          stateSanitizer: function(state) {
            return {
              value: state.value,
              context: state.context,
              actions: state.actions
            };
          }
        }, devToolsOptions), {
          features: __assign({
            jump: false,
            skip: false
          }, devToolsOptions ? devToolsOptions.features : void 0)
        }), this.machine);
        this.devTools.init(this.state);
      }
      registerService(this);
    }
  };
  Interpreter2.prototype.toJSON = function() {
    return {
      id: this.id
    };
  };
  Interpreter2.prototype[symbolObservable] = function() {
    return this;
  };
  Interpreter2.prototype.getSnapshot = function() {
    if (this.status === InterpreterStatus.NotStarted) {
      return this.initialState;
    }
    return this._state;
  };
  Interpreter2.defaultOptions = {
    execute: true,
    deferEvents: true,
    clock: {
      setTimeout: function(fn, ms) {
        return setTimeout(fn, ms);
      },
      clearTimeout: function(id) {
        return clearTimeout(id);
      }
    },
    logger: console.log.bind(console),
    devTools: false
  };
  Interpreter2.interpret = interpret;
  return Interpreter2;
}();
function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}

// node_modules/xstate/es/invokeUtils.js
function toInvokeSource2(src) {
  if (typeof src === "string") {
    var simpleSrc = {
      type: src
    };
    simpleSrc.toString = function() {
      return src;
    };
    return simpleSrc;
  }
  return src;
}
function toInvokeDefinition(invokeConfig) {
  return __assign(__assign({
    type: invoke
  }, invokeConfig), {
    toJSON: function() {
      invokeConfig.onDone;
      invokeConfig.onError;
      var invokeDef = __rest(invokeConfig, ["onDone", "onError"]);
      return __assign(__assign({}, invokeDef), {
        type: invoke,
        src: toInvokeSource2(invokeConfig.src)
      });
    }
  });
}

// node_modules/xstate/es/StateNode.js
var NULL_EVENT = "";
var STATE_IDENTIFIER = "#";
var WILDCARD = "*";
var EMPTY_OBJECT = {};
var isStateId = function(str) {
  return str[0] === STATE_IDENTIFIER;
};
var createDefaultOptions = function() {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
};
var validateArrayifiedTransitions = function(stateNode, event2, transitions) {
  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function(transition) {
    return !("cond" in transition) && !("in" in transition) && (isString(transition.target) || isMachine(transition.target));
  });
  var eventText = event2 === NULL_EVENT ? "the transient event" : "event '".concat(event2, "'");
  warn(!hasNonLastUnguardedTarget, "One or more transitions for ".concat(eventText, " on state '").concat(stateNode.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
};
var StateNode = function() {
  function StateNode2(config, options, _context, _stateInfo) {
    var _this = this;
    if (_context === void 0) {
      _context = "context" in config ? config.context : void 0;
    }
    var _a2;
    this.config = config;
    this._context = _context;
    this.order = -1;
    this.__xstatenode = true;
    this.__cache = {
      events: void 0,
      relativeValue: /* @__PURE__ */ new Map(),
      initialStateValue: void 0,
      initialState: void 0,
      on: void 0,
      transitions: void 0,
      candidates: {},
      delayedTransitions: void 0
    };
    this.idMap = {};
    this.tags = [];
    this.options = Object.assign(createDefaultOptions(), options);
    this.parent = _stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.parent;
    this.key = this.config.key || (_stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.key) || this.config.id || "(machine)";
    this.machine = this.parent ? this.parent.machine : this;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);
    this.id = this.config.id || __spreadArray([this.machine.key], __read(this.path), false).join(this.delimiter);
    this.version = this.parent ? this.parent.version : this.config.version;
    this.type = this.config.type || (this.config.parallel ? "parallel" : this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic");
    this.schema = this.parent ? this.machine.schema : (_a2 = this.config.schema) !== null && _a2 !== void 0 ? _a2 : {};
    this.description = this.config.description;
    if (!IS_PRODUCTION) {
      warn(!("parallel" in this.config), 'The "parallel" property is deprecated and will be removed in version 4.1. '.concat(this.config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '".concat(this.type, "'`"), " in the config for state node '").concat(this.id, "' instead."));
    }
    this.initial = this.config.initial;
    this.states = this.config.states ? mapValues(this.config.states, function(stateConfig, key) {
      var _a3;
      var stateNode = new StateNode2(stateConfig, {}, void 0, {
        parent: _this,
        key
      });
      Object.assign(_this.idMap, __assign((_a3 = {}, _a3[stateNode.id] = stateNode, _a3), stateNode.idMap));
      return stateNode;
    }) : EMPTY_OBJECT;
    var order = 0;
    function dfs(stateNode) {
      var e_1, _a3;
      stateNode.order = order++;
      try {
        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var child = _c.value;
          dfs(child);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    dfs(this);
    this.history = this.config.history === true ? "shallow" : this.config.history || false;
    this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function(_a3) {
      var event2 = _a3.event;
      return event2 === NULL_EVENT;
    }) : NULL_EVENT in this.config.on);
    this.strict = !!this.config.strict;
    this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function(action) {
      return toActionObject(action);
    });
    this.onExit = toArray(this.config.exit || this.config.onExit).map(function(action) {
      return toActionObject(action);
    });
    this.meta = this.config.meta;
    this.doneData = this.type === "final" ? this.config.data : void 0;
    this.invoke = toArray(this.config.invoke).map(function(invokeConfig, i4) {
      var _a3, _b;
      if (isMachine(invokeConfig)) {
        var invokeId = createInvokeId(_this.id, i4);
        _this.machine.options.services = __assign((_a3 = {}, _a3[invokeId] = invokeConfig, _a3), _this.machine.options.services);
        return toInvokeDefinition({
          src: invokeId,
          id: invokeId
        });
      } else if (isString(invokeConfig.src)) {
        var invokeId = invokeConfig.id || createInvokeId(_this.id, i4);
        return toInvokeDefinition(__assign(__assign({}, invokeConfig), {
          id: invokeId,
          src: invokeConfig.src
        }));
      } else if (isMachine(invokeConfig.src) || isFunction(invokeConfig.src)) {
        var invokeId = invokeConfig.id || createInvokeId(_this.id, i4);
        _this.machine.options.services = __assign((_b = {}, _b[invokeId] = invokeConfig.src, _b), _this.machine.options.services);
        return toInvokeDefinition(__assign(__assign({
          id: invokeId
        }, invokeConfig), {
          src: invokeId
        }));
      } else {
        var invokeSource = invokeConfig.src;
        return toInvokeDefinition(__assign(__assign({
          id: createInvokeId(_this.id, i4)
        }, invokeConfig), {
          src: invokeSource
        }));
      }
    });
    this.activities = toArray(this.config.activities).concat(this.invoke).map(function(activity) {
      return toActivityDefinition(activity);
    });
    this.transition = this.transition.bind(this);
    this.tags = toArray(this.config.tags);
  }
  StateNode2.prototype._init = function() {
    if (this.__cache.transitions) {
      return;
    }
    getAllStateNodes(this).forEach(function(stateNode) {
      return stateNode.on;
    });
  };
  StateNode2.prototype.withConfig = function(options, context) {
    var _a2 = this.options, actions = _a2.actions, activities = _a2.activities, guards = _a2.guards, services = _a2.services, delays = _a2.delays;
    return new StateNode2(this.config, {
      actions: __assign(__assign({}, actions), options.actions),
      activities: __assign(__assign({}, activities), options.activities),
      guards: __assign(__assign({}, guards), options.guards),
      services: __assign(__assign({}, services), options.services),
      delays: __assign(__assign({}, delays), options.delays)
    }, context !== null && context !== void 0 ? context : this.context);
  };
  StateNode2.prototype.withContext = function(context) {
    return new StateNode2(this.config, this.options, context);
  };
  Object.defineProperty(StateNode2.prototype, "context", {
    get: function() {
      return isFunction(this._context) ? this._context() : this._context;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "definition", {
    get: function() {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        context: this.context,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: mapValues(this.states, function(state) {
          return state.definition;
        }),
        on: this.on,
        transitions: this.transitions,
        entry: this.onEntry,
        exit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.doneData,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      };
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.toJSON = function() {
    return this.definition;
  };
  Object.defineProperty(StateNode2.prototype, "on", {
    get: function() {
      if (this.__cache.on) {
        return this.__cache.on;
      }
      var transitions = this.transitions;
      return this.__cache.on = transitions.reduce(function(map, transition) {
        map[transition.eventType] = map[transition.eventType] || [];
        map[transition.eventType].push(transition);
        return map;
      }, {});
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "after", {
    get: function() {
      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "transitions", {
    get: function() {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.getCandidates = function(eventName) {
    if (this.__cache.candidates[eventName]) {
      return this.__cache.candidates[eventName];
    }
    var transient = eventName === NULL_EVENT;
    var candidates = this.transitions.filter(function(transition) {
      var sameEventType = transition.eventType === eventName;
      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;
    });
    this.__cache.candidates[eventName] = candidates;
    return candidates;
  };
  StateNode2.prototype.getDelayedTransitions = function() {
    var _this = this;
    var afterConfig = this.config.after;
    if (!afterConfig) {
      return [];
    }
    var mutateEntryExit = function(delay, i4) {
      var delayRef = isFunction(delay) ? "".concat(_this.id, ":delay[").concat(i4, "]") : delay;
      var eventType = after2(delayRef, _this.id);
      _this.onEntry.push(send2(eventType, {
        delay
      }));
      _this.onExit.push(cancel2(eventType));
      return eventType;
    };
    var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function(transition, i4) {
      var eventType = mutateEntryExit(transition.delay, i4);
      return __assign(__assign({}, transition), {
        event: eventType
      });
    }) : flatten(Object.keys(afterConfig).map(function(delay, i4) {
      var configTransition = afterConfig[delay];
      var resolvedTransition = isString(configTransition) ? {
        target: configTransition
      } : configTransition;
      var resolvedDelay = !isNaN(+delay) ? +delay : delay;
      var eventType = mutateEntryExit(resolvedDelay, i4);
      return toArray(resolvedTransition).map(function(transition) {
        return __assign(__assign({}, transition), {
          event: eventType,
          delay: resolvedDelay
        });
      });
    }));
    return delayedTransitions.map(function(delayedTransition) {
      var delay = delayedTransition.delay;
      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {
        delay
      });
    });
  };
  StateNode2.prototype.getStateNodes = function(state) {
    var _a2;
    var _this = this;
    if (!state) {
      return [];
    }
    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);
    if (isString(stateValue)) {
      var initialStateValue = this.getStateNode(stateValue).initial;
      return initialStateValue !== void 0 ? this.getStateNodes((_a2 = {}, _a2[stateValue] = initialStateValue, _a2)) : [this, this.states[stateValue]];
    }
    var subStateKeys = Object.keys(stateValue);
    var subStateNodes = [this];
    subStateNodes.push.apply(subStateNodes, __spreadArray([], __read(flatten(subStateKeys.map(function(subStateKey) {
      return _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
    }))), false));
    return subStateNodes;
  };
  StateNode2.prototype.handles = function(event2) {
    var eventType = getEventType(event2);
    return this.events.includes(eventType);
  };
  StateNode2.prototype.resolveState = function(state) {
    var stateFromConfig = state instanceof State ? state : State.create(state);
    var configuration = Array.from(getConfiguration([], this.getStateNodes(stateFromConfig.value)));
    return new State(__assign(__assign({}, stateFromConfig), {
      value: this.resolve(stateFromConfig.value),
      configuration,
      done: isInFinalState(configuration, this),
      tags: getTagsFromConfiguration(configuration),
      machine: this.machine
    }));
  };
  StateNode2.prototype.transitionLeafNode = function(stateValue, state, _event) {
    var stateNode = this.getStateNode(stateValue);
    var next = stateNode.next(state, _event);
    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }
    return next;
  };
  StateNode2.prototype.transitionCompoundNode = function(stateValue, state, _event) {
    var subStateKeys = Object.keys(stateValue);
    var stateNode = this.getStateNode(subStateKeys[0]);
    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);
    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }
    return next;
  };
  StateNode2.prototype.transitionParallelNode = function(stateValue, state, _event) {
    var e_2, _a2;
    var transitionMap = {};
    try {
      for (var _b = __values(Object.keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var subStateKey = _c.value;
        var subStateValue = stateValue[subStateKey];
        if (!subStateValue) {
          continue;
        }
        var subStateNode = this.getStateNode(subStateKey);
        var next = subStateNode._transition(subStateValue, state, _event);
        if (next) {
          transitionMap[subStateKey] = next;
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    var stateTransitions = Object.keys(transitionMap).map(function(key) {
      return transitionMap[key];
    });
    var enabledTransitions = flatten(stateTransitions.map(function(st) {
      return st.transitions;
    }));
    var willTransition = stateTransitions.some(function(st) {
      return st.transitions.length > 0;
    });
    if (!willTransition) {
      return this.next(state, _event);
    }
    var entryNodes = flatten(stateTransitions.map(function(t5) {
      return t5.entrySet;
    }));
    var configuration = flatten(Object.keys(transitionMap).map(function(key) {
      return transitionMap[key].configuration;
    }));
    return {
      transitions: enabledTransitions,
      entrySet: entryNodes,
      exitSet: flatten(stateTransitions.map(function(t5) {
        return t5.exitSet;
      })),
      configuration,
      source: state,
      actions: flatten(Object.keys(transitionMap).map(function(key) {
        return transitionMap[key].actions;
      }))
    };
  };
  StateNode2.prototype._transition = function(stateValue, state, _event) {
    if (isString(stateValue)) {
      return this.transitionLeafNode(stateValue, state, _event);
    }
    if (Object.keys(stateValue).length === 1) {
      return this.transitionCompoundNode(stateValue, state, _event);
    }
    return this.transitionParallelNode(stateValue, state, _event);
  };
  StateNode2.prototype.getTransitionData = function(state, event2) {
    return this._transition(state.value, state, toSCXMLEvent(event2));
  };
  StateNode2.prototype.next = function(state, _event) {
    var e_3, _a2;
    var _this = this;
    var eventName = _event.name;
    var actions = [];
    var nextStateNodes = [];
    var selectedTransition;
    try {
      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var candidate = _c.value;
        var cond = candidate.cond, stateIn = candidate.in;
        var resolvedContext = state.context;
        var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;
        var guardPassed = false;
        try {
          guardPassed = !cond || evaluateGuard(this.machine, cond, resolvedContext, _event, state);
        } catch (err) {
          throw new Error("Unable to evaluate guard '".concat(cond.name || cond.type, "' in transition for event '").concat(eventName, "' in state node '").concat(this.id, "':\n").concat(err.message));
        }
        if (guardPassed && isInState) {
          if (candidate.target !== void 0) {
            nextStateNodes = candidate.target;
          }
          actions.push.apply(actions, __spreadArray([], __read(candidate.actions), false));
          selectedTransition = candidate;
          break;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    if (!selectedTransition) {
      return void 0;
    }
    if (!nextStateNodes.length) {
      return {
        transitions: [selectedTransition],
        entrySet: [],
        exitSet: [],
        configuration: state.value ? [this] : [],
        source: state,
        actions
      };
    }
    var allNextStateNodes = flatten(nextStateNodes.map(function(stateNode) {
      return _this.getRelativeStateNodes(stateNode, state.historyValue);
    }));
    var isInternal = !!selectedTransition.internal;
    var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function(n3) {
      return _this.nodesFromChild(n3);
    }));
    return {
      transitions: [selectedTransition],
      entrySet: reentryNodes,
      exitSet: isInternal ? [] : [this],
      configuration: allNextStateNodes,
      source: state,
      actions
    };
  };
  StateNode2.prototype.nodesFromChild = function(childStateNode) {
    if (childStateNode.escapes(this)) {
      return [];
    }
    var nodes = [];
    var marker = childStateNode;
    while (marker && marker !== this) {
      nodes.push(marker);
      marker = marker.parent;
    }
    nodes.push(this);
    return nodes;
  };
  StateNode2.prototype.escapes = function(stateNode) {
    if (this === stateNode) {
      return false;
    }
    var parent = this.parent;
    while (parent) {
      if (parent === stateNode) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  };
  StateNode2.prototype.getActions = function(transition, currentContext, _event, prevState) {
    var e_4, _a2, e_5, _b;
    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);
    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;
    try {
      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {
        var sn = resolvedConfig_1_1.value;
        if (!has(prevConfig, sn)) {
          transition.entrySet.push(sn);
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a2 = resolvedConfig_1.return))
          _a2.call(resolvedConfig_1);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    try {
      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
        var sn = prevConfig_1_1.value;
        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {
          transition.exitSet.push(sn);
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return))
          _b.call(prevConfig_1);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    var doneEvents = flatten(transition.entrySet.map(function(sn2) {
      var events = [];
      if (sn2.type !== "final") {
        return events;
      }
      var parent = sn2.parent;
      if (!parent.parent) {
        return events;
      }
      events.push(done(sn2.id, sn2.doneData), done(parent.id, sn2.doneData ? mapContext(sn2.doneData, currentContext, _event) : void 0));
      var grandparent = parent.parent;
      if (grandparent.type === "parallel") {
        if (getChildren(grandparent).every(function(parentNode) {
          return isInFinalState(transition.configuration, parentNode);
        })) {
          events.push(done(grandparent.id));
        }
      }
      return events;
    }));
    transition.exitSet.sort(function(a5, b4) {
      return b4.order - a5.order;
    });
    transition.entrySet.sort(function(a5, b4) {
      return a5.order - b4.order;
    });
    var entryStates = new Set(transition.entrySet);
    var exitStates = new Set(transition.exitSet);
    var _c = __read([flatten(Array.from(entryStates).map(function(stateNode) {
      return __spreadArray(__spreadArray([], __read(stateNode.activities.map(function(activity) {
        return start2(activity);
      })), false), __read(stateNode.onEntry), false);
    })).concat(doneEvents.map(raise2)), flatten(Array.from(exitStates).map(function(stateNode) {
      return __spreadArray(__spreadArray([], __read(stateNode.onExit), false), __read(stateNode.activities.map(function(activity) {
        return stop2(activity);
      })), false);
    }))], 2), entryActions = _c[0], exitActions = _c[1];
    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);
    return actions;
  };
  StateNode2.prototype.transition = function(state, event2, context) {
    if (state === void 0) {
      state = this.initialState;
    }
    var _event = toSCXMLEvent(event2);
    var currentState;
    if (state instanceof State) {
      currentState = context === void 0 ? state : this.resolveState(State.from(state, context));
    } else {
      var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);
      var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;
      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));
    }
    if (!IS_PRODUCTION && _event.name === WILDCARD) {
      throw new Error("An event cannot have the wildcard type ('".concat(WILDCARD, "')"));
    }
    if (this.strict) {
      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {
        throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(_event.name, "'"));
      }
    }
    var stateTransition = this._transition(currentState.value, currentState, _event) || {
      transitions: [],
      configuration: [],
      entrySet: [],
      exitSet: [],
      source: currentState,
      actions: []
    };
    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));
    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;
    stateTransition.configuration = __spreadArray([], __read(resolvedConfig), false);
    return this.resolveTransition(stateTransition, currentState, currentState.context, _event);
  };
  StateNode2.prototype.resolveRaisedTransition = function(state, _event, originalEvent) {
    var _a2;
    var currentActions = state.actions;
    state = this.transition(state, _event);
    state._event = originalEvent;
    state.event = originalEvent.data;
    (_a2 = state.actions).unshift.apply(_a2, __spreadArray([], __read(currentActions), false));
    return state;
  };
  StateNode2.prototype.resolveTransition = function(stateTransition, currentState, context, _event) {
    var e_6, _a2;
    var _this = this;
    if (_event === void 0) {
      _event = initEvent;
    }
    var configuration = stateTransition.configuration;
    var willTransition = !currentState || stateTransition.transitions.length > 0;
    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : void 0;
    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : void 0 : void 0;
    var actions = this.getActions(stateTransition, context, _event, currentState);
    var activities = currentState ? __assign({}, currentState.activities) : {};
    try {
      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
        var action = actions_1_1.value;
        if (action.type === start) {
          activities[action.activity.id || action.activity.type] = action;
        } else if (action.type === stop) {
          activities[action.activity.id || action.activity.type] = false;
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (actions_1_1 && !actions_1_1.done && (_a2 = actions_1.return))
          _a2.call(actions_1);
      } finally {
        if (e_6)
          throw e_6.error;
      }
    }
    var _b = __read(resolveActions(this, currentState, context, _event, actions, this.machine.config.preserveActionOrder), 2), resolvedActions = _b[0], updatedContext = _b[1];
    var _c = __read(partition(resolvedActions, function(action2) {
      return action2.type === raise || action2.type === send && action2.to === SpecialTargets.Internal;
    }), 2), raisedEvents = _c[0], nonRaisedActions = _c[1];
    var invokeActions = resolvedActions.filter(function(action2) {
      var _a3;
      return action2.type === start && ((_a3 = action2.activity) === null || _a3 === void 0 ? void 0 : _a3.type) === invoke;
    });
    var children2 = invokeActions.reduce(function(acc, action2) {
      acc[action2.activity.id] = createInvocableActor(action2.activity, _this.machine, updatedContext, _event);
      return acc;
    }, currentState ? __assign({}, currentState.children) : {});
    var resolvedConfiguration = willTransition ? stateTransition.configuration : currentState ? currentState.configuration : [];
    var isDone = isInFinalState(resolvedConfiguration, this);
    var nextState = new State({
      value: resolvedStateValue || currentState.value,
      context: updatedContext,
      _event,
      _sessionid: currentState ? currentState._sessionid : null,
      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : void 0 : currentState ? currentState.historyValue : void 0,
      history: !resolvedStateValue || stateTransition.source ? currentState : void 0,
      actions: resolvedStateValue ? nonRaisedActions : [],
      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
      events: [],
      configuration: resolvedConfiguration,
      transitions: stateTransition.transitions,
      children: children2,
      done: isDone,
      tags: getTagsFromConfiguration(resolvedConfiguration),
      machine: this
    });
    var didUpdateContext = context !== updatedContext;
    nextState.changed = _event.name === update || didUpdateContext;
    var history = nextState.history;
    if (history) {
      delete history.history;
    }
    var isTransient = !isDone && (this._transient || configuration.some(function(stateNode) {
      return stateNode._transient;
    }));
    if (!willTransition && (!isTransient || _event.name === NULL_EVENT)) {
      return nextState;
    }
    var maybeNextState = nextState;
    if (!isDone) {
      if (isTransient) {
        maybeNextState = this.resolveRaisedTransition(maybeNextState, {
          type: nullEvent
        }, _event);
      }
      while (raisedEvents.length) {
        var raisedEvent = raisedEvents.shift();
        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);
      }
    }
    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : void 0);
    maybeNextState.changed = changed;
    maybeNextState.history = history;
    return maybeNextState;
  };
  StateNode2.prototype.getStateNode = function(stateKey) {
    if (isStateId(stateKey)) {
      return this.machine.getStateNodeById(stateKey);
    }
    if (!this.states) {
      throw new Error("Unable to retrieve child state '".concat(stateKey, "' from '").concat(this.id, "'; no child states exist."));
    }
    var result = this.states[stateKey];
    if (!result) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }
    return result;
  };
  StateNode2.prototype.getStateNodeById = function(stateId) {
    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;
    if (resolvedStateId === this.id) {
      return this;
    }
    var stateNode = this.machine.idMap[resolvedStateId];
    if (!stateNode) {
      throw new Error("Child state node '#".concat(resolvedStateId, "' does not exist on machine '").concat(this.id, "'"));
    }
    return stateNode;
  };
  StateNode2.prototype.getStateNodeByPath = function(statePath) {
    if (typeof statePath === "string" && isStateId(statePath)) {
      try {
        return this.getStateNodeById(statePath.slice(1));
      } catch (e5) {
      }
    }
    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();
    var currentStateNode = this;
    while (arrayStatePath.length) {
      var key = arrayStatePath.shift();
      if (!key.length) {
        break;
      }
      currentStateNode = currentStateNode.getStateNode(key);
    }
    return currentStateNode;
  };
  StateNode2.prototype.resolve = function(stateValue) {
    var _a2;
    var _this = this;
    if (!stateValue) {
      return this.initialStateValue || EMPTY_OBJECT;
    }
    switch (this.type) {
      case "parallel":
        return mapValues(this.initialStateValue, function(subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
        });
      case "compound":
        if (isString(stateValue)) {
          var subStateNode = this.getStateNode(stateValue);
          if (subStateNode.type === "parallel" || subStateNode.type === "compound") {
            return _a2 = {}, _a2[stateValue] = subStateNode.initialStateValue, _a2;
          }
          return stateValue;
        }
        if (!Object.keys(stateValue).length) {
          return this.initialStateValue || {};
        }
        return mapValues(stateValue, function(subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
        });
      default:
        return stateValue || EMPTY_OBJECT;
    }
  };
  StateNode2.prototype.getResolvedPath = function(stateIdentifier) {
    if (isStateId(stateIdentifier)) {
      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];
      if (!stateNode) {
        throw new Error("Unable to find state node '".concat(stateIdentifier, "'"));
      }
      return stateNode.path;
    }
    return toStatePath(stateIdentifier, this.delimiter);
  };
  Object.defineProperty(StateNode2.prototype, "initialStateValue", {
    get: function() {
      var _a2;
      if (this.__cache.initialStateValue) {
        return this.__cache.initialStateValue;
      }
      var initialStateValue;
      if (this.type === "parallel") {
        initialStateValue = mapFilterValues(this.states, function(state) {
          return state.initialStateValue || EMPTY_OBJECT;
        }, function(stateNode) {
          return !(stateNode.type === "history");
        });
      } else if (this.initial !== void 0) {
        if (!this.states[this.initial]) {
          throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
        }
        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a2 = {}, _a2[this.initial] = this.states[this.initial].initialStateValue, _a2);
      } else {
        initialStateValue = {};
      }
      this.__cache.initialStateValue = initialStateValue;
      return this.__cache.initialStateValue;
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.getInitialState = function(stateValue, context) {
    this._init();
    var configuration = this.getStateNodes(stateValue);
    return this.resolveTransition({
      configuration,
      entrySet: configuration,
      exitSet: [],
      transitions: [],
      source: void 0,
      actions: []
    }, void 0, context !== null && context !== void 0 ? context : this.machine.context, void 0);
  };
  Object.defineProperty(StateNode2.prototype, "initialState", {
    get: function() {
      var initialStateValue = this.initialStateValue;
      if (!initialStateValue) {
        throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
      }
      return this.getInitialState(initialStateValue);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "target", {
    get: function() {
      var target;
      if (this.type === "history") {
        var historyConfig = this.config;
        if (isString(historyConfig.target)) {
          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
        } else {
          target = historyConfig.target;
        }
      }
      return target;
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.getRelativeStateNodes = function(relativeStateId, historyValue, resolve) {
    if (resolve === void 0) {
      resolve = true;
    }
    return resolve ? relativeStateId.type === "history" ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];
  };
  Object.defineProperty(StateNode2.prototype, "initialStateNodes", {
    get: function() {
      var _this = this;
      if (isLeafNode(this)) {
        return [this];
      }
      if (this.type === "compound" && !this.initial) {
        if (!IS_PRODUCTION) {
          warn(false, "Compound state node '".concat(this.id, "' has no initial state."));
        }
        return [this];
      }
      var initialStateNodePaths = toStatePaths(this.initialStateValue);
      return flatten(initialStateNodePaths.map(function(initialPath) {
        return _this.getFromRelativePath(initialPath);
      }));
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.getFromRelativePath = function(relativePath) {
    if (!relativePath.length) {
      return [this];
    }
    var _a2 = __read(relativePath), stateKey = _a2[0], childStatePath = _a2.slice(1);
    if (!this.states) {
      throw new Error("Cannot retrieve subPath '".concat(stateKey, "' from node with no states"));
    }
    var childStateNode = this.getStateNode(stateKey);
    if (childStateNode.type === "history") {
      return childStateNode.resolveHistory();
    }
    if (!this.states[stateKey]) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }
    return this.states[stateKey].getFromRelativePath(childStatePath);
  };
  StateNode2.prototype.historyValue = function(relativeStateValue) {
    if (!Object.keys(this.states).length) {
      return void 0;
    }
    return {
      current: relativeStateValue || this.initialStateValue,
      states: mapFilterValues(this.states, function(stateNode, key) {
        if (!relativeStateValue) {
          return stateNode.historyValue();
        }
        var subStateValue = isString(relativeStateValue) ? void 0 : relativeStateValue[key];
        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
      }, function(stateNode) {
        return !stateNode.history;
      })
    };
  };
  StateNode2.prototype.resolveHistory = function(historyValue) {
    var _this = this;
    if (this.type !== "history") {
      return [this];
    }
    var parent = this.parent;
    if (!historyValue) {
      var historyTarget = this.target;
      return historyTarget ? flatten(toStatePaths(historyTarget).map(function(relativeChildPath) {
        return parent.getFromRelativePath(relativeChildPath);
      })) : parent.initialStateNodes;
    }
    var subHistoryValue = nestedPath(parent.path, "states")(historyValue).current;
    if (isString(subHistoryValue)) {
      return [parent.getStateNode(subHistoryValue)];
    }
    return flatten(toStatePaths(subHistoryValue).map(function(subStatePath) {
      return _this.history === "deep" ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
    }));
  };
  Object.defineProperty(StateNode2.prototype, "stateIds", {
    get: function() {
      var _this = this;
      var childStateIds = flatten(Object.keys(this.states).map(function(stateKey) {
        return _this.states[stateKey].stateIds;
      }));
      return [this.id].concat(childStateIds);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "events", {
    get: function() {
      var e_7, _a2, e_8, _b;
      if (this.__cache.events) {
        return this.__cache.events;
      }
      var states = this.states;
      var events = new Set(this.ownEvents);
      if (states) {
        try {
          for (var _c = __values(Object.keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stateId = _d.value;
            var state = states[stateId];
            if (state.states) {
              try {
                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var event_1 = _f.value;
                  events.add("".concat(event_1));
                }
              } catch (e_8_1) {
                e_8 = {
                  error: e_8_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return))
                    _b.call(_e);
                } finally {
                  if (e_8)
                    throw e_8.error;
                }
              }
            }
          }
        } catch (e_7_1) {
          e_7 = {
            error: e_7_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return))
              _a2.call(_c);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
      }
      return this.__cache.events = Array.from(events);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode2.prototype, "ownEvents", {
    get: function() {
      var events = new Set(this.transitions.filter(function(transition) {
        return !(!transition.target && !transition.actions.length && transition.internal);
      }).map(function(transition) {
        return transition.eventType;
      }));
      return Array.from(events);
    },
    enumerable: false,
    configurable: true
  });
  StateNode2.prototype.resolveTarget = function(_target) {
    var _this = this;
    if (_target === void 0) {
      return void 0;
    }
    return _target.map(function(target) {
      if (!isString(target)) {
        return target;
      }
      var isInternalTarget = target[0] === _this.delimiter;
      if (isInternalTarget && !_this.parent) {
        return _this.getStateNodeByPath(target.slice(1));
      }
      var resolvedTarget = isInternalTarget ? _this.key + target : target;
      if (_this.parent) {
        try {
          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);
          return targetStateNode;
        } catch (err) {
          throw new Error("Invalid transition definition for state node '".concat(_this.id, "':\n").concat(err.message));
        }
      } else {
        return _this.getStateNodeByPath(resolvedTarget);
      }
    });
  };
  StateNode2.prototype.formatTransition = function(transitionConfig) {
    var _this = this;
    var normalizedTarget = normalizeTarget(transitionConfig.target);
    var internal = "internal" in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function(_target) {
      return isString(_target) && _target[0] === _this.delimiter;
    }) : true;
    var guards = this.machine.options.guards;
    var target = this.resolveTarget(normalizedTarget);
    var transition = __assign(__assign({}, transitionConfig), {
      actions: toActionObjects(toArray(transitionConfig.actions)),
      cond: toGuard(transitionConfig.cond, guards),
      target,
      source: this,
      internal,
      eventType: transitionConfig.event,
      toJSON: function() {
        return __assign(__assign({}, transition), {
          target: transition.target ? transition.target.map(function(t5) {
            return "#".concat(t5.id);
          }) : void 0,
          source: "#".concat(_this.id)
        });
      }
    });
    return transition;
  };
  StateNode2.prototype.formatTransitions = function() {
    var e_9, _a2;
    var _this = this;
    var onConfig;
    if (!this.config.on) {
      onConfig = [];
    } else if (Array.isArray(this.config.on)) {
      onConfig = this.config.on;
    } else {
      var _b = this.config.on, _c = WILDCARD, _d = _b[_c], wildcardConfigs = _d === void 0 ? [] : _d, strictTransitionConfigs_1 = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);
      onConfig = flatten(Object.keys(strictTransitionConfigs_1).map(function(key) {
        if (!IS_PRODUCTION && key === NULL_EVENT) {
          warn(false, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + 'Please check the `on` configuration for "#'.concat(_this.id, '".'));
        }
        var transitionConfigArray = toTransitionConfigArray(key, strictTransitionConfigs_1[key]);
        if (!IS_PRODUCTION) {
          validateArrayifiedTransitions(_this, key, transitionConfigArray);
        }
        return transitionConfigArray;
      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));
    }
    var eventlessConfig = this.config.always ? toTransitionConfigArray("", this.config.always) : [];
    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];
    if (!IS_PRODUCTION) {
      warn(!(this.config.onDone && !this.parent), 'Root nodes cannot have an ".onDone" transition. Please check the config of "'.concat(this.id, '".'));
    }
    var invokeConfig = flatten(this.invoke.map(function(invokeDef) {
      var settleTransitions = [];
      if (invokeDef.onDone) {
        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)), false));
      }
      if (invokeDef.onError) {
        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(error2(invokeDef.id)), invokeDef.onError)), false));
      }
      return settleTransitions;
    }));
    var delayedTransitions = this.after;
    var formattedTransitions = flatten(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(doneConfig), false), __read(invokeConfig), false), __read(onConfig), false), __read(eventlessConfig), false).map(function(transitionConfig) {
      return toArray(transitionConfig).map(function(transition) {
        return _this.formatTransition(transition);
      });
    }));
    try {
      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
        var delayedTransition = delayedTransitions_1_1.value;
        formattedTransitions.push(delayedTransition);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a2 = delayedTransitions_1.return))
          _a2.call(delayedTransitions_1);
      } finally {
        if (e_9)
          throw e_9.error;
      }
    }
    return formattedTransitions;
  };
  return StateNode2;
}();

// node_modules/xstate/es/Machine.js
function createMachine(config, options) {
  return new StateNode(config, options);
}

// node_modules/lingo3d/lib/interface/IDummy.js
var dummySchema = {
  ...modelSchema,
  spineName: String,
  preset: String,
  strideForward: Number,
  strideRight: Number,
  strideMove: Boolean,
  strideMode: String
};
var dummyDefaults = {
  ...modelDefaults,
  spineName: void 0,
  preset: "default",
  strideForward: 0,
  strideRight: 0,
  strideMove: false,
  strideMode: "aim",
  scale: 1.7,
  scaleX: 1.7,
  scaleY: 1.7,
  scaleZ: 1.7,
  width: 20,
  depth: 20,
  animation: "idle",
  pbr: true,
  src: YBOT_URL
};

// node_modules/lingo3d/lib/display/Dummy/poseMachine.js
var poseMachine_default = createMachine({
  states: {
    "idle": {
      on: {
        RUN_START: "running",
        RUN_BACKWARDS_START: "runningBackwards",
        JUMP_START: "jumping"
      }
    },
    "running": {
      on: {
        RUN_STOP: "idle",
        RUN_BACKWARDS_START: "runningBackwards",
        JUMP_START: "jumping"
      }
    },
    "runningBackwards": {
      on: {
        RUN_STOP: "idle",
        RUN_START: "running",
        JUMP_START: "jumping"
      }
    },
    "jumping": {
      on: {
        JUMP_STOP: "idle"
      }
    }
  },
  initial: "idle"
});

// node_modules/lingo3d/lib/display/Dummy/index.js
var dummyTypeMap = /* @__PURE__ */ new WeakMap();
var Dummy = class extends Model {
  constructor() {
    super();
    __publicField(this, "poseService", interpret(poseMachine_default));
    __publicField(this, "spineNameState", new Reactive(void 0));
    __publicField(this, "srcState", new Reactive(YBOT_URL));
    __publicField(this, "animationsState", new Reactive({}));
    __publicField(this, "presetState", new Reactive("default"));
    __publicField(this, "strideForwardState", new Reactive(0));
    __publicField(this, "strideRightState", new Reactive(0));
    __publicField(this, "strideMoveState", new Reactive(false));
    __publicField(this, "strideMode", "aim");
    __publicField(this, "jumpHeight", 10);
    this.width = 20;
    this.depth = 20;
    this.scale = 1.7;
    this.pbr = true;
    this.frustumCulled = false;
    const [setType, getType] = store(void 0);
    const [setSpine, getSpine] = store(void 0);
    this.createEffect(() => {
      const spineName = this.spineNameState.get();
      const src = super.src = this.srcState.get();
      setSpine(void 0);
      setType(void 0);
      dummyTypeMap.delete(this);
      const handle = this.loaded.then((loaded) => {
        if (spineName) {
          setSpine(this.find(spineName, true));
          if (spineName === "mixamorigSpine") {
            setType("mixamo");
            src === YBOT_URL && dummyTypeMap.set(this, "dummy");
          } else if (spineName === "Spine" && loaded.getObjectByName("Wolf3D_Body")) {
            setType("readyplayerme");
            dummyTypeMap.set(this, "readyplayerme");
          }
          return;
        }
        if (loaded.getObjectByName("Wolf3D_Body")) {
          setSpine(this.find("Spine", true));
          setType("readyplayerme");
          dummyTypeMap.set(this, "readyplayerme");
          return;
        }
        const spine = this.find("mixamorigSpine", true);
        setSpine(spine);
        if (spine) {
          setType("mixamo");
          src === YBOT_URL && dummyTypeMap.set(this, "dummy");
        }
      });
      return () => {
        handle.cancel();
      };
    }, [this.srcState.get, this.spineNameState.get]);
    const [setPose, getPose] = store("idle");
    this.createEffect(() => {
      const type2 = getType();
      if (!type2)
        return;
      const preset = this.presetState.get();
      const prefix = preset === "rifle" ? "rifle-" : "";
      const parts = this.srcState.get().split("/");
      parts.pop();
      let url2 = parts.join("/") + "/";
      let done2 = false;
      (async () => {
        const res = await fetch(url2 + prefix + "idle.fbx", { method: "HEAD" });
        if (done2)
          return;
        if (!res.ok) {
          if (type2 === "readyplayerme")
            url2 = DUMMY_URL + "readyplayerme/";
          else
            return;
        }
        super.animations = {
          idle: url2 + prefix + "idle.fbx",
          running: url2 + prefix + "running.fbx",
          runningBackwards: url2 + prefix + "running-backwards.fbx",
          jumping: url2 + prefix + "falling.fbx",
          death: url2 + "death.fbx",
          ...this.animationsState.get()
        };
        this.animation = getPose();
      })();
      return () => {
        done2 = true;
        this.animation = void 0;
        super.animations = {};
      };
    }, [this.presetState.get, this.srcState.get, getType, this.animationsState.get]);
    const { poseService } = this;
    this.createEffect(() => {
      const pose = this.animation = getPose();
      if (pose !== "jumping")
        return;
      this.velocity.y = this.jumpHeight;
      const handle = onBeforeRender(() => {
        this.velocity.y === 0 && poseService.send("JUMP_STOP");
      });
      return () => {
        handle.cancel();
      };
    }, [getPose]);
    poseService.onTransition((state) => state.changed && setPose(state.value)).start();
    this.then(() => poseService.stop());
    let groupVecOld;
    const computeAngle = (angle2) => {
      const thisPoint = this.pointAt(1e3);
      const centerPoint = this.getWorldPosition();
      const rotated = rotatePoint({ x: thisPoint.x, y: thisPoint.z }, { x: centerPoint.x, y: centerPoint.z }, angle2);
      return point2Vec(new Point3d(rotated.x, thisPoint.y, rotated.y));
    };
    this.createEffect(() => {
      const spine = getSpine();
      if (!spine)
        return;
      const spineQuaternion = spine.outerObject3d.quaternion.clone();
      const loadedGroupQuaternion = this.loadedGroup.quaternion.clone();
      const { strideForward, strideRight, strideMove } = this;
      if (!strideForward && !strideRight) {
        poseService.send("RUN_STOP");
        this.strideMode === "aim" && (groupVecOld = void 0);
        return;
      }
      const backwards = this.strideMode === "aim" ? strideForward > 0 : false;
      const sf = backwards ? -strideForward : strideForward;
      const sr = backwards ? -strideRight : strideRight;
      const angle2 = 90 - Math.atan2(-sf, -sr) * rad2Deg;
      const handle = onRender(() => {
        poseService.send(backwards ? "RUN_BACKWARDS_START" : "RUN_START");
        let spinePoint;
        if (this.strideMode === "aim") {
          this.loadedGroup.quaternion.copy(loadedGroupQuaternion);
          spine.outerObject3d.quaternion.copy(spineQuaternion);
          spinePoint = spine.pointAt(1e3);
        }
        const groupVecNew = computeAngle(angle2);
        const groupVec = (groupVecOld != null ? groupVecOld : computeAngle(0)).lerp(groupVecNew, 0.1);
        this.loadedGroup.lookAt(groupVec);
        groupVecOld = groupVec;
        spinePoint && spine.lookAt(spinePoint);
        if (!strideMove)
          return;
        const { x: x2, y: y4 } = endPoint(0, 0, angle2 + 90, Math.max(Math.abs(strideForward), Math.abs(strideRight)));
        this.moveForward(backwards ? y4 : -y4);
        this.moveRight(backwards ? -x2 : x2);
      });
      return () => {
        handle.cancel();
        if (this.strideMode === "aim") {
          spine.outerObject3d.quaternion.copy(spineQuaternion);
          this.loadedGroup.quaternion.copy(loadedGroupQuaternion);
        }
      };
    }, [this.strideMoveState.get, this.strideForwardState.get, this.strideRightState.get, getSpine]);
  }
  get spineName() {
    return this.spineNameState.get();
  }
  set spineName(val) {
    this.spineNameState.set(val);
  }
  get src() {
    return this.srcState.get();
  }
  set src(val) {
    this.srcState.set(val);
  }
  get animations() {
    return super.animations;
  }
  set animations(val) {
    this.animationsState.set(val);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(val) {
    this.presetState.set(val);
  }
  get strideForward() {
    return this.strideForwardState.get();
  }
  set strideForward(val) {
    this.strideForwardState.set(val);
  }
  get strideRight() {
    return this.strideRightState.get();
  }
  set strideRight(val) {
    this.strideRightState.set(val);
  }
  get strideMove() {
    return this.strideMoveState.get();
  }
  set strideMove(val) {
    this.strideMoveState.set(val);
  }
  jump(height = 10) {
    this.jumpHeight = height;
    this.poseService.send("JUMP_START");
  }
};
__publicField(Dummy, "componentName", "dummy");
__publicField(Dummy, "defaults", dummyDefaults);
__publicField(Dummy, "schema", dummySchema);

// node_modules/lingo3d/lib/interface/IFloor.js
var floorSchema = {
  ...objectManagerSchema,
  preset: String,
  repeatX: Number,
  repeatZ: Number
};
var floorDefaults = {
  ...objectManagerDefaults,
  preset: "industrial0",
  repeatX: 1,
  repeatZ: 1
};

// node_modules/lingo3d/lib/interface/IBuilding.js
var buildingSchema = {
  ...floorSchema,
  repeatY: Number
};
var buildingDefaults = {
  ...floorDefaults,
  repeatY: 1
};

// node_modules/lingo3d/lib/display/Building/Floor.js
var url = "https://unpkg.com/lingo3d-facade@1.0.0/assets/";
var makeFacade = (src, parent, rotationY) => {
  const facade = new Model();
  facade.src = src;
  facade.rotationY = rotationY;
  parent.append(facade);
  return facade;
};
var applyTransform = (facadeArray, radius2, diameter2, repeatX, repeatZ, z3) => {
  const offset = diameter2 * facadeArray.length * 0.5 - radius2;
  let i4 = 0;
  if (z3) {
    for (const facade of facadeArray) {
      facade.z += radius2 * repeatX;
      facade.x += i4++ * diameter2 - offset;
    }
    return;
  }
  for (const facade of facadeArray) {
    facade.x += radius2 * repeatZ;
    facade.z += i4++ * diameter2 - offset;
  }
};
var Floor = class extends ObjectManager {
  constructor(parent) {
    const group = new Group();
    super(group);
    __publicField(this, "presetState", new Reactive("industrial0"));
    __publicField(this, "repeatXState", new Reactive(1));
    __publicField(this, "repeatZState", new Reactive(1));
    parent.append(this);
    hiddenAppendables.add(this);
    this.createEffect(() => {
      const repeatX = Math.max(Math.floor(this.repeatXState.get()), 1);
      const repeatZ = Math.max(Math.floor(this.repeatZState.get()), 1);
      const src = url + this.presetState.get() + ".glb";
      const facade0 = (0, import_lodash.range)(repeatX).map(() => makeFacade(src, this, 0));
      const facade2 = (0, import_lodash.range)(repeatX).map(() => makeFacade(src, this, 180));
      const facade1 = (0, import_lodash.range)(repeatZ).map(() => makeFacade(src, this, 90));
      const facade3 = (0, import_lodash.range)(repeatZ).map(() => makeFacade(src, this, 270));
      const handle = facade0[0].loaded.then(() => {
        const diameter2 = facade0[0].depth;
        const radius2 = diameter2 * 0.5;
        applyTransform(facade0, radius2, diameter2, repeatX, repeatZ, false);
        applyTransform(facade2, -radius2, -diameter2, repeatX, repeatZ, false);
        applyTransform(facade1, -radius2, -diameter2, repeatX, repeatZ, true);
        applyTransform(facade3, radius2, diameter2, repeatX, repeatZ, true);
      });
      return () => {
        handle.cancel();
        for (const facade of facade0)
          facade.dispose();
        for (const facade of facade2)
          facade.dispose();
        for (const facade of facade1)
          facade.dispose();
        for (const facade of facade3)
          facade.dispose();
      };
    }, [this.presetState.get, this.repeatXState.get, this.repeatZState.get]);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(val) {
    this.presetState.set(val);
  }
  get repeatX() {
    return this.repeatXState.get();
  }
  set repeatX(val) {
    this.repeatXState.set(val);
  }
  get repeatZ() {
    return this.repeatZState.get();
  }
  set repeatZ(val) {
    this.repeatZState.set(val);
  }
};

// node_modules/lingo3d/lib/display/Building/index.js
var Building = class extends ObjectManager {
  constructor() {
    const group = new Group();
    super(group);
    __publicField(this, "presetState", new Reactive("industrial0"));
    __publicField(this, "repeatXState", new Reactive(1));
    __publicField(this, "repeatZState", new Reactive(1));
    __publicField(this, "repeatYState", new Reactive(1));
    this.scale = 10;
    this.createEffect(() => {
      const preset = this.presetState.get();
      const repeatX = this.repeatXState.get();
      const repeatZ = this.repeatZState.get();
      const repeatY = Math.max(Math.floor(this.repeatYState.get()), 1);
      const floors = (0, import_lodash.range)(repeatY).map((y4) => {
        const floor = new Floor(this);
        floor.preset = preset;
        floor.repeatX = repeatX;
        floor.repeatZ = repeatZ;
        floor.y = y4 * 100;
        return floor;
      });
      return () => {
        for (const floor of floors)
          floor.dispose();
      };
    }, [this.presetState.get, this.repeatXState.get, this.repeatZState.get, this.repeatYState.get]);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(val) {
    this.presetState.set(val);
  }
  get repeatX() {
    return this.repeatXState.get();
  }
  set repeatX(val) {
    this.repeatXState.set(val);
  }
  get repeatZ() {
    return this.repeatZState.get();
  }
  set repeatZ(val) {
    this.repeatZState.set(val);
  }
  get repeatY() {
    return this.repeatYState.get();
  }
  set repeatY(val) {
    this.repeatYState.set(val);
  }
};
__publicField(Building, "componentName", "building");
__publicField(Building, "defaults", buildingDefaults);
__publicField(Building, "schema", buildingSchema);

// node_modules/lingo3d/lib/interface/ISvgMesh.js
var svgMeshSchema = {
  ...loadedSchema,
  ...texturedBasicSchema,
  ...texturedStandardSchema
};
var svgMeshDefaults = {
  ...loadedDefaults,
  ...texturedBasicDefaults,
  ...texturedStandardDefaults
};

// node_modules/lingo3d/lib/display/SvgMesh.js
var lazyLoadSVG = lazy(() => import("./loadSVG-T6WU6XLY.js"));
var svgGeometryCache = /* @__PURE__ */ new WeakMap();
var SvgMesh = class extends Loaded {
  constructor() {
    super(...arguments);
    __publicField(this, "material", new MeshStandardMaterial());
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.material.dispose();
    return this;
  }
  load(url2) {
    return lazyLoadSVG().then((module) => module.default(url2));
  }
  resolveLoaded(svgData) {
    const loadedObject3d = new Group();
    loadedObject3d.scale.y *= -1;
    const geometries = forceGet(svgGeometryCache, svgData, () => {
      const shapes = [];
      for (const path2 of svgData.paths)
        for (const shape of path2.toShapes(true))
          shapes.push(shape);
      if (!shapes.length)
        return [];
      const testGroup = new Group();
      for (const shape of shapes) {
        const geom = new ExtrudeGeometry(shape, {
          depth: 0,
          bevelEnabled: false
        });
        geom.dispose();
        testGroup.add(new Mesh(geom));
      }
      const size2 = measure_default(testGroup);
      const result = [];
      for (const shape of shapes)
        result.push(new ExtrudeGeometry(shape, {
          depth: size2.y,
          bevelEnabled: false
        }));
      return result;
    });
    for (const geometry7 of geometries) {
      const mesh = new Mesh(geometry7, this.material);
      loadedObject3d.add(mesh);
    }
    const size = fit_default(loadedObject3d, this._src);
    !this.widthSet && (this.object3d.scale.x = size.x);
    !this.heightSet && (this.object3d.scale.y = size.y);
    !this.depthSet && (this.object3d.scale.z = size.z);
    return loadedObject3d;
  }
};
__publicField(SvgMesh, "componentName", "svgMesh");
__publicField(SvgMesh, "defaults", svgMeshDefaults);
__publicField(SvgMesh, "schema", svgMeshSchema);
applyMixins(SvgMesh, [TexturedStandardMixin, TexturedBasicMixin]);
var SvgMesh_default = SvgMesh;

// node_modules/lingo3d/lib/interface/IReflector.js
var reflectorSchema = {
  ...planeSchema
};
var reflectorDefaults = {
  ...planeDefaults,
  rotationX: -90,
  reflection: true,
  opacity: 0.01
};

// node_modules/lingo3d/lib/display/Reflector/index.js
var Reflector = class extends Plane {
  constructor() {
    super();
    this.rotationX = -90;
    this.opacity = 0.01;
  }
};
__publicField(Reflector, "componentName", "reflector");
__publicField(Reflector, "defaults", reflectorDefaults);
__publicField(Reflector, "schema", reflectorSchema);

// node_modules/lingo3d/lib/interface/ITrigger.js
var triggerSchema = {
  ...positionedSchema,
  onEnter: Function,
  onExit: Function,
  targetIds: [String, Array],
  pad: Boolean,
  radius: Number,
  interval: Number,
  helper: Boolean
};
var triggerDefaults = {
  ...positionedDefaults,
  onEnter: void 0,
  onExit: void 0,
  targetIds: void 0,
  pad: false,
  radius: 50,
  interval: 300,
  helper: true
};

// node_modules/lingo3d/lib/display/Trigger.js
var getTargets = (id) => {
  var _a2;
  return (_a2 = idMap.get(id)) != null ? _a2 : [];
};
var Trigger = class extends PositionedItem {
  constructor() {
    const group = new Group();
    super(group);
    __publicField(this, "refresh", new Reactive({}));
    __publicField(this, "onEnter");
    __publicField(this, "onExit");
    __publicField(this, "_pad", false);
    __publicField(this, "_radius", 50);
    __publicField(this, "_interval", 300);
    __publicField(this, "_helper", true);
    __publicField(this, "_targetIds");
    scene_default.add(group);
    let helper;
    this.createEffect(() => {
      const { _radius, _interval, _targetIds, _pad } = this;
      if (!_targetIds)
        return;
      const r5 = _radius * scaleDown;
      const pr = r5 * 0.2;
      let hitOld = false;
      const handle = timer(_interval, -1, () => {
        var _a2, _b;
        const { x: x2, y: y4, z: z3 } = getWorldPosition_default(this.outerObject3d);
        const targets = typeof _targetIds === "string" ? getTargets(_targetIds) : _targetIds.map((id) => [...getTargets(id)]).flat();
        let hit = false;
        for (const target of targets) {
          const { x: tx, y: ty, z: tz } = getWorldPosition_default(target.object3d);
          if (_pad) {
            const { y: sy } = getActualScale_default(target);
            hit = Math.abs(x2 - tx) < r5 && Math.abs(y4 - (ty - sy * 0.5)) < pr && Math.abs(z3 - tz) < r5;
          } else
            hit = Math.abs(x2 - tx) < r5 && Math.abs(y4 - ty) < r5 && Math.abs(z3 - tz) < r5;
          if (hit)
            break;
        }
        if (hitOld !== hit)
          if (hit) {
            (_a2 = this.onEnter) == null ? void 0 : _a2.call(this);
            helper && (helper.color = "blue");
          } else {
            (_b = this.onExit) == null ? void 0 : _b.call(this);
            helper && (helper.color = "white");
          }
        hitOld = hit;
      });
      return () => {
        handle.cancel();
      };
    }, [this.refresh.get]);
    this.createEffect(() => {
      const { _radius, _helper, _pad } = this;
      if (!_helper)
        return;
      if (getCameraRendered() !== mainCamera_default)
        return;
      const h4 = helper = _pad ? new Cylinder() : new Sphere();
      appendableRoot.delete(h4);
      group.add(h4.outerObject3d);
      h4.scale = _radius * scaleDown * 2;
      h4.opacity = 0.5;
      h4.height = _pad ? 10 : 100;
      const handle = onSelectionTarget(({ target }) => target === h4 && emitSelectionTarget(this));
      return () => {
        h4.dispose();
        helper = void 0;
        handle.cancel();
      };
    }, [this.refresh.get, getCameraRendered]);
  }
  get pad() {
    return this._pad;
  }
  set pad(val) {
    this._pad = val;
    this.refresh.set({});
  }
  get radius() {
    return this._radius;
  }
  set radius(val) {
    this._radius = val;
    this.refresh.set({});
  }
  get interval() {
    return this._interval;
  }
  set interval(val) {
    this._interval = val;
    this.refresh.set({});
  }
  get helper() {
    return this._helper;
  }
  set helper(val) {
    this._helper = val;
    this.refresh.set({});
  }
  get targetIds() {
    return this._targetIds;
  }
  set targetIds(val) {
    this._targetIds = val;
    this.refresh.set({});
  }
};
__publicField(Trigger, "componentName", "trigger");
__publicField(Trigger, "defaults", triggerDefaults);
__publicField(Trigger, "schema", triggerSchema);

// node_modules/lingo3d/lib/interface/IAudio.js
var audioSchema = {
  ...positionedSchema,
  src: String,
  autoplay: Boolean,
  loop: Boolean,
  distance: Number,
  distanceModel: String,
  maxDistance: Number,
  rolloffFactor: Number
};
var audioDefaults = {
  ...positionedDefaults,
  src: void 0,
  autoplay: false,
  loop: false,
  distance: 1,
  maxDistance: 1e4,
  distanceModel: "inverse",
  rolloffFactor: 1
};

// node_modules/lingo3d/lib/display/core/utils/makeAudioSprite.js
var makeAudioSprite_default = () => {
  const sprite = new Sprite_default();
  sprite.texture = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAABINJREFUaEPtWkuIXEUUPad7Jkr8Jiq6iBJFkmACUdGFohFMXCioqBhJVBCJTBR1oSDGhYofJH5QF2KMuBMjKvhbGhcK7gVDEI0LUXEluIqS2HXkvtxqipea7pqelrwKPmhmmKmuV6fuuZ86t4hj+EiaIfmPLUHSpZJ2kLyP5J+SSFKly2PpwGmOk9QDYAsdSFoSQniC5FMA/iC5guTfnQZiiwNgVjjsVrhJ0qsALvCN+pnkRSQPdhZIi0bnS3oFwC0O4BCAJQB+Ibma5F+dA+I06pkvuEUel/QkgBMBDIxiyad7QHzR/cSZN0l6DcBat4I5+Yz/HgCY33QLiCQDYLtt0eicEMJLJO9KAPTdCjGGdAtISiMH8ZCk5wCcCsAWa+HUQLSfLBC3UigJw1MLvy1nvlLS6wAuy9AoF8mPApIOSi08XxpYNBB7ie00ySBpWQjhBZJzI2g0DsgaD78nA7ie5Idu3WHyzE0wMZCMM98raSeAM51Ctss5GpUCWSrpdwA/kdxM8kBq9fYkEwFp0ehip9GGQhqVAjlJ0j4AKwEcJnkHyY/nA3MUEN/p+ahoITLSaGkI4VmSjyQA7P/2WeiT+kik1gmSfgRwrlvYSpoHSL6ZAzME4hHHCiCbdOQjabNn5hU+0EJtKY2KLOJ+sUrS2wDM2k3eIbmN5DttMA0QAxEBSDrFE5WFygjUflp9dJ6kFwHc4Kuxv1lSm4iiCaJc+B2uaTAYvEvyzgTMVSS/SaMZIwhJF0raDWBdknHju2yhtuvLfdGxtJiERuMsMqy1zMqxMgghfAFgk395f6/XayqEWJNFi8xI+g7AmnG0ckCLoVExEEuEcdetQpD0PYDTbIK2v0QgN0v6BIBVobNjwCyWRgsC4rs+a6W/pDlJu3wCK/ktMBw5u/jAhz2EpoVcgXGmNmRkrRXpI2lW0g8eks0qt5P8qHH8GoD4GpvMPhgMdpJ8zP/2fr/f31IbkKailrRB0lfOhd9IrrKSpiaLNGKEpOVOrzPc6deS3F8NkNQbQwjfAljvQK4jubcqIDHnhRC+BHCtA9lKck9tQBo/CSF8BuBGB3I/yV3/A5laBjkyUdGZ/bihVty8qp09ye7LPPzaSdSye13hNyker5b0tVvnV1cmq0qIuRJlT7/f31pNibKQotFU8U+PhzK+/oNVRUfdvQA2jjvqdl18eI/klpHiQ0wyE8hBL7vmZFP8V3LQaklvuCWiHDRHcndWDkrLjQUKdM+QfNS/by+atkB3AIBpZ400RXI7ybdyovZEQkJLMl3v5/1rEkCxgVNakuWUxrZkehvJz4sl09I3Z0Tse1y8O6saEbtFxbStcLq3FbYn1ml3p8bJQVH7NcXT2gofpOLDfBs9EbVyk7XodoXT7fJCuh37Rk8mUKQN0AclPV9V6y1Dt6b3J+lsb4bePYJuRQerUf47NWoV0G2jt6dNJLen++3plnWa3JL02+3CgN07qePCQNtCrWCw0htFt/q47l/hyASDui/VZOg2vOYEYIekp6u55jSGbpdIsntbE108+xeZO79vduBVJgAAAABJRU5ErkJggg==`;
  appendableRoot.delete(sprite);
  sprite.scale = 0.5;
  return sprite;
};

// node_modules/lingo3d/lib/display/utils/loaders/loadAudio.js
var cache2 = /* @__PURE__ */ new Map();
var loader = new AudioLoader();
var loadAudio_default = (url2) => forceGet(cache2, url2, () => new Promise((resolve, reject) => {
  increaseLoadingCount();
  loader.load(url2, (buffer) => {
    decreaseLoadingCount();
    resolve(Object.freeze(buffer));
  }, handleProgress, () => {
    decreaseLoadingCount();
    reject();
  });
}));

// node_modules/lingo3d/lib/display/Audio.js
var audioListener = new AudioListener();
createEffect(() => {
  const cam = getCameraRendered();
  cam.add(audioListener);
  return () => {
    cam.remove(audioListener);
  };
}, [getCameraRendered]);
var Audio = class extends PositionedItem {
  constructor() {
    const sound = new PositionalAudio(audioListener);
    super(sound);
    __publicField(this, "sound");
    __publicField(this, "_src");
    __publicField(this, "srcCount", 0);
    this.sound = sound;
    scene_default.add(sound);
    this.createEffect(() => {
      if (getCameraRendered() !== mainCamera_default)
        return;
      const sprite = makeAudioSprite_default();
      this.outerObject3d.add(sprite.outerObject3d);
      const handle = onSelectionTarget(({ target }) => {
        target === sprite && emitSelectionTarget(this);
      });
      return () => {
        sprite.dispose();
        handle.cancel();
      };
    }, [getCameraRendered]);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.sound.disconnect();
    return this;
  }
  get src() {
    return this._src;
  }
  set src(val) {
    if (this._src === val)
      return;
    this._src = val;
    const srcCount = ++this.srcCount;
    if (!val)
      return;
    loadAudio_default(val).then((buffer) => {
      if (srcCount !== this.srcCount || this.done)
        return;
      this.sound.setBuffer(buffer);
    });
  }
  get autoplay() {
    return this.sound.autoplay;
  }
  set autoplay(val) {
    this.sound.autoplay = val;
    val && this.sound.play();
  }
  get loop() {
    return this.sound.loop;
  }
  set loop(val) {
    this.sound.loop = val;
  }
  get distance() {
    return this.sound.getRefDistance();
  }
  set distance(val) {
    this.sound.setRefDistance(val);
  }
  get distanceModel() {
    return this.sound.getDistanceModel();
  }
  set distanceModel(val) {
    this.sound.setDistanceModel(val);
  }
  get maxDistance() {
    return this.sound.getMaxDistance();
  }
  set maxDistance(val) {
    this.sound.setMaxDistance(val);
  }
  get rolloffFactor() {
    return this.sound.getRolloffFactor();
  }
  set rolloffFactor(val) {
    this.sound.setRolloffFactor(val);
  }
};
__publicField(Audio, "componentName", "audio");
__publicField(Audio, "defaults", audioDefaults);
__publicField(Audio, "schema", audioSchema);

// node_modules/lingo3d/lib/events/onEditorGroupItems.js
var [emitEditorGroupItems, onEditorGroupItems] = event_default();

// node_modules/lingo3d/lib/interface/IGroup.js
var groupSchema = {
  ...objectManagerSchema
};
var groupDefaults = {
  ...objectManagerDefaults
};

// node_modules/lingo3d/lib/states/useMultipleSelectionEnabled.js
var [setMultipleSelectionEnabled, getMultipleSelectionEnabled] = store(true);

// node_modules/lingo3d/lib/display/Group.js
var Group2 = class extends ObjectManager {
  constructor() {
    super(new Group());
  }
};
__publicField(Group2, "componentName", "group");
__publicField(Group2, "defaults", groupDefaults);
__publicField(Group2, "schema", groupSchema);
createEffect(() => {
  const enabled = getMultipleSelectionEnabled();
  const targets = getMultipleSelectionTargets();
  if (!targets.length || !enabled)
    return;
  const group = new Group();
  scene_default.add(group);
  const groupManager = new SimpleObjectManager_default(group);
  multipleSelectionGroupManagers.add(groupManager);
  setSelectionTarget(groupManager);
  const parentEntries = [];
  for (const { outerObject3d: target } of targets) {
    if (!target.parent)
      continue;
    parentEntries.push([target, target.parent]);
    group.attach(target);
  }
  box3.setFromObject(group);
  for (const [object, parent] of parentEntries)
    parent.attach(object);
  group.position.copy(box3.getCenter(vector3));
  for (const [object] of parentEntries)
    group.attach(object);
  let consolidated = false;
  const handle = onEditorGroupItems(() => {
    if (!targets.length || consolidated)
      return;
    consolidated = true;
    const consolidatedGroup = new Group2();
    consolidatedGroup.outerObject3d.position.copy(group.position);
    for (const target of targets)
      consolidatedGroup.attach(target);
    emitSelectionTarget(consolidatedGroup);
  });
  return () => {
    emitSelectionTarget();
    if (!groupManager.done && !consolidated)
      for (const [object, parent] of parentEntries)
        parent.attach(object);
    setSelectionTarget(void 0);
    groupManager.dispose();
    scene_default.remove(group);
    handle.cancel();
  };
}, [getMultipleSelectionTargets, getMultipleSelectionEnabled]);

// node_modules/lingo3d/lib/interface/ISkybox.js
var skyboxSchema = {
  ...eventLoopSchema,
  texture: [String, Array]
};
var skyboxDefaults = {
  ...eventLoopDefaults,
  texture: void 0
};

// node_modules/lingo3d/lib/display/Skybox.js
var Skybox = class extends EventLoopItem {
  constructor() {
    super(new Group());
    __publicField(this, "_texture");
    pushSkyboxStack(this);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    pullSkyboxStack(this);
    return this;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    setSkyboxStack([...getSkyboxStack()]);
  }
};
__publicField(Skybox, "componentName", "skybox");
__publicField(Skybox, "defaults", skyboxDefaults);
__publicField(Skybox, "schema", skyboxSchema);

// node_modules/lingo3d/lib/interface/ISky.js
var skySchema = {
  ...eventLoopSchema
};
var skyDefaults = {
  ...eventLoopDefaults
};

// node_modules/lingo3d/lib/interface/ICamera.js
var cameraSchema = {
  ...cameraBaseSchema
};
var cameraDefaults = {
  ...cameraBaseDefaults
};

// node_modules/lingo3d/lib/display/cameras/Camera.js
var Camera = class extends CameraBase {
  constructor() {
    super(new PerspectiveCamera(75, 1, camNear, camFar));
  }
};
__publicField(Camera, "componentName", "camera");
__publicField(Camera, "defaults", cameraDefaults);
__publicField(Camera, "schema", cameraSchema);

// node_modules/lingo3d/lib/interface/ICharacterCamera.js
var characterCameraSchema = {
  ...cameraBaseSchema,
  lockTargetRotation: [Boolean, String]
};
var characterCameraDefaults = {
  ...cameraBaseDefaults,
  lockTargetRotation: true
};

// node_modules/lingo3d/lib/interface/IThirdPersonCamera.js
var thirdPersonCameraSchema = {
  ...characterCameraSchema
};
var thirdPersonCameraDefaults = {
  ...characterCameraDefaults,
  innerZ: 300
};

// node_modules/lingo3d/lib/display/core/CharacterCamera.js
var CharacterCamera = class extends OrbitCameraBase {
  constructor() {
    super(new PerspectiveCamera(75, 1, camNear, camFar));
    __publicField(this, "lockTargetRotation", true);
    const cam = this.camera;
    scene_default.attach(cam);
    this.then(() => scene_default.remove(cam));
    this.createEffect(() => {
      const target = this.targetState.get();
      if (!target)
        return;
      if ("frustumCulled" in target)
        target.frustumCulled = false;
    }, [this.targetState.get]);
    const followTarget = (target, slerp) => {
      euler.setFromQuaternion(target.outerObject3d.quaternion);
      euler.y += Math.PI;
      if (slerp) {
        quaternion.setFromEuler(euler);
        this.outerObject3d.quaternion.slerp(quaternion, 0.1);
      } else
        this.outerObject3d.setRotationFromEuler(euler);
      this.updateAngle();
    };
    const lockTarget = (target, slerp) => {
      euler.setFromQuaternion(this.outerObject3d.quaternion);
      euler.x = 0;
      euler.z = 0;
      euler.y += Math.PI;
      if (slerp) {
        quaternion.setFromEuler(euler);
        target.outerObject3d.quaternion.slerp(quaternion, 0.1);
      } else
        target.outerObject3d.setRotationFromEuler(euler);
    };
    let transformControlRotating = false;
    this.createEffect(() => {
      const target = this.targetState.get();
      if (!target)
        return;
      followTarget(target, false);
      let targetMoved = false;
      let [x2, y4, z3] = [0, 0, 0];
      const handle0 = onBeforeRender(() => {
        const { x: x0, y: y0, z: z0 } = target.outerObject3d.position;
        targetMoved = x0 !== x2 || y0 !== y4 || z0 !== z3;
        [x2, y4, z3] = [x0, y0, z0];
      });
      const handle1 = onBeforeRender(() => {
        this.outerObject3d.position.copy(target.outerObject3d.position);
        if (!this.lockTargetRotation)
          return;
        if (this.lockTargetRotation === "follow" || transformControlRotating) {
          followTarget(target, false);
          return;
        }
        if (this.lockTargetRotation === "dynamic-lock") {
          targetMoved && lockTarget(target, true);
          return;
        }
        if (this.lockTargetRotation === "dynamic-follow") {
          targetMoved && followTarget(target, true);
          return;
        }
        lockTarget(target, false);
      });
      return () => {
        handle0.cancel();
        handle1.cancel();
      };
    }, [this.targetState.get]);
    this.createEffect(() => {
      const target = this.targetState.get();
      const selectionTarget = getSelectionTarget();
      const dragging = getTransformControlsDragging();
      const mode = getTransformControlsMode();
      const rotating = target && target === selectionTarget && dragging && mode === "rotate";
      if (!rotating)
        return;
      transformControlRotating = true;
      return () => {
        transformControlRotating = false;
      };
    }, [this.targetState.get, getSelectionTarget, getTransformControlsDragging, getTransformControlsMode]);
  }
};
__publicField(CharacterCamera, "defaults", characterCameraDefaults);
__publicField(CharacterCamera, "schema", characterCameraSchema);

// node_modules/lingo3d/lib/display/cameras/ThirdPersonCamera.js
var ThirdPersonCamera = class extends CharacterCamera {
  constructor() {
    super();
    this.innerZ = 300;
    this.orbitMode = true;
    import("./enableBVHCamera-MHUMQMX2.js").then((module) => module.default.call(this));
  }
};
__publicField(ThirdPersonCamera, "componentName", "thirdPersonCamera");
__publicField(ThirdPersonCamera, "defaults", thirdPersonCameraDefaults);
__publicField(ThirdPersonCamera, "schema", thirdPersonCameraSchema);

// node_modules/lingo3d/lib/display/cameras/FirstPersonCamera.js
var FirstPersonCamera = class extends CharacterCamera {
  constructor() {
    super();
    __publicField(this, "innerYSetState", new Reactive(false));
    const cam = this.camera;
    this.watch(onBeforeRender(() => {
      cam.position.copy(getWorldPosition_default(this.object3d));
      cam.quaternion.copy(getWorldQuaternion_default(this.object3d));
    }));
    this.createEffect(() => {
      const target = this.targetState.get();
      const innerYSet = this.innerYSetState.get();
      if (!target || !(target instanceof SimpleObjectManager_default) || innerYSet)
        return;
      super.innerY = target.height * 0.4;
      return () => {
        super.innerY = 0;
      };
    }, [this.targetState.get, this.innerYSetState.get]);
  }
  get innerY() {
    return super.innerY;
  }
  set innerY(val) {
    super.innerY = val;
    this.innerYSetState.set(true);
  }
};
__publicField(FirstPersonCamera, "componentName", "firstPersonCamera");

// node_modules/lingo3d/lib/display/core/utils/makeLightSprite.js
var makeLightSprite_default = () => {
  const sprite = new Sprite_default();
  sprite.texture = `data:image/png;base64,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`;
  appendableRoot.delete(sprite);
  sprite.scale = 0.5;
  return sprite;
};

// node_modules/lingo3d/lib/display/core/LightBase.js
var LightBase = class extends ObjectManager {
  constructor(light, Helper) {
    super(light);
    this.createEffect(() => {
      if (getCameraRendered() !== mainCamera_default)
        return;
      const handle = new Cancellable();
      const sprite = makeLightSprite_default();
      handle.watch(onSelectionTarget(({ target }) => {
        target === sprite && emitSelectionTarget(this);
      }));
      if (Helper) {
        const helper = new Helper(this.object3d);
        scene_default.add(helper);
        helper.add(sprite.outerObject3d);
        if ("update" in helper)
          handle.watch(onBeforeRender(() => {
            helper.update();
          }));
        handle.then(() => {
          helper.dispose();
          scene_default.remove(helper);
        });
      } else
        this.outerObject3d.add(sprite.outerObject3d);
      return () => {
        sprite.dispose();
        handle.cancel();
      };
    }, [getCameraRendered]);
  }
  dispose() {
    if (this.done)
      return this;
    super.dispose();
    this.object3d.dispose();
    return this;
  }
  get color() {
    return "#" + this.object3d.color.getHexString();
  }
  set color(val) {
    this.object3d.color = new Color(val);
  }
  get intensity() {
    return this.object3d.intensity;
  }
  set intensity(val) {
    this.object3d.intensity = val;
  }
};

// node_modules/lingo3d/lib/interface/ILightBase.js
var lightBaseSchema = {
  ...objectManagerSchema,
  color: String,
  intensity: Number
};
var lightBaseDefaults = {
  ...objectManagerDefaults,
  color: "#ffffff",
  intensity: 1
};

// node_modules/lingo3d/lib/interface/ILight.js
var lightSchema = {
  ...lightBaseSchema
};
var lightDefaults = {
  ...lightBaseDefaults
};

// node_modules/lingo3d/lib/interface/IAmbientLight.js
var ambientLightSchema = {
  ...lightSchema
};
var ambientLightDefaults = {
  ...lightDefaults
};

// node_modules/lingo3d/lib/display/lights/AmbientLight.js
var AmbientLight2 = class extends LightBase {
  constructor() {
    super(new AmbientLight());
  }
};
__publicField(AmbientLight2, "componentName", "ambientLight");
__publicField(AmbientLight2, "defaults", ambientLightDefaults);
__publicField(AmbientLight2, "schema", ambientLightSchema);

// node_modules/three/examples/jsm/helpers/RectAreaLightHelper.js
var RectAreaLightHelper = class extends Line {
  constructor(light, color2) {
    const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    const geometry7 = new BufferGeometry();
    geometry7.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry7.computeBoundingSphere();
    const material = new LineBasicMaterial({ fog: false });
    super(geometry7, material);
    this.light = light;
    this.color = color2;
    this.type = "RectAreaLightHelper";
    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    const geometry22 = new BufferGeometry();
    geometry22.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry22.computeBoundingSphere();
    this.add(new Mesh(geometry22, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
      this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const c5 = this.material.color;
      const max = Math.max(c5.r, c5.g, c5.b);
      if (max > 1)
        c5.multiplyScalar(1 / max);
      this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
    this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
};

// node_modules/lingo3d/lib/interface/IAreaLight.js
var areaLightSchema = {
  ...lightBaseSchema,
  helper: Boolean
};
var areaLightDefaults = {
  ...lightBaseDefaults,
  depth: 0,
  scaleZ: 0,
  helper: true
};

// node_modules/lingo3d/lib/display/lights/AreaLight.js
var lazyInit = lazy(async () => {
  const { RectAreaLightUniformsLib } = await import("./RectAreaLightUniformsLib-FRSRW7NE.js");
  RectAreaLightUniformsLib.init();
});
var AreaLight = class extends ObjectManager {
  constructor() {
    super(new Group());
    __publicField(this, "light");
    __publicField(this, "helperState", new Reactive(true));
    __publicField(this, "_color");
    __publicField(this, "_intensity");
    __publicField(this, "_width");
    __publicField(this, "_height");
    __publicField(this, "_scaleX");
    __publicField(this, "_scaleY");
    (async () => {
      await lazyInit();
      if (this.done)
        return;
      const light = this.light = new RectAreaLight(this._color, this._intensity, this.width * this.scaleX * scaleDown, this.height * this.scaleY * scaleDown);
      this.object3d.add(light);
      this.then(() => light.dispose());
      this.createEffect(() => {
        if (getTransformControlsMode() !== "scale" || getSelectionTarget() !== this)
          return;
        const handle = onTransformControls(() => {
          const { x: x2, y: y4 } = this.outerObject3d.scale;
          this.scaleX = x2;
          this.scaleY = y4;
        });
        return () => {
          handle.cancel();
        };
      }, [getTransformControlsMode, getSelectionTarget]);
      this.createEffect(() => {
        if (getCameraRendered() !== mainCamera_default || !this.helperState.get())
          return;
        const helper = new RectAreaLightHelper(light);
        scene_default.add(helper);
        return () => {
          helper.dispose();
          scene_default.remove(helper);
        };
      }, [getCameraRendered, this.helperState.get]);
    })();
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(val) {
    this.helperState.set(val);
  }
  get color() {
    var _a2;
    return (_a2 = this._color) != null ? _a2 : "#ffffff";
  }
  set color(val) {
    this._color = val;
    this.light && (this.light.color = new Color(val));
  }
  get intensity() {
    var _a2;
    return (_a2 = this._intensity) != null ? _a2 : 1;
  }
  set intensity(val) {
    this._intensity = val;
    this.light && (this.light.intensity = val);
  }
  get width() {
    var _a2;
    return (_a2 = this._width) != null ? _a2 : 100;
  }
  set width(val) {
    this._width = val;
    this.light && (this.light.width = val * this.scaleX * scaleDown);
  }
  get height() {
    var _a2;
    return (_a2 = this._height) != null ? _a2 : 100;
  }
  set height(val) {
    this._height = val;
    this.light && (this.light.height = val * this.scaleY * scaleDown);
  }
  get scaleX() {
    var _a2;
    return (_a2 = this._scaleX) != null ? _a2 : 1;
  }
  set scaleX(val) {
    this._scaleX = val;
    this.light && (this.light.width = val * this.width * scaleDown);
  }
  get scaleY() {
    var _a2;
    return (_a2 = this._scaleY) != null ? _a2 : 1;
  }
  set scaleY(val) {
    this._scaleY = val;
    this.light && (this.light.height = val * this.height * scaleDown);
  }
  get depth() {
    return 0;
  }
  set depth(_4) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(_4) {
  }
};
__publicField(AreaLight, "componentName", "areaLight");
__publicField(AreaLight, "defaults", areaLightDefaults);
__publicField(AreaLight, "schema", areaLightSchema);

// node_modules/lingo3d/lib/interface/IDirectionalLight.js
var directionalLightSchema = {
  ...lightSchema
};
var directionalLightDefaults = {
  ...lightDefaults
};

// node_modules/lingo3d/lib/display/lights/DirectionalLight.js
var DirectionalLight2 = class extends LightBase {
  constructor() {
    super(new DirectionalLight(), DirectionalLightHelper);
    this.innerY = 0;
  }
};
__publicField(DirectionalLight2, "componentName", "directionalLight");
__publicField(DirectionalLight2, "defaults", directionalLightDefaults);
__publicField(DirectionalLight2, "schema", directionalLightSchema);

// node_modules/lingo3d/lib/interface/ISkyLight.js
var skyLightSchema = {
  ...lightBaseSchema,
  groundColor: String
};
var skyLightDefaults = {
  ...lightBaseDefaults,
  groundColor: "#ffffff"
};

// node_modules/lingo3d/lib/display/lights/SkyLight.js
var Skylight = class extends LightBase {
  constructor() {
    super(new HemisphereLight(), HemisphereLightHelper);
    this.innerY = 0;
  }
  get groundColor() {
    return "#" + this.object3d.groundColor.getHexString();
  }
  set groundColor(val) {
    this.object3d.groundColor = new Color(val);
  }
};
__publicField(Skylight, "componentName", "skyLight");
__publicField(Skylight, "defaults", skyLightDefaults);
__publicField(Skylight, "schema", skyLightSchema);

// node_modules/lingo3d/lib/interface/IPointLight.js
var pointLightSchema = {
  ...lightBaseSchema,
  decay: Number,
  distance: Number
};
var pointLightDefaults = {
  ...lightBaseDefaults,
  decay: 1,
  distance: 0
};

// node_modules/lingo3d/lib/display/core/mixins/PointLightMixin.js
var PointLightMixin = class {
  get decay() {
    return this.object3d.decay;
  }
  set decay(val) {
    this.object3d.decay = val;
  }
  get distance() {
    return this.object3d.distance;
  }
  set distance(val) {
    this.object3d.distance = val;
  }
};

// node_modules/lingo3d/lib/display/lights/PointLight.js
var PointLight2 = class extends LightBase {
  constructor() {
    super(new PointLight(), PointLightHelper);
  }
};
__publicField(PointLight2, "componentName", "pointLight");
__publicField(PointLight2, "defaults", pointLightDefaults);
__publicField(PointLight2, "schema", pointLightSchema);
applyMixins(PointLight2, [PointLightMixin]);
var PointLight_default = PointLight2;

// node_modules/lingo3d/lib/interface/ISpotLight.js
var spotLightSchema = {
  ...lightBaseSchema,
  angle: Number,
  penumbra: Number
};
var spotLightDefaults = {
  ...lightBaseDefaults,
  angle: 1,
  penumbra: 0
};

// node_modules/lingo3d/lib/display/lights/SpotLight.js
var SpotLight2 = class extends LightBase {
  constructor() {
    super(new SpotLight(), SpotLightHelper);
    this.innerY = 0;
  }
  get angle() {
    return this.object3d.angle;
  }
  set angle(val) {
    this.object3d.angle = val;
  }
  get penumbra() {
    return this.object3d.penumbra;
  }
  set penumbra(val) {
    this.object3d.penumbra = val;
  }
};
__publicField(SpotLight2, "componentName", "spotLight");
__publicField(SpotLight2, "defaults", spotLightDefaults);
__publicField(SpotLight2, "schema", spotLightSchema);
applyMixins(SpotLight2, [PointLightMixin]);
var SpotLight_default = SpotLight2;

// node_modules/lingo3d/lib/interface/IKeyboard.js
var keyboardSchema = {
  ...eventLoopSchema,
  onKeyPress: Function,
  onKeyUp: Function,
  onKeyDown: Function
};
var keyboardDefaults = {
  ...eventLoopDefaults,
  onKeyPress: void 0,
  onKeyUp: void 0,
  onKeyDown: void 0
};

// node_modules/lingo3d/lib/states/useSelectionBlockKeyboard.js
var [setSelectionBlockKeyboard, getSelectionBlockKeyboard] = store(true);

// node_modules/lingo3d/lib/api/keyboard.js
var [emitDown, onDown] = event_default();
var [emitUp, onUp] = event_default();
var [emitPress, onPress] = event_default();
var isPressed2 = /* @__PURE__ */ new Set();
var processKey = (str) => {
  str = str.length === 1 ? str.toLowerCase() : str;
  if (str === " ")
    str = "Space";
  return str;
};
createEffect(() => {
  if (getEditorActive() && getSelectionBlockKeyboard())
    return;
  const handle = onBeforeRender(() => isPressed2.size > 0 && emitPress());
  const handleKeyDown = (e5) => {
    const key = processKey(e5.key);
    isPressed2.add(key);
    emitDown(key);
  };
  const handleKeyUp = (e5) => {
    const key = processKey(e5.key);
    isPressed2.delete(key);
    emitUp(key);
    !isPressed2.size && emitPress();
  };
  handle.watch(onKeyClear(() => {
    if (!isPressed2.size)
      return;
    const pressed = [...isPressed2];
    isPressed2.clear();
    for (const key of pressed)
      emitUp(key);
  }));
  document.addEventListener("keydown", handleKeyDown);
  document.addEventListener("keyup", handleKeyUp);
  return () => {
    handle.cancel();
    document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("keyup", handleKeyUp);
  };
}, [getEditorActive, getSelectionBlockKeyboard]);
var Keyboard = class extends EventLoopItem {
  constructor() {
    super(new Group());
    __publicField(this, "onKeyPress");
    __publicField(this, "onKeyUp");
    __publicField(this, "onKeyDown");
    this.watch(onPress(() => {
      if (!this.onKeyPress)
        return;
      if (!isPressed2.size) {
        this.onKeyPress("", isPressed2);
        return;
      }
      for (const key of isPressed2)
        this.onKeyPress(key, isPressed2);
    }));
    this.watch(onUp((key) => {
      var _a2;
      return (_a2 = this.onKeyUp) == null ? void 0 : _a2.call(this, key, isPressed2);
    }));
    this.watch(onDown((key) => {
      var _a2;
      return (_a2 = this.onKeyDown) == null ? void 0 : _a2.call(this, key, isPressed2);
    }));
  }
};
__publicField(Keyboard, "componentName", "keyboard");
__publicField(Keyboard, "defaults", keyboardDefaults);
__publicField(Keyboard, "schema", keyboardSchema);
var keyboard = new Keyboard();
appendableRoot.delete(keyboard);
var keyboard_default = keyboard;

// node_modules/lingo3d/lib/api/gamepad.js
"getGamepads" in navigator && onBeforeRender(() => {
  for (const pad of navigator.getGamepads()) {
    if (!pad)
      continue;
    for (let i4 = 0; i4 < pad.buttons.length; i4++) {
      const button = pad.buttons[i4];
      const pct = Math.round(button.value * 100) + "%";
      button.pressed && console.log(i4, button.value, button.pressed, pct);
    }
    for (let i4 = 0; i4 < pad.axes.length; i4++) {
      const val = Number(pad.axes[i4].toFixed(2));
      val !== 0 && console.log(i4, val);
    }
  }
});

// node_modules/lingo3d/lib/api/createProxy.js
var createProxy_default = () => {
  let instance;
  const data = {};
  return new Proxy(data, {
    get(_4, prop) {
      var _a2;
      return (_a2 = instance == null ? void 0 : instance[prop]) != null ? _a2 : data[prop];
    },
    set(_4, prop, val) {
      if (prop === "__target") {
        instance = val;
        for (const [key, value] of Object.entries(data))
          val[key] = value;
        return true;
      }
      data[prop] = val;
      instance && (instance[prop] = val);
      return true;
    }
  });
};

// node_modules/lingo3d/lib/api/settings.js
var defaultSkybox = new Skybox();
appendableRoot.delete(defaultSkybox);
var settings_default = {
  get defaultFog() {
    return getDefaultFog();
  },
  set defaultFog(value) {
    setDefaultFog(value);
  },
  get defaultLight() {
    return getDefaultLight();
  },
  set defaultLight(value) {
    setDefaultLight(value);
  },
  get defaultLightScale() {
    return getDefaultLightScale();
  },
  set defaultLightScale(value) {
    setDefaultLightScale(value);
  },
  get skybox() {
    return defaultSkybox.texture;
  },
  set skybox(value) {
    defaultSkybox.texture = value;
  },
  get defaultOrbitControls() {
    return getOrbitControls();
  },
  set defaultOrbitControls(value) {
    setOrbitControls(value);
  },
  get gridHelper() {
    return getGridHelper();
  },
  set gridHelper(value) {
    setGridHelper(value);
  },
  get gridHelperSize() {
    return getGridHelperSize();
  },
  set gridHelperSize(value) {
    setGridHelperSize(value);
  },
  get gravity() {
    return getGravity();
  },
  set gravity(value) {
    setGravity(value);
  },
  get repulsion() {
    return getRepulsion();
  },
  set repulsion(value) {
    setRepulsion(value);
  },
  get autoMount() {
    return getAutoMount();
  },
  set autoMount(value) {
    setAutoMount(value);
  },
  get antiAlias() {
    return getAntiAlias();
  },
  set antiAlias(value) {
    setAntiAlias(value);
  },
  get pixelRatio() {
    return getPixelRatio();
  },
  set pixelRatio(value) {
    setPixelRatio(value);
  },
  get logarithmicDepth() {
    return getLogarithmicDepth();
  },
  set logarithmicDepth(value) {
    setLogarithmicDepth(value);
  },
  get exposure() {
    return getExposure();
  },
  set exposure(value) {
    setExposure(value);
  },
  get pbr() {
    return getPBR();
  },
  set pbr(value) {
    setPBR(value);
  },
  get bloom() {
    return getBloom();
  },
  set bloom(value) {
    setBloom(value);
  },
  get bloomStrength() {
    return getBloomStrength();
  },
  set bloomStrength(value) {
    setBloomStrength(value);
  },
  get bloomRadius() {
    return getBloomRadius();
  },
  set bloomRadius(value) {
    setBloomRadius(value);
  },
  get bloomThreshold() {
    return getBloomThreshold();
  },
  set bloomThreshold(value) {
    setBloomThreshold(value);
  },
  get ambientOcclusion() {
    return getAmbientOcclusion();
  },
  set ambientOcclusion(value) {
    setAmbientOcclusion(value);
  },
  get outlineColor() {
    return getOutlineColor();
  },
  set outlineColor(value) {
    setOutlineColor(value);
  },
  get outlineHiddenColor() {
    return getOutlineHiddenColor();
  },
  set outlineHiddenColor(value) {
    setOutlineHiddenColor(value);
  },
  get outlinePattern() {
    return getOutlinePattern();
  },
  set outlinePattern(value) {
    setOutlinePattern(value);
  },
  get outlinePulse() {
    return getOutlinePulse();
  },
  set outlinePulse(value) {
    setOutlinePulse(value);
  },
  get outlineStrength() {
    return getOutlineStrength();
  },
  set outlineStrength(value) {
    setOutlineStrength(value);
  },
  get outlineThickness() {
    return getOutlineThickness();
  },
  set outlineThickness(value) {
    setOutlineThickness(value);
  },
  get lensDistortion() {
    return getLensDistortion();
  },
  set lensDistortion(val) {
    setLensDistortion(val);
  },
  get lensIor() {
    return getLensIor();
  },
  set lensIor(val) {
    setLensIor(val);
  },
  get lensBand() {
    return getLensBand();
  },
  set lensBand(val) {
    setLensBand(val);
  },
  get texture() {
    return getBackgroundImage();
  },
  set texture(value) {
    setBackgroundImage(value);
  },
  get color() {
    return getBackgroundColor();
  },
  set color(value) {
    setBackgroundColor(value);
  }
};

// node_modules/@lincode/filetypes/lib/index.js
var extensionMap = /* @__PURE__ */ new Map();
var getExtensionType = (val) => {
  var _a2, _b;
  return extensionMap.get((_b = (_a2 = splitFileName(val)[1]) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b !== void 0 ? _b : "");
};
var register = (type2, extensions) => {
  for (const ext of extensions)
    extensionMap.set(ext, type2);
  return extensions;
};
var imageExtensions = register("image", [
  "jpg",
  "jpeg",
  "gif",
  "png",
  "svg",
  "tiff",
  "webp",
  "hdr"
]);
var audioExtensions = register("audio", [
  "m4a",
  "mp3",
  "wav",
  "wma",
  "ogg",
  "flax",
  "flac",
  "aac"
]);
var plainTextExtensions = register("plainText", [
  "ls",
  "js",
  "ts",
  "jsx",
  "tsx",
  "py",
  "txt",
  "md",
  "json",
  "yaml",
  "c",
  "cpp",
  "h",
  "hpp",
  "css",
  "scss",
  "sass",
  "html"
]);
var modelExtensions = register("model", [
  "gltf",
  "glb",
  "fbx"
]);
var sceneExtensions = register("scene", [
  "l3d"
]);

// node_modules/lingo3d/lib/display/utils/loaders/loadTexturePromise.js
var cache3 = /* @__PURE__ */ new Map();
var loadTexturePromise_default = (url2) => forceGet(cache3, url2, () => new Promise((resolve) => {
  const texture = loadTexture_default(url2, () => resolve(texture));
}));

// node_modules/lingo3d/lib/api/preload.js
var preload_default = async (urls, total, onProgress) => {
  var _a2;
  const promises = [];
  for (const url2 of urls) {
    const filetype = getExtensionType(url2);
    if (!filetype)
      continue;
    switch (filetype) {
      case "image":
        promises.push(loadTexturePromise_default(url2));
        break;
      case "model":
        const extension = (_a2 = splitFileName(url2)[1]) == null ? void 0 : _a2.toLowerCase();
        if (extension === "fbx")
          promises.push((await lazyLoadFBX()).default(url2, false));
        else if (extension === "gltf" || extension === "glb")
          promises.push((await lazyLoadGLTF()).default(url2, false));
        break;
      case "audio":
      case "plainText":
      case "scene":
        break;
      default:
        assertExhaustive(filetype);
    }
  }
  let totalBytes = 0;
  if (typeof total === "number")
    totalBytes = total;
  else {
    total = total.toLowerCase();
    if (total.endsWith("kb"))
      totalBytes = parseFloat(total) * 1024 * 1024;
    else if (total.endsWith("mb"))
      totalBytes = parseFloat(total) * 1024 * 1024 * 1024;
    else if (total.endsWith("gb"))
      totalBytes = parseFloat(total) * 1024 * 1024 * 1024 * 1024;
    else
      throw new Error("invalid preload total value: " + total);
  }
  const interval = setInterval(() => {
    onProgress == null ? void 0 : onProgress(totalBytes <= 0 ? 0 : Math.min(bytesLoaded_default[0] / totalBytes * 100, 99));
  }, 100);
  await Promise.all(promises);
  clearInterval(interval);
  await new Promise((resolve) => {
    const handle = new Cancellable();
    handle.watch(getLoadingCount((count) => {
      if (count > 0)
        return;
      handle.cancel();
      resolve();
    }));
  });
  onProgress == null ? void 0 : onProgress(100);
};

// node_modules/lingo3d/lib/api/screenshot.js
var screenshot_default = {
  toBlob: async () => {
    return new Promise((resolve) => {
      const handle = onAfterRender(() => {
        var _a2;
        handle.cancel();
        (_a2 = getRenderer()) == null ? void 0 : _a2.domElement.toBlob((blob) => blob && resolve(blob));
      });
    });
  },
  toDataURL: async (type2, quality) => {
    return new Promise((resolve) => {
      const handle = onAfterRender(() => {
        handle.cancel();
        const renderer = getRenderer();
        renderer && resolve(renderer.domElement.toDataURL(type2, quality));
      });
    });
  }
};

// node_modules/lingo3d/lib/events/onApplySetup.js
var [emitApplySetup, onApplySetup] = event_default();

// node_modules/lingo3d/lib/interface/ISetup.js
var setupDefaults = {
  ...settings_default
};

// node_modules/lingo3d/lib/api/serializer/applySetup.js
var applySetup_default = debounce((node) => {
  var _a2;
  for (const key of Object.keys(settings_default)) {
    if (key === "autoMount")
      continue;
    settings_default[key] = (_a2 = node[key]) != null ? _a2 : setupDefaults[key];
  }
  emitApplySetup();
}, 0, "trailing");

// node_modules/lingo3d/lib/api/serializer/types.js
var nonSerializedProperties = [
  "type",
  "children",
  "scale",
  "rotation",
  "velocity",
  "target",
  "proxy"
];
var nonEditorSettings = [
  "defaultOrbitControls",
  "autoMount",
  "texture",
  "color"
];
var nonSerializedSettings = [
  ...nonEditorSettings,
  "gridHelper",
  "gridHelperSize"
];

// node_modules/lingo3d/lib/api/serializer/serialize.js
var serialize = (children2) => {
  const dataParent = [];
  for (const child of children2) {
    if (hiddenAppendables.has(child))
      continue;
    const { componentName, schema, defaults } = child.constructor;
    const data = { type: componentName };
    for (const key of Object.keys(schema)) {
      if (nonSerializedProperties.includes(key))
        continue;
      let value;
      if (key === "animations") {
        value = child.loadedAnims;
        if (!value)
          continue;
      } else if (key === "animation") {
        value = child.animationName;
        if (value === void 0)
          continue;
      } else
        value = child[key];
      if (value === defaults[key] || typeof value === "function")
        continue;
      if (typeof value === "number")
        value = Number(value.toFixed(2));
      data[key] = value;
    }
    child.children && (data.children = serialize(child.children));
    dataParent.push(data);
  }
  return dataParent;
};
var serialize_default = (children2 = appendableRoot) => {
  const data = serialize(children2 instanceof Appendable ? [children2] : children2);
  const settingsDiff = { type: "setup" };
  for (const [key, value] of Object.entries((0, import_lodash.omit)(settings_default, nonSerializedSettings)))
    if (setupDefaults[key] !== value)
      settingsDiff[key] = value;
  if (Object.keys(settingsDiff).length)
    data.push(settingsDiff);
  return data;
};

// node_modules/lingo3d/lib/api/serializer/createObject.js
var record = type({
  "group": () => new Group2(),
  "model": () => new Model(),
  "svgMesh": () => new SvgMesh_default(),
  "dummy": () => new Dummy(),
  "building": () => new Building(),
  "reflector": () => new Reflector(),
  "sprite": () => new Sprite_default(),
  "trigger": () => new Trigger(),
  "audio": () => new Audio(),
  "camera": () => new Camera(),
  "thirdPersonCamera": () => new ThirdPersonCamera(),
  "firstPersonCamera": () => new FirstPersonCamera(),
  "orbitCamera": () => new OrbitCamera(),
  "ambientLight": () => new AmbientLight2(),
  "areaLight": () => new AreaLight(),
  "directionalLight": () => new DirectionalLight2(),
  "skyLight": () => new Skylight(),
  "pointLight": () => new PointLight_default(),
  "spotLight": () => new SpotLight_default(),
  "circle": () => new Circle(),
  "cone": () => new Cone(),
  "cube": () => new Cube(),
  "cylinder": () => new Cylinder(),
  "octahedron": () => new Octahedron(),
  "plane": () => new Plane(),
  "sphere": () => new Sphere(),
  "tetrahedron": () => new Tetrahedron(),
  "torus": () => new Torus(),
  "skybox": () => new Skybox(),
  "environment": () => new Environment()
});
var createObject_default = (type2) => record[type2]();

// node_modules/lingo3d/lib/api/serializer/deserialize.js
var nodeToObjectManager = (node, loadedResolvables) => {
  var _a2;
  if (node.type === "setup") {
    applySetup_default(node);
    return;
  }
  if (node.type === "animation")
    return;
  const object = createObject_default(node.type);
  loadedResolvables && object instanceof Loaded && loadedResolvables.push(object.loaded);
  Object.assign(object, (0, import_lodash.omit)(node, nonSerializedProperties));
  (_a2 = node.children) == null ? void 0 : _a2.map((n3) => nodeToObjectManager(n3, loadedResolvables)).forEach((c5) => c5 && object.append(c5));
  return object;
};
var deserialize_default = (graph, loadedResolvables) => graph.map((n3) => nodeToObjectManager(n3, loadedResolvables));

// node_modules/lingo3d/lib/index.js
preventTreeShake(engine_default);
var lib_default = {};

// node_modules/lingo3d-react/lib/components/World.js
var import_react2 = __toESM(require_react());

// node_modules/lingo3d-react/lib/components/logical/Setup.js
var import_react = __toESM(require_react());
var Setup = (props) => {
  (0, import_react.useLayoutEffect)(() => {
    applySetup_default(props);
    return () => {
      applySetup_default({});
    };
  }, [JSON.stringify(props)]);
  return null;
};
var Setup_default = Setup;

// node_modules/lingo3d-react/lib/components/logical/HTML/htmlContainer.js
var htmlContainer = document.createElement("div");
Object.assign(htmlContainer.style, {
  position: "absolute",
  left: "0px",
  top: "0px",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  userSelect: "none"
});
var htmlContainer_default = htmlContainer;

// node_modules/lingo3d-react/lib/components/World.js
preventTreeShake(lib_default);
var World = ({ style: style3, className, position, children: children2, ...rest }) => {
  const divRef = (0, import_react2.useRef)(null);
  (0, import_react2.useLayoutEffect)(() => {
    const el = divRef.current;
    if (!el)
      return;
    el.appendChild(htmlContainer_default);
    settings_default.autoMount = el;
    return () => {
      settings_default.autoMount = false;
    };
  }, []);
  return import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement(Setup_default, { ...rest }), import_react2.default.createElement("div", { style: {
    width: "100%",
    height: "100%",
    position: position !== null && position !== void 0 ? position : "absolute",
    top: 0,
    left: 0,
    display: "flex",
    ...style3
  } }, import_react2.default.createElement("div", { style: { height: "100%" } }, children2), import_react2.default.createElement("div", { ref: divRef, style: { height: "100%", flexGrow: 1, position: "relative", overflow: "hidden" } })));
};
var World_default = World;

// node_modules/lingo3d-react/lib/components/editor/LingoEditor.js
var import_react3 = __toESM(require_react());

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t2;
var o;
var r;
var f;
var e = {};
var c = [];
var s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function a(n3, l5) {
  for (var u5 in l5)
    n3[u5] = l5[u5];
  return n3;
}
function h(n3) {
  var l5 = n3.parentNode;
  l5 && l5.removeChild(n3);
}
function v(l5, u5, i4) {
  var t5, o4, r5, f4 = {};
  for (r5 in u5)
    r5 == "key" ? t5 = u5[r5] : r5 == "ref" ? o4 = u5[r5] : f4[r5] = u5[r5];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), typeof l5 == "function" && l5.defaultProps != null)
    for (r5 in l5.defaultProps)
      f4[r5] === void 0 && (f4[r5] = l5.defaultProps[r5]);
  return y(l5, f4, t5, o4, null);
}
function y(n3, i4, t5, o4, r5) {
  var f4 = { type: n3, props: i4, key: t5, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r5 == null ? ++u : r5 };
  return r5 == null && l.vnode != null && l.vnode(f4), f4;
}
function d(n3) {
  return n3.children;
}
function _(n3, l5) {
  this.props = n3, this.context = l5;
}
function k(n3, l5) {
  if (l5 == null)
    return n3.__ ? k(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u5; l5 < n3.__k.length; l5++)
    if ((u5 = n3.__k[l5]) != null && u5.__e != null)
      return u5.__e;
  return typeof n3.type == "function" ? k(n3) : null;
}
function b(n3) {
  var l5, u5;
  if ((n3 = n3.__) != null && n3.__c != null) {
    for (n3.__e = n3.__c.base = null, l5 = 0; l5 < n3.__k.length; l5++)
      if ((u5 = n3.__k[l5]) != null && u5.__e != null) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return b(n3);
  }
}
function m(n3) {
  (!n3.__d && (n3.__d = true) && t2.push(n3) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
}
function g() {
  for (var n3; g.__r = t2.length; )
    n3 = t2.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }), t2 = [], n3.some(function(n4) {
      var l5, u5, i4, t5, o4, r5;
      n4.__d && (o4 = (t5 = (l5 = n4).__v).__e, (r5 = l5.__P) && (u5 = [], (i4 = a({}, t5)).__v = t5.__v + 1, j(r5, t5, i4, l5.__n, r5.ownerSVGElement !== void 0, t5.__h != null ? [o4] : null, u5, o4 == null ? k(t5) : o4, t5.__h), z(u5, t5), t5.__e != o4 && b(t5)));
    });
}
function w(n3, l5, u5, i4, t5, o4, r5, f4, s5, a5) {
  var h4, v4, p3, _4, b4, m4, g3, w4 = i4 && i4.__k || c, A = w4.length;
  for (u5.__k = [], h4 = 0; h4 < l5.length; h4++)
    if ((_4 = u5.__k[h4] = (_4 = l5[h4]) == null || typeof _4 == "boolean" ? null : typeof _4 == "string" || typeof _4 == "number" || typeof _4 == "bigint" ? y(null, _4, null, null, _4) : Array.isArray(_4) ? y(d, { children: _4 }, null, null, null) : _4.__b > 0 ? y(_4.type, _4.props, _4.key, null, _4.__v) : _4) != null) {
      if (_4.__ = u5, _4.__b = u5.__b + 1, (p3 = w4[h4]) === null || p3 && _4.key == p3.key && _4.type === p3.type)
        w4[h4] = void 0;
      else
        for (v4 = 0; v4 < A; v4++) {
          if ((p3 = w4[v4]) && _4.key == p3.key && _4.type === p3.type) {
            w4[v4] = void 0;
            break;
          }
          p3 = null;
        }
      j(n3, _4, p3 = p3 || e, t5, o4, r5, f4, s5, a5), b4 = _4.__e, (v4 = _4.ref) && p3.ref != v4 && (g3 || (g3 = []), p3.ref && g3.push(p3.ref, null, _4), g3.push(v4, _4.__c || b4, _4)), b4 != null ? (m4 == null && (m4 = b4), typeof _4.type == "function" && _4.__k === p3.__k ? _4.__d = s5 = x(_4, s5, n3) : s5 = P(n3, _4, p3, w4, b4, s5), typeof u5.type == "function" && (u5.__d = s5)) : s5 && p3.__e == s5 && s5.parentNode != n3 && (s5 = k(p3));
    }
  for (u5.__e = m4, h4 = A; h4--; )
    w4[h4] != null && (typeof u5.type == "function" && w4[h4].__e != null && w4[h4].__e == u5.__d && (u5.__d = k(i4, h4 + 1)), N(w4[h4], w4[h4]));
  if (g3)
    for (h4 = 0; h4 < g3.length; h4++)
      M(g3[h4], g3[++h4], g3[++h4]);
}
function x(n3, l5, u5) {
  for (var i4, t5 = n3.__k, o4 = 0; t5 && o4 < t5.length; o4++)
    (i4 = t5[o4]) && (i4.__ = n3, l5 = typeof i4.type == "function" ? x(i4, l5, u5) : P(u5, i4, i4, t5, i4.__e, l5));
  return l5;
}
function P(n3, l5, u5, i4, t5, o4) {
  var r5, f4, e5;
  if (l5.__d !== void 0)
    r5 = l5.__d, l5.__d = void 0;
  else if (u5 == null || t5 != o4 || t5.parentNode == null)
    n:
      if (o4 == null || o4.parentNode !== n3)
        n3.appendChild(t5), r5 = null;
      else {
        for (f4 = o4, e5 = 0; (f4 = f4.nextSibling) && e5 < i4.length; e5 += 2)
          if (f4 == t5)
            break n;
        n3.insertBefore(t5, o4), r5 = o4;
      }
  return r5 !== void 0 ? r5 : t5.nextSibling;
}
function C(n3, l5, u5, i4, t5) {
  var o4;
  for (o4 in u5)
    o4 === "children" || o4 === "key" || o4 in l5 || H(n3, o4, null, u5[o4], i4);
  for (o4 in l5)
    t5 && typeof l5[o4] != "function" || o4 === "children" || o4 === "key" || o4 === "value" || o4 === "checked" || u5[o4] === l5[o4] || H(n3, o4, l5[o4], u5[o4], i4);
}
function $(n3, l5, u5) {
  l5[0] === "-" ? n3.setProperty(l5, u5) : n3[l5] = u5 == null ? "" : typeof u5 != "number" || s.test(l5) ? u5 : u5 + "px";
}
function H(n3, l5, u5, i4, t5) {
  var o4;
  n:
    if (l5 === "style")
      if (typeof u5 == "string")
        n3.style.cssText = u5;
      else {
        if (typeof i4 == "string" && (n3.style.cssText = i4 = ""), i4)
          for (l5 in i4)
            u5 && l5 in u5 || $(n3.style, l5, "");
        if (u5)
          for (l5 in u5)
            i4 && u5[l5] === i4[l5] || $(n3.style, l5, u5[l5]);
      }
    else if (l5[0] === "o" && l5[1] === "n")
      o4 = l5 !== (l5 = l5.replace(/Capture$/, "")), l5 = l5.toLowerCase() in n3 ? l5.toLowerCase().slice(2) : l5.slice(2), n3.l || (n3.l = {}), n3.l[l5 + o4] = u5, u5 ? i4 || n3.addEventListener(l5, o4 ? T : I, o4) : n3.removeEventListener(l5, o4 ? T : I, o4);
    else if (l5 !== "dangerouslySetInnerHTML") {
      if (t5)
        l5 = l5.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l5 !== "href" && l5 !== "list" && l5 !== "form" && l5 !== "tabIndex" && l5 !== "download" && l5 in n3)
        try {
          n3[l5] = u5 == null ? "" : u5;
          break n;
        } catch (n4) {
        }
      typeof u5 == "function" || (u5 != null && (u5 !== false || l5[0] === "a" && l5[1] === "r") ? n3.setAttribute(l5, u5) : n3.removeAttribute(l5));
    }
}
function I(n3) {
  this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function T(n3) {
  this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function j(n3, u5, i4, t5, o4, r5, f4, e5, c5) {
  var s5, h4, v4, y4, p3, k3, b4, m4, g3, x2, A, P3, C2, $2 = u5.type;
  if (u5.constructor !== void 0)
    return null;
  i4.__h != null && (c5 = i4.__h, e5 = u5.__e = i4.__e, u5.__h = null, r5 = [e5]), (s5 = l.__b) && s5(u5);
  try {
    n:
      if (typeof $2 == "function") {
        if (m4 = u5.props, g3 = (s5 = $2.contextType) && t5[s5.__c], x2 = s5 ? g3 ? g3.props.value : s5.__ : t5, i4.__c ? b4 = (h4 = u5.__c = i4.__c).__ = h4.__E : ("prototype" in $2 && $2.prototype.render ? u5.__c = h4 = new $2(m4, x2) : (u5.__c = h4 = new _(m4, x2), h4.constructor = $2, h4.render = O), g3 && g3.sub(h4), h4.props = m4, h4.state || (h4.state = {}), h4.context = x2, h4.__n = t5, v4 = h4.__d = true, h4.__h = []), h4.__s == null && (h4.__s = h4.state), $2.getDerivedStateFromProps != null && (h4.__s == h4.state && (h4.__s = a({}, h4.__s)), a(h4.__s, $2.getDerivedStateFromProps(m4, h4.__s))), y4 = h4.props, p3 = h4.state, v4)
          $2.getDerivedStateFromProps == null && h4.componentWillMount != null && h4.componentWillMount(), h4.componentDidMount != null && h4.__h.push(h4.componentDidMount);
        else {
          if ($2.getDerivedStateFromProps == null && m4 !== y4 && h4.componentWillReceiveProps != null && h4.componentWillReceiveProps(m4, x2), !h4.__e && h4.shouldComponentUpdate != null && h4.shouldComponentUpdate(m4, h4.__s, x2) === false || u5.__v === i4.__v) {
            h4.props = m4, h4.state = h4.__s, u5.__v !== i4.__v && (h4.__d = false), h4.__v = u5, u5.__e = i4.__e, u5.__k = i4.__k, u5.__k.forEach(function(n4) {
              n4 && (n4.__ = u5);
            }), h4.__h.length && f4.push(h4);
            break n;
          }
          h4.componentWillUpdate != null && h4.componentWillUpdate(m4, h4.__s, x2), h4.componentDidUpdate != null && h4.__h.push(function() {
            h4.componentDidUpdate(y4, p3, k3);
          });
        }
        if (h4.context = x2, h4.props = m4, h4.__v = u5, h4.__P = n3, A = l.__r, P3 = 0, "prototype" in $2 && $2.prototype.render)
          h4.state = h4.__s, h4.__d = false, A && A(u5), s5 = h4.render(h4.props, h4.state, h4.context);
        else
          do {
            h4.__d = false, A && A(u5), s5 = h4.render(h4.props, h4.state, h4.context), h4.state = h4.__s;
          } while (h4.__d && ++P3 < 25);
        h4.state = h4.__s, h4.getChildContext != null && (t5 = a(a({}, t5), h4.getChildContext())), v4 || h4.getSnapshotBeforeUpdate == null || (k3 = h4.getSnapshotBeforeUpdate(y4, p3)), C2 = s5 != null && s5.type === d && s5.key == null ? s5.props.children : s5, w(n3, Array.isArray(C2) ? C2 : [C2], u5, i4, t5, o4, r5, f4, e5, c5), h4.base = u5.__e, u5.__h = null, h4.__h.length && f4.push(h4), b4 && (h4.__E = h4.__ = null), h4.__e = false;
      } else
        r5 == null && u5.__v === i4.__v ? (u5.__k = i4.__k, u5.__e = i4.__e) : u5.__e = L(i4.__e, u5, i4, t5, o4, r5, f4, c5);
    (s5 = l.diffed) && s5(u5);
  } catch (n4) {
    u5.__v = null, (c5 || r5 != null) && (u5.__e = e5, u5.__h = !!c5, r5[r5.indexOf(e5)] = null), l.__e(n4, u5, i4);
  }
}
function z(n3, u5) {
  l.__c && l.__c(u5, n3), n3.some(function(u6) {
    try {
      n3 = u6.__h, u6.__h = [], n3.some(function(n4) {
        n4.call(u6);
      });
    } catch (n4) {
      l.__e(n4, u6.__v);
    }
  });
}
function L(l5, u5, i4, t5, o4, r5, f4, c5) {
  var s5, a5, v4, y4 = i4.props, p3 = u5.props, d4 = u5.type, _4 = 0;
  if (d4 === "svg" && (o4 = true), r5 != null) {
    for (; _4 < r5.length; _4++)
      if ((s5 = r5[_4]) && "setAttribute" in s5 == !!d4 && (d4 ? s5.localName === d4 : s5.nodeType === 3)) {
        l5 = s5, r5[_4] = null;
        break;
      }
  }
  if (l5 == null) {
    if (d4 === null)
      return document.createTextNode(p3);
    l5 = o4 ? document.createElementNS("http://www.w3.org/2000/svg", d4) : document.createElement(d4, p3.is && p3), r5 = null, c5 = false;
  }
  if (d4 === null)
    y4 === p3 || c5 && l5.data === p3 || (l5.data = p3);
  else {
    if (r5 = r5 && n.call(l5.childNodes), a5 = (y4 = i4.props || e).dangerouslySetInnerHTML, v4 = p3.dangerouslySetInnerHTML, !c5) {
      if (r5 != null)
        for (y4 = {}, _4 = 0; _4 < l5.attributes.length; _4++)
          y4[l5.attributes[_4].name] = l5.attributes[_4].value;
      (v4 || a5) && (v4 && (a5 && v4.__html == a5.__html || v4.__html === l5.innerHTML) || (l5.innerHTML = v4 && v4.__html || ""));
    }
    if (C(l5, p3, y4, o4, c5), v4)
      u5.__k = [];
    else if (_4 = u5.props.children, w(l5, Array.isArray(_4) ? _4 : [_4], u5, i4, t5, o4 && d4 !== "foreignObject", r5, f4, r5 ? r5[0] : i4.__k && k(i4, 0), c5), r5 != null)
      for (_4 = r5.length; _4--; )
        r5[_4] != null && h(r5[_4]);
    c5 || ("value" in p3 && (_4 = p3.value) !== void 0 && (_4 !== l5.value || d4 === "progress" && !_4 || d4 === "option" && _4 !== y4.value) && H(l5, "value", _4, y4.value, false), "checked" in p3 && (_4 = p3.checked) !== void 0 && _4 !== l5.checked && H(l5, "checked", _4, y4.checked, false));
  }
  return l5;
}
function M(n3, u5, i4) {
  try {
    typeof n3 == "function" ? n3(u5) : n3.current = u5;
  } catch (n4) {
    l.__e(n4, i4);
  }
}
function N(n3, u5, i4) {
  var t5, o4;
  if (l.unmount && l.unmount(n3), (t5 = n3.ref) && (t5.current && t5.current !== n3.__e || M(t5, null, u5)), (t5 = n3.__c) != null) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u5);
      }
    t5.base = t5.__P = null;
  }
  if (t5 = n3.__k)
    for (o4 = 0; o4 < t5.length; o4++)
      t5[o4] && N(t5[o4], u5, typeof n3.type != "function");
  i4 || n3.__e == null || h(n3.__e), n3.__e = n3.__d = void 0;
}
function O(n3, l5, u5) {
  return this.constructor(n3, u5);
}
function S(u5, i4, t5) {
  var o4, r5, f4;
  l.__ && l.__(u5, i4), r5 = (o4 = typeof t5 == "function") ? null : t5 && t5.__k || i4.__k, f4 = [], j(i4, u5 = (!o4 && t5 || i4).__k = v(d, null, [u5]), r5 || e, e, i4.ownerSVGElement !== void 0, !o4 && t5 ? [t5] : r5 ? null : i4.firstChild ? n.call(i4.childNodes) : null, f4, !o4 && t5 ? t5 : r5 ? r5.__e : i4.firstChild, o4), z(f4, u5);
}
function q(n3, l5) {
  S(n3, l5, q);
}
function B(l5, u5, i4) {
  var t5, o4, r5, f4 = a({}, l5.props);
  for (r5 in u5)
    r5 == "key" ? t5 = u5[r5] : r5 == "ref" ? o4 = u5[r5] : f4[r5] = u5[r5];
  return arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), y(l5.type, f4, t5 || l5.key, o4 || l5.ref, null);
}
n = c.slice, l = { __e: function(n3, l5, u5, i4) {
  for (var t5, o4, r5; l5 = l5.__; )
    if ((t5 = l5.__c) && !t5.__)
      try {
        if ((o4 = t5.constructor) && o4.getDerivedStateFromError != null && (t5.setState(o4.getDerivedStateFromError(n3)), r5 = t5.__d), t5.componentDidCatch != null && (t5.componentDidCatch(n3, i4 || {}), r5 = t5.__d), r5)
          return t5.__E = t5;
      } catch (l6) {
        n3 = l6;
      }
  throw n3;
} }, u = 0, i = function(n3) {
  return n3 != null && n3.constructor === void 0;
}, _.prototype.setState = function(n3, l5) {
  var u5;
  u5 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n3 == "function" && (n3 = n3(a({}, u5), this.props)), n3 && a(u5, n3), n3 != null && this.__v && (l5 && this.__h.push(l5), m(this));
}, _.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), m(this));
}, _.prototype.render = d, t2 = [], o = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;

// node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var o2 = 0;
function e2(_4, e5, n3, t5, f4) {
  var l5, s5, u5 = {};
  for (s5 in e5)
    s5 == "ref" ? l5 = e5[s5] : u5[s5] = e5[s5];
  var a5 = { type: _4, props: u5, key: n3, ref: l5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: --o2, __source: f4, __self: t5 };
  if (typeof _4 == "function" && (l5 = _4.defaultProps))
    for (s5 in l5)
      u5[s5] === void 0 && (u5[s5] = l5[s5]);
  return l.vnode && l.vnode(a5), a5;
}

// node_modules/lingo3d/lib/editor/Editor/index.js
var import_tweakpane = __toESM(require_tweakpane());

// node_modules/preact/hooks/dist/hooks.module.js
var t3;
var u2;
var r2;
var o3;
var i2 = 0;
var c2 = [];
var f2 = [];
var e3 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function p(t5, r5) {
  l.__h && l.__h(u2, t5, i2 || r5), i2 = 0;
  var o4 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t5 >= o4.__.length && o4.__.push({ __V: f2 }), o4.__[t5];
}
function y2(n3) {
  return i2 = 1, d2(z2, n3);
}
function d2(n3, r5, o4) {
  var i4 = p(t3++, 2);
  return i4.t = n3, i4.__c || (i4.__ = [o4 ? o4(r5) : z2(void 0, r5), function(n4) {
    var t5 = i4.t(i4.__[0], n4);
    i4.__[0] !== t5 && (i4.__ = [t5, i4.__[1]], i4.__c.setState({}));
  }], i4.__c = u2), i4.__;
}
function _2(r5, o4) {
  var i4 = p(t3++, 3);
  !l.__s && w2(i4.__H, o4) && (i4.__ = r5, i4.u = o4, u2.__H.__h.push(i4));
}
function h2(r5, o4) {
  var i4 = p(t3++, 4);
  !l.__s && w2(i4.__H, o4) && (i4.__ = r5, i4.u = o4, u2.__h.push(i4));
}
function s2(n3) {
  return i2 = 5, F(function() {
    return { current: n3 };
  }, []);
}
function F(n3, u5) {
  var r5 = p(t3++, 7);
  return w2(r5.__H, u5) ? (r5.__V = n3(), r5.u = u5, r5.__h = n3, r5.__V) : r5.__;
}
function b2() {
  for (var t5; t5 = c2.shift(); )
    if (t5.__P)
      try {
        t5.__H.__h.forEach(j2), t5.__H.__h.forEach(k2), t5.__H.__h = [];
      } catch (u5) {
        t5.__H.__h = [], l.__e(u5, t5.__v);
      }
}
l.__b = function(n3) {
  u2 = null, e3 && e3(n3);
}, l.__r = function(n3) {
  a2 && a2(n3), t3 = 0;
  var o4 = (u2 = n3.__c).__H;
  o4 && (r2 === u2 ? (o4.__h = [], u2.__h = [], o4.__.forEach(function(n4) {
    n4.__V = f2, n4.u = void 0;
  })) : (o4.__h.forEach(j2), o4.__h.forEach(k2), o4.__h = [])), r2 = u2;
}, l.diffed = function(t5) {
  v2 && v2(t5);
  var i4 = t5.__c;
  i4 && i4.__H && (i4.__H.__h.length && (c2.push(i4) !== 1 && o3 === l.requestAnimationFrame || ((o3 = l.requestAnimationFrame) || function(n3) {
    var t6, u5 = function() {
      clearTimeout(r5), g2 && cancelAnimationFrame(t6), setTimeout(n3);
    }, r5 = setTimeout(u5, 100);
    g2 && (t6 = requestAnimationFrame(u5));
  })(b2)), i4.__H.__.forEach(function(n3) {
    n3.u && (n3.__H = n3.u), n3.__V !== f2 && (n3.__ = n3.__V), n3.u = void 0, n3.__V = f2;
  })), r2 = u2 = null;
}, l.__c = function(t5, u5) {
  u5.some(function(t6) {
    try {
      t6.__h.forEach(j2), t6.__h = t6.__h.filter(function(n3) {
        return !n3.__ || k2(n3);
      });
    } catch (r5) {
      u5.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), u5 = [], l.__e(r5, t6.__v);
    }
  }), l2 && l2(t5, u5);
}, l.unmount = function(t5) {
  m2 && m2(t5);
  var u5, r5 = t5.__c;
  r5 && r5.__H && (r5.__H.__.forEach(function(n3) {
    try {
      j2(n3);
    } catch (n4) {
      u5 = n4;
    }
  }), u5 && l.__e(u5, r5.__v));
};
var g2 = typeof requestAnimationFrame == "function";
function j2(n3) {
  var t5 = u2, r5 = n3.__c;
  typeof r5 == "function" && (n3.__c = void 0, r5()), u2 = t5;
}
function k2(n3) {
  var t5 = u2;
  n3.__c = n3.__(), u2 = t5;
}
function w2(n3, t5) {
  return !n3 || n3.length !== t5.length || t5.some(function(t6, u5) {
    return t6 !== n3[u5];
  });
}
function z2(n3, t5) {
  return typeof t5 == "function" ? t5(n3) : t5;
}

// node_modules/preact-custom-element/dist/preact-custom-element.esm.js
function r3() {
  return (r3 = Object.assign || function(t5) {
    for (var e5 = 1; e5 < arguments.length; e5++) {
      var n3 = arguments[e5];
      for (var o4 in n3)
        Object.prototype.hasOwnProperty.call(n3, o4) && (t5[o4] = n3[o4]);
    }
    return t5;
  }).apply(this, arguments);
}
function i3(t5) {
  this.getChildContext = function() {
    return t5.context;
  };
  var e5 = t5.children, n3 = function(t6, e6) {
    if (t6 == null)
      return {};
    var n4, o4, r5 = {}, i4 = Object.keys(t6);
    for (o4 = 0; o4 < i4.length; o4++)
      e6.indexOf(n4 = i4[o4]) >= 0 || (r5[n4] = t6[n4]);
    return r5;
  }(t5, ["context", "children"]);
  return B(e5, n3);
}
function a3() {
  var o4 = new CustomEvent("_preact", { detail: {}, bubbles: true, cancelable: true });
  this.dispatchEvent(o4), this._vdom = v(i3, r3({}, this._props, { context: o4.detail.context }), function e5(n3, o5) {
    if (n3.nodeType === 3)
      return n3.data;
    if (n3.nodeType !== 1)
      return null;
    var r5 = [], i4 = {}, a5 = 0, c5 = n3.attributes, l5 = n3.childNodes;
    for (a5 = c5.length; a5--; )
      c5[a5].name !== "slot" && (i4[c5[a5].name] = c5[a5].value, i4[s3(c5[a5].name)] = c5[a5].value);
    for (a5 = l5.length; a5--; ) {
      var p3 = e5(l5[a5], null), d4 = l5[a5].slot;
      d4 ? i4[d4] = v(u3, { name: d4 }, p3) : r5[a5] = p3;
    }
    var h4 = o5 ? v(u3, null, r5) : r5;
    return v(o5 || n3.nodeName.toLowerCase(), i4, h4);
  }(this, this._vdomComponent)), (this.hasAttribute("hydrate") ? q : S)(this._vdom, this._root);
}
function s3(t5) {
  return t5.replace(/-(\w)/g, function(t6, e5) {
    return e5 ? e5.toUpperCase() : "";
  });
}
function c3(t5, e5, r5) {
  if (this._vdom) {
    var i4 = {};
    i4[t5] = r5 = r5 == null ? void 0 : r5, i4[s3(t5)] = r5, this._vdom = B(this._vdom, i4), S(this._vdom, this._root);
  }
}
function l3() {
  S(this._vdom = null, this._root);
}
function u3(e5, n3) {
  var o4 = this;
  return v("slot", r3({}, e5, { ref: function(t5) {
    t5 ? (o4.ref = t5, o4._listener || (o4._listener = function(t6) {
      t6.stopPropagation(), t6.detail.context = n3;
    }, t5.addEventListener("_preact", o4._listener))) : o4.ref.removeEventListener("_preact", o4._listener);
  } }));
}
function preact_custom_element_esm_default(t5, e5, n3, o4) {
  function r5() {
    var e6 = Reflect.construct(HTMLElement, [], r5);
    return e6._vdomComponent = t5, e6._root = o4 && o4.shadow ? e6.attachShadow({ mode: "open" }) : e6, e6;
  }
  return (r5.prototype = Object.create(HTMLElement.prototype)).constructor = r5, r5.prototype.connectedCallback = a3, r5.prototype.attributeChangedCallback = c3, r5.prototype.disconnectedCallback = l3, n3 = n3 || t5.observedAttributes || Object.keys(t5.propTypes || {}), r5.observedAttributes = n3, n3.forEach(function(t6) {
    Object.defineProperty(r5.prototype, t6, { get: function() {
      return this._vdom.props[t6];
    }, set: function(e6) {
      this._vdom ? this.attributeChangedCallback(t6, null, e6) : (this._props || (this._props = {}), this._props[t6] = e6, this.connectedCallback());
      var n4 = typeof e6;
      e6 != null && n4 !== "string" && n4 !== "boolean" && n4 !== "number" || this.setAttribute(t6, e6);
    } });
  }), customElements.define(e5 || t5.tagName || t5.displayName || t5.name, r5);
}

// node_modules/lingo3d/lib/editor/hook.js
var hook_default = (setGlobalState, getGlobalState) => {
  const useGlobalState = () => {
    const [state, setState] = y2(() => getGlobalState());
    _2(() => {
      const handle = getGlobalState(setState);
      return () => {
        handle.cancel();
      };
    }, []);
    return [state, setGlobalState];
  };
  return useGlobalState;
};

// node_modules/lingo3d/lib/states/useSceneGraphTarget.js
var [setSceneGraphTarget, getSceneGraphTarget] = store(void 0);
getSelectionTarget(() => setSceneGraphTarget(void 0));

// node_modules/lingo3d/lib/states/useSceneGraphExpanded.js
var [setSceneGraphExpanded, getSceneGraphExpanded] = store(void 0);

// node_modules/lingo3d/lib/states/useSceneGraphPreventDrag.js
var [setSceneGraphPreventDrag, getSceneGraphPreventDrag] = store(false);

// node_modules/lingo3d/lib/editor/states.js
var useSelectionTarget = hook_default(setSelectionTarget, getSelectionTarget);
var useMultipleSelectionTargets = hook_default(setMultipleSelectionTargets, getMultipleSelectionTargets);
var useSelectionFrozen = hook_default(setSelectionFrozen, getSelectionFrozen);
var useCameraList = hook_default(setCameraList, getCameraList);
var useCameraStack = hook_default(setCameraStack, getCameraStack);
var useTransformControlsMode = hook_default(setTransformControlsMode, getTransformControlsMode);
var useTransformControlsSpace = hook_default(setTransformControlsSpace, getTransformControlsSpace);
var useDefaultLight = hook_default(setDefaultLight, getDefaultLight);
var useDefaultFog = hook_default(setDefaultFog, getDefaultFog);
var useSceneGraphTarget = hook_default(setSceneGraphTarget, getSceneGraphTarget);
var useSceneGraphExpanded = hook_default(setSceneGraphExpanded, getSceneGraphExpanded);
var useSceneGraphPreventDrag = hook_default(setSceneGraphPreventDrag, getSceneGraphPreventDrag);
var useEditorActive = hook_default(setEditorActive, getEditorActive);

// node_modules/lingo3d/lib/editor/Editor/deleteSelected.js
var deleteSelected_default = () => {
  if (getTransformControlsDragging())
    return;
  const selectionTarget = getSelectionTarget();
  const multipleSelectionTargets = getMultipleSelectionTargets();
  selectionTarget == null ? void 0 : selectionTarget.dispose();
  for (const target of multipleSelectionTargets)
    target.dispose();
};

// node_modules/lingo3d/lib/editor/getComponentName.js
var getComponentName_default = (appendable) => appendable.name || (0, import_lodash.upperFirst)(appendable.constructor.componentName);

// node_modules/lingo3d/lib/utils/createElement.js
var createElement_default = (html) => {
  const el = document.createElement("div");
  el.innerHTML = html;
  return el.children[0];
};

// node_modules/lingo3d/lib/editor/Editor/resetIcon.js
var resetIcon_default = createElement_default(`
    <div>
        <svg t="1656447640895" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1297" width="10" height="10"><path d="M788.804292 977.500541a503.543363 503.543363 0 0 0 162.507176-119.862595 509.687074 509.687074 0 0 0 103.780528-174.312738 515.047762 515.047762 0 0 0 28.550186-194.068985 514.385205 514.385205 0 0 0-45.53574-190.816432 508.663122 508.663122 0 0 0-118.657945-164.193685A501.676156 501.676156 0 0 0 554.921651 0.530046 503.904757 503.904757 0 0 0 203.585714 166.530704a509.807538 509.807538 0 0 0-94.564962 150.159522L0 290.187944l45.174345 154.014399 45.234577 154.0144 109.382147-116.610042L309.173215 365.056891l-103.057738-24.936238a411.387699 411.387699 0 0 1 69.990118-106.611453 405.846313 405.846313 0 0 1 576.906499-25.960191c166.181356 153.592772 177.625524 415.001647 25.659027 582.869512a406.087243 406.087243 0 0 1-577.026963 25.899958l-66.315938 73.302904a502.097784 502.097784 0 0 0 364.707543 133.836525 499.387323 499.387323 0 0 0 188.768529-45.957367z" p-id="1298" fill="#ffffff"></path></svg>
    </div>
`);

// node_modules/lingo3d/lib/editor/Editor/addInputs.js
var programmatic = false;
var leading = true;
var setProgrammatic = debounce(() => {
  programmatic = leading;
  leading = !leading;
}, 100, "both");
var toFixed = (v4) => typeof v4 === "number" ? Number(v4.toFixed(2)) : v4;
var isPoint = (v4) => v4 && typeof v4 === "object" && "x" in v4 && "y" in v4;
var isTrue = (v4) => v4 === true || v4 === "true";
var isFalse = (v4) => v4 === false || v4 === "false";
var isEqual = (a5, b4) => {
  if (isPoint(a5) && isPoint(b4))
    return a5.x === b4.x && a5.y === b4.y && a5.z === b4.z;
  if (isTrue(a5) && isTrue(b4))
    return true;
  if (isFalse(a5) && isFalse(b4))
    return true;
  return a5 === b4;
};
var addInputs_default = (pane, title, target, defaults, params = { ...target }) => {
  const folder = pane.addFolder({ title });
  for (const [key, value] of Object.entries(params))
    switch (typeof value) {
      case "undefined":
        params[key] = "";
        break;
      case "number":
        params[key] = toFixed(value);
        break;
      case "object":
        if (Array.isArray(value)) {
          params[key] = JSON.stringify(value);
          break;
        }
        typeof (value == null ? void 0 : value.x) === "number" && (value.x = toFixed(value.x));
        typeof (value == null ? void 0 : value.y) === "number" && (value.y = toFixed(value.y));
        typeof (value == null ? void 0 : value.z) === "number" && (value.z = toFixed(value.z));
        break;
    }
  return Object.fromEntries(Object.keys(params).map((key) => {
    var _a2;
    const input = folder.addInput(params, key);
    const resetButton = resetIcon_default.cloneNode(true);
    input.element.prepend(resetButton);
    let defaultValue = defaults[key];
    defaultValue = (_a2 = Array.isArray(defaultValue) ? defaultValue[1] : defaultValue) != null ? _a2 : "";
    const unchanged = isEqual(params[key], defaultValue);
    resetButton.style.opacity = unchanged ? "0.1" : "0.5";
    resetButton.style.cursor = unchanged ? "auto" : "pointer";
    resetButton.onclick = () => {
      params[key] = defaultValue;
      input.refresh();
    };
    input.on("change", ({ value }) => {
      if (programmatic)
        return;
      const unchanged2 = isEqual(value, defaultValue);
      resetButton.style.opacity = unchanged2 ? "0.1" : "0.5";
      resetButton.style.cursor = unchanged2 ? "auto" : "pointer";
      if (typeof value === "string") {
        if (value === "true" || value === "false") {
          target[key] = value === "true" ? true : false;
          return;
        }
        const num = parseFloat(value);
        if (!Number.isNaN(num)) {
          target[key] = num;
          return;
        }
      }
      target[key] = toFixed(value);
    });
    return [key, input];
  }));
};

// node_modules/lingo3d/lib/editor/Editor/getParams.js
var getParams_default = (schema, defaults, target) => {
  const params = {};
  for (const [key, value] of Object.entries(schema)) {
    if (nonEditorSchemaSet_default.has(key))
      continue;
    let currentVal = target[key];
    if (value === Function || typeof currentVal === "function")
      continue;
    if (value === Object || typeof currentVal === "object" && !Array.isArray(currentVal)) {
      if (!currentVal || typeof currentVal.x !== "number" || typeof currentVal.y !== "number")
        continue;
    }
    if (currentVal === void 0) {
      currentVal = defaults[key];
      Array.isArray(currentVal) && (currentVal = currentVal[1]);
    }
    if (currentVal === Infinity)
      currentVal = 999999999;
    else if (currentVal === -Infinity)
      currentVal = -999999999;
    else if (Array.isArray(currentVal))
      currentVal = JSON.stringify(currentVal);
    params[key] = currentVal;
  }
  return params;
};

// node_modules/lingo3d/lib/editor/Editor/splitObject.js
var splitObject_default = (target, keys) => {
  let result0;
  for (const key of keys)
    key in target && ((result0 != null ? result0 : result0 = {})[key] = target[key]);
  const keySet = new Set(keys);
  const result1 = {};
  for (const [key, value] of Object.entries(target))
    !keySet.has(key) && (result1[key] = value);
  return [result0, result1];
};

// node_modules/lingo3d/lib/editor/Editor/assignIn.js
var assignIn_default = (to, from, keys) => {
  for (const key of keys)
    key in to && (to[key] = from[key]);
};

// node_modules/lingo3d/lib/events/onSceneGraphNameChange.js
var [emitSceneGraphNameChange, onSceneGraphNameChange] = event_default();

// node_modules/lingo3d/lib/editor/Editor/index.js
preventTreeShake(v);
Object.assign(setupDefaults, {
  defaultLightEnabled: true,
  defaultFogEnabled: false
});
Object.assign(dummyDefaults, {
  stride: { x: 0, y: 0 }
});
var style = createElement_default(`
    <style>
        .tp-rotv {
            box-shadow: none !important;
            background-color: transparent !important;
        }
        .tp-brkv {
            border-left: none !important;
        }
    </style>
`);
document.head.appendChild(style);
var Editor = ({ mouse, keyboard: keyboard2 }) => {
  const elRef = s2(null);
  _2(() => {
    setSelectionBlockMouse(mouse !== "enabled");
    setSelectionBlockKeyboard(keyboard2 !== "enabled");
    return () => {
      setSelectionBlockKeyboard(true);
      setSelectionBlockMouse(true);
    };
  }, [mouse, keyboard2]);
  const [renderDeps, render] = y2({});
  const [cameraStack] = useCameraStack();
  const camera = last(cameraStack);
  _2(() => {
    const currentCamera = camera;
    const init2 = () => {
      mainOrbitCamera_default.activate();
      setOrbitControls(true);
      setSelection(true);
      setGridHelper(true);
      render({});
    };
    init2();
    const handle0 = onApplySetup(init2);
    const handleKeyDown = (e5) => {
      if (e5.key !== "Shift" && e5.key !== "Meta" && e5.key !== "Control")
        return;
      setMultipleSelection(true);
    };
    const handleKeyUp = (e5) => {
      if (e5.key !== "Shift" && e5.key !== "Meta" && e5.key !== "Control")
        return;
      setMultipleSelection(false);
    };
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    const handle1 = onKeyClear(() => setMultipleSelection(false));
    emitEditorMountChange();
    return () => {
      currentCamera.userData.manager.activate();
      setOrbitControls(false);
      setSelection(false);
      setGridHelper(false);
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
      handle0.cancel();
      handle1.cancel();
      emitEditorMountChange();
    };
  }, []);
  const [selectionTarget] = useSelectionTarget();
  const [multipleSelectionTargets] = useMultipleSelectionTargets();
  const [cameraList] = useCameraList();
  const [pane, setPane] = y2();
  const [cameraFolder, setCameraFolder] = y2();
  h2(() => {
    var _a2;
    if (!pane || !cameraFolder)
      return;
    const mainCameraName = "main camera";
    const options = cameraList.reduce((acc, cam, i4) => {
      acc[i4 === 0 ? mainCameraName : getComponentName_default(cam.userData.manager)] = i4;
      return acc;
    }, {});
    const cameraInput = pane.addInput({ camera: cameraList.indexOf(camera) }, "camera", { options });
    cameraFolder.add(cameraInput);
    cameraInput.on("change", ({ value }) => {
      cameraList[value].userData.manager.activate();
    });
    const secondaryOptions = {
      none: 0,
      ...(0, import_lodash.omit)(options, mainCameraName)
    };
    const secondaryCameraInput = pane.addInput({
      "secondary camera": cameraList.indexOf((_a2 = getSecondaryCamera()) != null ? _a2 : mainCamera_default)
    }, "secondary camera", { options: secondaryOptions });
    cameraFolder.add(secondaryCameraInput);
    secondaryCameraInput.on("change", ({ value }) => setSecondaryCamera(value === 0 ? void 0 : cameraList[value]));
    return () => {
      cameraInput.dispose();
      secondaryCameraInput.dispose();
    };
  }, [pane, cameraFolder, cameraList, camera]);
  const [defaultLight, setDefaultLight2] = useDefaultLight();
  const defaultLightEnabled = !!defaultLight;
  const [defaultFog, setDefaultFog2] = useDefaultFog();
  const defaultFogEnabled = !!defaultFog;
  _2(() => {
    const el = elRef.current;
    if (!el)
      return;
    const pane2 = new import_tweakpane.Pane({ container: el });
    setPane(pane2);
    setCameraFolder(pane2.addFolder({ title: "camera" }));
    if (!selectionTarget) {
      const omitted = [
        "defaultFog",
        "defaultLight",
        "defaultLightScale"
      ];
      const rest = Object.assign({
        defaultLightEnabled,
        ...defaultLightEnabled && {
          defaultLight,
          defaultLightScale: settings_default.defaultLightScale
        },
        defaultFogEnabled,
        ...defaultFogEnabled && { defaultFog }
      }, (0, import_lodash.omit)(settings_default, [...nonEditorSettings, ...omitted]));
      const [editorParams, editorRest] = splitObject_default(rest, [
        "gridHelper",
        "gridHelperSize"
      ]);
      addInputs_default(pane2, "editor", settings_default, setupDefaults, editorParams);
      const [rendererParams, rendererRest] = splitObject_default(editorRest, [
        "antiAlias",
        "pixelRatio",
        "logarithmicDepth",
        "pbr"
      ]);
      addInputs_default(pane2, "renderer", settings_default, setupDefaults, rendererParams);
      const [sceneParams, sceneRest] = splitObject_default(rendererRest, [
        "exposure",
        "defaultLightEnabled",
        "defaultLight",
        "defaultLightScale",
        "defaultFogEnabled",
        "defaultFog",
        "skybox"
      ]);
      const { defaultLightEnabled: defaultLightEnabledInput, defaultFogEnabled: defaultFogEnabledInput } = addInputs_default(pane2, "lighting & environment", settings_default, setupDefaults, sceneParams);
      defaultLightEnabledInput.on("change", ({ value }) => setDefaultLight2(value ? "default" : false));
      defaultFogEnabledInput.on("change", ({ value }) => setDefaultFog2(value ? "white" : void 0));
      const [effectsParams, effectsRest] = splitObject_default(sceneRest, [
        "ambientOcclusion",
        "bloom",
        "bloomStrength",
        "bloomRadius",
        "bloomThreshold",
        "lensDistortion",
        "lensIor",
        "lensBand"
      ]);
      addInputs_default(pane2, "effects", settings_default, setupDefaults, effectsParams);
      const [outlineParams, outlineRest] = splitObject_default(effectsRest, [
        "outlineColor",
        "outlineHiddenColor",
        "outlinePattern",
        "outlinePulse",
        "outlineStrength",
        "outlineThickness"
      ]);
      addInputs_default(pane2, "outline effect", settings_default, setupDefaults, outlineParams);
      const [physicsParams, physicsRest] = splitObject_default(outlineRest, [
        "gravity",
        "repulsion"
      ]);
      addInputs_default(pane2, "physics", settings_default, setupDefaults, physicsParams);
      Object.keys(physicsRest).length && addInputs_default(pane2, "settings", settings_default, setupDefaults, physicsRest);
      return () => {
        pane2.dispose();
      };
    }
    const handleKey = (e5) => {
      if (e5.key === "Backspace" || e5.key === "Delete") {
        e5.preventDefault();
        !getMultipleSelection() && deleteSelected_default();
        return;
      }
      if (e5.key.toLowerCase() !== "c")
        return;
      const target2 = getSelectionTarget();
      if (!target2)
        return;
      if (e5.metaKey || e5.ctrlKey) {
        const [item] = deserialize_default(serialize_default(target2));
        if (!target2.parent || !item)
          return;
        target2.parent.attach(item);
        emitSelectionTarget(item);
        return;
      }
      isPositionedItem(target2) && emitEditorCenterView(target2);
    };
    document.addEventListener("keydown", handleKey);
    const target = selectionTarget;
    const handle = new Cancellable();
    if (!multipleSelectionTargets.length) {
      const { schema, defaults, componentName } = target.constructor;
      const [generalParams, generalRest] = splitObject_default((0, import_lodash.omit)(getParams_default(schema, defaults, target), [
        "rotation",
        "innerRotation",
        "frustumCulled",
        "physics",
        "minAzimuthAngle",
        "maxAzimuthAngle"
      ]), ["name", "id"]);
      if (generalParams) {
        const { name: nameInput } = addInputs_default(pane2, "general", target, defaults, generalParams);
        nameInput.on("change", () => emitSceneGraphNameChange());
      }
      const [transformParams0, transformRest] = splitObject_default(generalRest, [
        "x",
        "y",
        "z",
        "rotationX",
        "rotationY",
        "rotationZ",
        "scale",
        "scaleX",
        "scaleY",
        "scaleZ",
        "innerX",
        "innerY",
        "innerZ",
        "innerRotationX",
        "innerRotationY",
        "innerRotationZ",
        "width",
        "height",
        "depth"
      ]);
      if (transformParams0) {
        const [innerTransformParams, transformParams] = splitObject_default(transformParams0, [
          "innerX",
          "innerY",
          "innerZ",
          "innerRotationX",
          "innerRotationY",
          "innerRotationZ",
          "width",
          "height",
          "depth"
        ]);
        addInputs_default(pane2, "transform", target, defaults, transformParams);
        innerTransformParams && addInputs_default(pane2, "inner transform", target, defaults, innerTransformParams);
        handle.watch(onTransformControls(() => {
          setProgrammatic();
          assignIn_default(transformParams, target, [
            "x",
            "y",
            "z",
            "rotationX",
            "rotationY",
            "rotationZ",
            "scaleX",
            "scaleY",
            "scaleZ"
          ]);
          pane2.refresh();
        }));
      }
      const [displayParams, displayRest] = splitObject_default(transformRest, [
        "visible",
        "innerVisible"
      ]);
      displayParams && addInputs_default(pane2, "display", target, defaults, displayParams);
      const [effectsParams, effectsRest] = splitObject_default(displayRest, [
        "bloom",
        "reflection",
        "outline"
      ]);
      effectsParams && addInputs_default(pane2, "effects", target, defaults, effectsParams);
      const [animationParams, animationRest] = splitObject_default(effectsRest, [
        "animation",
        "animationPaused",
        "animationRepeat"
      ]);
      animationParams && addInputs_default(pane2, "animation", target, defaults, animationParams);
      const [adjustMaterialParams, adjustMaterialRest] = splitObject_default(animationRest, [
        "toon",
        "pbr",
        "metalnessFactor",
        "roughnessFactor",
        "opacityFactor",
        "emissiveIntensityFactor",
        "emissiveColorFactor",
        "colorFactor"
      ]);
      adjustMaterialParams && addInputs_default(pane2, "adjust material", target, defaults, adjustMaterialParams);
      const [materialParams, materialRest] = splitObject_default(adjustMaterialRest, [
        "fog",
        "opacity",
        "color",
        "texture",
        "textureRepeat",
        "videoTexture",
        "wireframe"
      ]);
      materialParams && addInputs_default(pane2, "material", target, defaults, materialParams);
      const [pbrMaterialParams, pbrMaterialRest] = splitObject_default(materialRest, [
        "metalnessMap",
        "metalness",
        "roughnessMap",
        "roughness",
        "normalMap",
        "normalScale",
        "normalMapType",
        "bumpMap",
        "bumpScale",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "aoMap",
        "aoMapIntensity",
        "lightMap",
        "lightMapIntensity",
        "emissiveMap",
        "emissiveIntensity",
        "emissiveColor",
        "envMap",
        "alphaMap"
      ]);
      pbrMaterialParams && addInputs_default(pane2, "pbr material", target, defaults, pbrMaterialParams);
      if (componentName === "dummy") {
        pbrMaterialRest.stride = { x: 0, y: 0 };
        const { stride: strideInput } = addInputs_default(pane2, componentName, target, defaults, pbrMaterialRest);
        strideInput.on("change", ({ value }) => {
          Object.assign(pbrMaterialRest, {
            strideForward: -value.y,
            strideRight: value.x
          });
          pane2.refresh();
        });
      } else if (Object.keys(pbrMaterialRest).length)
        addInputs_default(pane2, componentName, target, defaults, pbrMaterialRest);
    }
    return () => {
      handle.cancel();
      pane2.dispose();
      document.removeEventListener("keydown", handleKey);
    };
  }, [
    selectionTarget,
    multipleSelectionTargets,
    renderDeps,
    defaultFogEnabled,
    defaultLightEnabled
  ]);
  return e2("div", { ref: elRef, onKeyDown: (e5) => e5.stopPropagation(), onKeyUp: (e5) => e5.stopPropagation(), className: "lingo3d-ui", style: {
    width: 300,
    height: "100%",
    background: "rgb(40, 41, 46)"
  } });
};
preact_custom_element_esm_default(Editor, "lingo3d-editor", ["mouse", "keyboard"]);

// node_modules/lingo3d/lib/editor/SceneGraph/icons/CubeIcon.js
preventTreeShake(v);
var CubeIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 1024 1024", style: { margin: 2, opacity: 0.25, flexShrink: 0 }, children: e2("path", { fill: "#fff", d: "M838.4 325.12L554.24 479.36C528 493.44 512 521.6 512 552.96V851.2c0 32 31.36 53.12 57.6 38.4l284.16-154.24c25.6-14.08 42.24-42.24 42.24-73.6v-297.6c0-32.64-31.36-53.12-57.6-39.04zm-432.64 153.6L121.6 325.12c-26.24-14.08-57.6 6.4-57.6 38.4v299.52c0 31.36 16 59.52 42.24 73.6l284.16 153.6c26.24 14.08 57.6-7.04 57.6-39.04V552.32c0-31.36-16-59.52-42.24-73.6zm406.4-223.36c13.44-7.04 19.84-19.2 18.56-30.72 1.28-12.16-5.12-23.68-18.56-30.72L522.88 42.88c-12.8-7.04-28.16-10.24-43.52-10.24-15.36 0-30.72 3.2-43.52 10.24l-289.28 150.4c-13.44 7.04-19.2 19.2-18.56 30.72-.64 12.16 5.12 24.32 18.56 31.36l289.28 150.4C448.64 412.8 464 416 479.36 416c15.36 0 30.72-3.2 43.52-10.24l289.28-150.4z" }) });
};
var CubeIcon_default = CubeIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/ExpandIcon.js
preventTreeShake(v);
var ExpandIcon = ({ style: style3, onClick }) => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 1024 1024", style: { margin: 2, flexShrink: 0, ...style3 }, onMouseDown: (e5) => e5.stopPropagation(), onClick: (e5) => (e5.stopPropagation(), onClick == null ? void 0 : onClick()), children: e2("path", { fill: "#fff", d: "M928.1 928.2H98v-830h830.1v830zm-104.8-415c0-24.6-19.9-44.5-44.5-44.5H556.5V246.4c0-24.6-19.9-44.5-44.5-44.5s-44.5 19.9-44.5 44.5v222.3H245.2c-24.6 0-44.5 19.9-44.5 44.5s19.9 44.5 44.5 44.5h222.3V780c0 24.6 19.9 44.5 44.5 44.5s44.5-19.9 44.5-44.5V557.7h222.3c24.6 0 44.5-20 44.5-44.5z" }) });
};
var ExpandIcon_default = ExpandIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/CollapseIcon.js
preventTreeShake(v);
var CollapseIcon = ({ style: style3, onClick }) => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 1024 1024", style: { margin: 2, flexShrink: 0, ...style3 }, onMouseDown: (e5) => e5.stopPropagation(), onClick: (e5) => (e5.stopPropagation(), onClick == null ? void 0 : onClick()), children: e2("path", { fill: "#fff", d: "M752 240H144c-17.7 0-32 14.3-32 32v608c0 17.7 14.3 32 32 32h608c17.7 0 32-14.3 32-32V272c0-17.7-14.3-32-32-32zM596 606c0 4.4-3.6 8-8 8H308c-4.4 0-8-3.6-8-8v-48c0-4.4 3.6-8 8-8h280c4.4 0 8 3.6 8 8v48zm284-494H264c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h576v576c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V144c0-17.7-14.3-32-32-32z" }) });
};
var CollapseIcon_default = CollapseIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/ComponentIconPath.js
preventTreeShake(v);
var ComponentIconPath_default = () => {
  return e2("path", { fill: "#fff", d: "M914.5 653.5c-5.5 0-11 1.1-16 3.3l-.2.1h-.2L510.2 822.2 122.2 657h-.2l-.2-.1c-5-2.1-10.3-3.3-16-3.3-23.1 0-41.8 19.3-41.8 43.1 0 18 10.7 33.3 25.8 39.8l403.9 172.1.4.1c10.2 4.4 21.8 4.4 32 0l.2-.1c.1 0 .1-.1.2-.1l403.9-172.1c15.1-6.5 25.8-21.8 25.8-39.8.1-23.8-18.6-43.1-41.7-43.1zm0-186.5c-7.9-.2-16 3.2-16 3.2L510.2 635.6 121.8 470.2s-10.3-3.2-16-3.2C82.7 467 64 486.2 64 510c0 17.9 10.7 33.3 25.8 39.7l403.9 172c.1 0 .1.1.2.1l.1.1c5 2.1 10.3 3.3 16 3.3 5.7 0 11.1-1.2 16-3.3l.2-.1c.1 0 .1 0 .2-.1l403.9-172c15.1-6.4 25.8-21.8 25.9-39.7.1-23.8-18.6-43-41.7-43zM89.8 363.2l403.9 172.1c.1 0 .1 0 .2.1l.1.1c5 2.1 10.3 3.2 16 3.2 5.5 0 10.9-1.1 16-3.2l.2-.1.2-.1 403.9-172c15.1-6.5 25.8-21.8 25.9-39.7 0-18-10.7-33.3-25.8-39.8L526.5 111.6c-.1 0-.1 0-.2-.1l-.2-.1c-10.2-4.4-21.8-4.4-32 0l-.1.1L89.8 283.7C74.7 290.1 64 305.5 64 323.5c0 17.9 10.7 33.2 25.8 39.7z" });
};

// node_modules/lingo3d/lib/editor/SceneGraph/icons/ComponentIcon.js
preventTreeShake(v);
var ComponentIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 1024 1024", style: { margin: 2, opacity: 0.25, flexShrink: 0 }, children: e2(ComponentIconPath_default, {}) });
};
var ComponentIcon_default = ComponentIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/Object3DTreeItem.js
preventTreeShake(v);
document.addEventListener("mouseup", () => setSceneGraphPreventDrag(false));
var Object3DTreeItem = ({ appendable, object3d, level }) => {
  const expandIconStyle = { opacity: object3d.children.length ? 0.5 : 0.05, cursor: "pointer" };
  const [expanded, setExpanded] = y2(false);
  const [sceneGraphTarget] = useSceneGraphTarget();
  const { setClickEl, handleClick, handleDoubleClick } = makeTreeItemCallbacks(object3d, appendable);
  const [sceneGraphExpanded, setSceneGraphExpanded2] = useSceneGraphExpanded();
  _2(() => {
    if (!sceneGraphExpanded)
      return;
    if (sceneGraphExpanded.has(object3d))
      setExpanded(true);
  }, [sceneGraphExpanded]);
  const startRef = s2(null);
  const endRef = s2(null);
  const selected = sceneGraphTarget === object3d;
  const highlightWidth = F(() => {
    if (!selected || !startRef.current || !endRef.current)
      return;
    const boundsStart = startRef.current.getBoundingClientRect();
    const boundsEnd = endRef.current.getBoundingClientRect();
    return boundsEnd.right - boundsStart.left + 4;
  }, [selected, expanded]);
  return e2("div", { ref: setClickEl, onClick: handleClick, onDblClick: handleDoubleClick, onMouseDown: () => setSceneGraphPreventDrag(true), style: {
    color: "rgba(255, 255, 255, 0.75)",
    marginLeft: 8,
    borderLeft: "1px solid rgba(255, 255, 255, 0.05)"
  }, children: [e2("div", { ref: startRef, style: {
    display: "flex",
    alignItems: "center",
    border: selected ? "1px solid rgba(255, 255, 255, 0.5)" : void 0,
    width: highlightWidth,
    minWidth: "100%",
    cursor: "default"
  }, children: [expanded ? e2(CollapseIcon_default, { style: expandIconStyle, onClick: () => (setExpanded(false), setSceneGraphExpanded2(void 0)) }) : e2(ExpandIcon_default, { style: expandIconStyle, onClick: () => setExpanded(true) }), e2(ComponentIcon_default, {}), e2("div", { ref: endRef, children: object3d.name })] }), expanded && object3d.children.map((child) => e2(Object3DTreeItem, { object3d: child, appendable, level: level + 1 }, child.uuid))] });
};
var Object3DTreeItem_default = Object3DTreeItem;

// node_modules/lingo3d/lib/editor/SceneGraph/ModelTreeItem.js
preventTreeShake(v);
var ModelTreeItem = ({ appendable, level }) => {
  const [loadedObject3d, setLoadedObject3d] = y2();
  const { loaded } = appendable;
  _2(() => {
    setLoadedObject3d(void 0);
    const handle = loaded.then(() => setLoadedObject3d(appendable.loadedGroup.children[0]));
    return () => {
      handle.cancel();
    };
  }, [loaded]);
  return e2(TreeItem_default, { appendable, level, children: loadedObject3d && e2(Object3DTreeItem_default, { appendable, level: level + 1, object3d: loadedObject3d }) });
};
var ModelTreeItem_default = ModelTreeItem;

// node_modules/lingo3d/lib/editor/SceneGraph/useClick.js
var useClick_default = (cb2) => {
  const [el, setEl] = y2(null);
  _2(() => {
    if (!el)
      return;
    let downTime = 0;
    let downX = 0;
    let downY = 0;
    const handleMouseDown = (e5) => {
      downTime = Date.now();
      downX = e5.clientX;
      downY = e5.clientY;
    };
    const handleMouseUp = (e5) => {
      const upTime = Date.now();
      const deltaTime = upTime - downTime;
      const deltaX = Math.abs(e5.clientX - downX);
      const deltaY = Math.abs(e5.clientY - downY);
      downTime = upTime;
      downX = e5.clientX;
      downY = e5.clientY;
      deltaTime < 300 && deltaX < 5 && deltaY < 5 && cb2(e5);
    };
    el.addEventListener("mousedown", handleMouseDown);
    el.addEventListener("mouseup", handleMouseUp);
    return () => {
      el.removeEventListener("mousedown", handleMouseDown);
      el.removeEventListener("mouseup", handleMouseUp);
    };
  }, [el]);
  return setEl;
};

// node_modules/lingo3d/lib/editor/SceneGraph/TreeItem.js
preventTreeShake(v);
var makeTreeItemCallbacks = (target, parent) => {
  const setClickEl = useClick_default((e5) => {
    e5.stopPropagation();
    mainOrbitCamera_default.activate();
    isPositionedItem(parent) && getSelectionTarget() !== parent && emitSelectionTarget(parent);
    if (target instanceof Object3D)
      queueMicrotask(() => setSceneGraphTarget(target));
    else
      emitSelectionTarget(target);
  });
  const handleClick = (e5) => e5.stopPropagation();
  const handleDoubleClick = (e5) => {
    e5.stopPropagation();
    if (!isPositionedItem(target))
      return;
    emitEditorCenterView(target);
    emitSelectionTarget(target);
  };
  return { setClickEl, handleClick, handleDoubleClick };
};
var draggingItemPtr = [void 0];
var TreeItem = ({ appendable, level, children: children2 }) => {
  var _a2;
  const name = getComponentName_default(appendable);
  const appendableChildren = F(() => {
    return appendable.children ? [...appendable.children].filter((item) => !hiddenAppendables.has(item)) : void 0;
  }, [(_a2 = appendable.children) == null ? void 0 : _a2.size]);
  const expandIconStyle = { opacity: (appendableChildren == null ? void 0 : appendableChildren.length) || children2 ? 0.5 : 0.05, cursor: "pointer" };
  const [dragOver, setDragOver] = y2(false);
  const [expanded, setExpanded] = y2(false);
  const [selectionTarget] = useSelectionTarget();
  const [multipleSelectionTargets] = useMultipleSelectionTargets();
  const selected = selectionTarget === appendable || multipleSelectionTargets.includes(appendable);
  const { setClickEl, handleClick, handleDoubleClick } = makeTreeItemCallbacks(appendable);
  const [sceneGraphExpanded, setSceneGraphExpanded2] = useSceneGraphExpanded();
  _2(() => {
    if (!sceneGraphExpanded)
      return;
    if (sceneGraphExpanded.has(appendable.outerObject3d))
      setExpanded(true);
  }, [sceneGraphExpanded]);
  const startRef = s2(null);
  const endRef = s2(null);
  const highlightWidth = F(() => {
    if (!selected || !startRef.current || !endRef.current)
      return;
    const boundsStart = startRef.current.getBoundingClientRect();
    const boundsEnd = endRef.current.getBoundingClientRect();
    return boundsEnd.right - boundsStart.left + 4;
  }, [selected, expanded]);
  const [preventDrag] = useSceneGraphPreventDrag();
  return e2("div", { ref: setClickEl, onClick: handleClick, onDblClick: handleDoubleClick, draggable: !preventDrag, onDragStart: (e5) => (e5.stopPropagation(), draggingItemPtr[0] = appendable), onDragEnd: (e5) => (e5.stopPropagation(), draggingItemPtr[0] = void 0), onDragOver: (e5) => {
    e5.stopPropagation();
    e5.preventDefault();
    if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
      return;
    setDragOver(true);
  }, onDragEnter: (e5) => {
    e5.stopPropagation();
    e5.preventDefault();
    if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
      return;
    setDragOver(true);
  }, onDragLeave: (e5) => {
    e5.stopPropagation();
    if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
      return;
    setDragOver(false);
  }, onDrop: (e5) => {
    e5.stopPropagation();
    if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
      return;
    setDragOver(false);
    appendable.attach(draggingItemPtr[0]);
  }, style: {
    color: "rgba(255, 255, 255, 0.75)",
    marginLeft: 8,
    borderLeft: "1px solid rgba(255, 255, 255, 0.05)",
    background: dragOver ? "rgba(255, 255, 255, 0.5)" : "none"
  }, children: [e2("div", { ref: startRef, style: {
    display: "flex",
    alignItems: "center",
    backgroundColor: selected ? "rgba(255, 255, 255, 0.1)" : void 0,
    width: highlightWidth,
    minWidth: "100%",
    cursor: "default"
  }, children: [expanded ? e2(CollapseIcon_default, { style: expandIconStyle, onClick: () => (setExpanded(false), setSceneGraphExpanded2(void 0)) }) : e2(ExpandIcon_default, { style: expandIconStyle, onClick: () => setExpanded(true) }), e2(CubeIcon_default, {}), e2("div", { ref: endRef, children: name })] }), expanded && (appendableChildren == null ? void 0 : appendableChildren.map((childAppendable) => childAppendable instanceof Model ? e2(ModelTreeItem_default, { appendable: childAppendable, level: level + 1 }, childAppendable.uuid) : e2(TreeItem, { appendable: childAppendable, level: level + 1 }, childAppendable.uuid))), expanded && children2] });
};
var TreeItem_default = TreeItem;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/GroupIcon.js
preventTreeShake(v);
var GroupIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M640 384h224a32 32 0 0132 32v384h-96v96H416a32 32 0 01-32-32V640H160a32 32 0 01-32-32V224h96v-96h384a32 32 0 0132 32v224zm0 32v192a32 32 0 01-32 32H416v224h352v-96h96V416H640zM96 96h96v96H96V96zm736 0h96v96h-96V96zM96 832h96v96H96v-96zm736 0h96v96h-96v-96z" }) });
};
var GroupIcon_default = GroupIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/DeleteIcon.js
preventTreeShake(v);
var DeleteIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M630.09 151.91V62.16H361.84v89.74H93.6v134.62h89.41v673.11h625.93v-673.1h89.42V151.91H630.09zM361.84 869.89h-89.43V286.53h89.43v583.36zm178.84 0h-89.43V286.53h89.43v583.36zm178.84 0h-89.43V286.53h89.43v583.36z" }) });
};
var DeleteIcon_default = DeleteIcon;

// node_modules/lingo3d/lib/editor/SceneGraph/TitleBarButton.js
preventTreeShake(v);
var TitleBarButton = ({ children: children2, onClick, active }) => {
  return e2("div", { onClick: active ? onClick : void 0, style: {
    width: 24,
    height: 24,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    marginRight: 2,
    opacity: active ? 1 : 0.1,
    cursor: active ? "pointer" : "default"
  }, children: children2 });
};
var TitleBarButton_default = TitleBarButton;

// node_modules/lingo3d/lib/editor/SceneGraph/EmptyItem.js
preventTreeShake(v);
var EmptyItem = () => {
  const [dragOver, setDragOver] = y2(false);
  return e2("div", { onDragOver: (e5) => {
    e5.stopPropagation();
    e5.preventDefault();
    if (!draggingItemPtr[0])
      return;
    setDragOver(true);
  }, onDragEnter: (e5) => {
    e5.stopPropagation();
    e5.preventDefault();
    if (!draggingItemPtr[0])
      return;
    setDragOver(true);
  }, onDragLeave: (e5) => {
    e5.stopPropagation();
    if (!draggingItemPtr[0])
      return;
    setDragOver(false);
  }, onDrop: (e5) => {
    var _a2, _b;
    e5.stopPropagation();
    setDragOver(false);
    const child = draggingItemPtr[0];
    if (!child)
      return;
    emitSceneGraphChange();
    appendableRoot.add(child);
    scene_default.attach(child.outerObject3d);
    (_b = (_a2 = child.parent) == null ? void 0 : _a2.children) == null ? void 0 : _b.delete(child);
    child.parent = void 0;
  }, style: {
    background: dragOver ? "rgba(255, 255, 255, 0.5)" : "none",
    width: "100%",
    height: 18
  } });
};
var EmptyItem_default = EmptyItem;

// node_modules/lingo3d/lib/editor/SceneGraph/icons/FindIcon.js
preventTreeShake(v);
var FindIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 1024 1024", children: e2(ComponentIconPath_default, {}) });
};
var FindIcon_default = FindIcon;

// node_modules/lingo3d/lib/utils/downloadBlob.js
var downloadBlob_default = (filename, blob) => {
  const elem = document.createElement("a");
  const objectURL = elem.href = URL.createObjectURL(blob);
  elem.download = filename;
  document.body.appendChild(elem);
  elem.click();
  document.body.removeChild(elem);
  URL.revokeObjectURL(objectURL);
};

// node_modules/lingo3d/lib/editor/SceneGraph/ContextMenu.js
preventTreeShake(v);
var traverseUp = (obj, expandedSet) => {
  var _a2, _b, _c;
  expandedSet.add(obj);
  const nextParent = (_c = (_b = (_a2 = obj.userData.manager) == null ? void 0 : _a2.parent) == null ? void 0 : _b.outerObject3d) != null ? _c : obj.parent;
  nextParent && traverseUp(nextParent, expandedSet);
};
var search = (n3, target) => {
  const name = n3.toLowerCase();
  let found;
  if (target instanceof Loaded)
    target.loadedGroup.traverse((item) => {
      if (found)
        return;
      item.name.toLowerCase().includes(name) && (found = item);
    });
  else
    target.outerObject3d.traverse((item) => {
      if (found)
        return;
      item.name.toLowerCase().includes(name) && (found = item);
    });
  if (!found)
    return;
  const expandedSet = /* @__PURE__ */ new Set();
  traverseUp(found, expandedSet);
  setSceneGraphExpanded(expandedSet);
  setSceneGraphTarget(found);
};
var MenuItem = ({ disabled, onClick, children: children2 }) => {
  const [hover, setHover] = y2(false);
  return e2("div", { style: {
    padding: 6,
    whiteSpace: "nowrap",
    background: !disabled && hover ? "rgba(255, 255, 255, 0.1)" : void 0,
    opacity: disabled ? 0.5 : 1
  }, onClick: disabled ? void 0 : onClick, onMouseEnter: disabled ? void 0 : () => setHover(true), onMouseLeave: disabled ? void 0 : () => setHover(false), children: children2 });
};
var ContextMenu = () => {
  const [data, setData] = y2(void 0);
  const [showSearch, setShowSearch] = y2(false);
  const [selectionTarget] = useSelectionTarget();
  const [[selectionFrozen]] = useSelectionFrozen();
  _2(() => {
    let [clientX, clientY] = [0, 0];
    const cb2 = (e5) => [clientX, clientY] = [e5.clientX, e5.clientY];
    document.addEventListener("mousemove", cb2);
    const handle = onSelectionTarget(({ target, rightClick }) => {
      rightClick && setData({ x: clientX, y: clientY, target });
    });
    return () => {
      handle.cancel();
      document.removeEventListener("mousemove", cb2);
    };
  }, []);
  _2(() => {
    !data && setShowSearch(false);
  }, [data]);
  if (!data)
    return null;
  return e2("div", { className: "lingo3d-ui", onMouseDown: () => setData(void 0), style: {
    zIndex: 9999,
    position: "absolute",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    overflow: "hidden"
  }, children: e2("div", { onMouseDown: (e5) => e5.stopPropagation(), style: {
    position: "absolute",
    left: data.x,
    top: data.y,
    background: "rgb(40, 41, 46)",
    padding: 6
  }, children: showSearch ? e2("input", { ref: (el) => el == null ? void 0 : el.focus(), style: { all: "unset", padding: 6 }, onKeyDown: (e5) => {
    e5.stopPropagation();
    if (e5.key !== "Enter" && e5.key !== "Escape")
      return;
    e5.key === "Enter" && selectionTarget && search(e5.target.value, selectionTarget);
    setData(void 0);
  } }) : e2(d, { children: [data.target && e2(d, { children: [e2(MenuItem, { onClick: () => setShowSearch(true), children: "Search children" }), e2(MenuItem, { onClick: () => {
    isMeshItem(selectionTarget) && addSelectionFrozen(selectionTarget);
    setData(void 0);
  }, children: "Freeze selection" }), selectionTarget instanceof Dummy && dummyTypeMap.has(selectionTarget) && e2(MenuItem, { onClick: async () => {
    setData(void 0);
    const url2 = dummyTypeMap.get(selectionTarget) === "dummy" ? YBOT_URL : DUMMY_URL + "readyplayerme/reference.fbx";
    const res = await fetch(url2);
    downloadBlob_default("model.fbx", await res.blob());
  }, children: "Download for Mixamo" })] }), e2(MenuItem, { disabled: !selectionFrozen.size, onClick: () => {
    clearSelectionFrozen();
    setData(void 0);
  }, children: "Unfreeze all" })] }) }) });
};
var ContextMenu_default = ContextMenu;

// node_modules/lingo3d/lib/states/useRetargetBones.js
var [setRetargetBones, getRetargetBones] = store(void 0);

// node_modules/lingo3d/lib/editor/SceneGraph/retargetBones.js
var retargetBones_default = {};
createEffect(() => {
  const dummy = getRetargetBones();
  if (!dummy)
    return;
  const handle = new Cancellable();
  handle.watch(dummy.loaded.then((loadedGroup) => {
    const bone = loadedGroup.getObjectByProperty("type", "Bone");
    bone.traverse((parent) => parent.name = "mixamorig" + parent.name);
  }));
  return () => {
    handle.cancel();
  };
}, [getRetargetBones]);

// node_modules/lingo3d/lib/editor/SceneGraph/index.js
preventTreeShake([v, retargetBones_default]);
var SceneGraph = () => {
  const [r5, render] = y2({});
  h2(() => {
    const cb2 = () => render({});
    const handle0 = onSceneGraphChange(cb2);
    const handle1 = onSceneGraphNameChange(cb2);
    emitEditorMountChange();
    return () => {
      handle0.cancel();
      handle1.cancel();
      emitEditorMountChange();
    };
  }, []);
  const appendables = F(() => [...appendableRoot].filter((item) => !multipleSelectionGroupManagers.has(item) && !hiddenAppendables.has(item)), [r5]);
  const [multipleSelectionTargets] = useMultipleSelectionTargets();
  const [selectionTarget] = useSelectionTarget();
  const [sceneGraphTarget] = useSceneGraphTarget();
  const [cameraStack] = useCameraStack();
  const camera = last(cameraStack);
  const handleFind = () => {
    if ((sceneGraphTarget == null ? void 0 : sceneGraphTarget.name) && selectionTarget instanceof ObjectManager)
      setTimeout(() => emitSelectionTarget(selectionTarget.find(sceneGraphTarget.name)));
  };
  return e2(d, { children: [e2("div", { className: "lingo3d-ui", onClick: () => emitSelectionTarget(), style: {
    width: 200,
    height: "100%",
    background: "rgb(40, 41, 46)",
    padding: 4,
    paddingTop: 0,
    display: "flex",
    flexDirection: "column",
    overflow: "hidden"
  }, children: [e2("div", { style: {
    height: 24,
    borderBottom: "1px solid rgb(255,255,255,0.1)",
    opacity: camera === mainCamera_default ? 0.5 : 0.25,
    display: "flex",
    alignItems: "center",
    paddingLeft: 12
  }, children: [e2("div", { children: "scenegraph" }), e2("div", { style: { flexGrow: 1 } }), e2(TitleBarButton_default, { active: !!sceneGraphTarget, onClick: handleFind, children: e2(FindIcon_default, {}) }), e2(TitleBarButton_default, { active: !!multipleSelectionTargets.length, onClick: emitEditorGroupItems, children: e2(GroupIcon_default, {}) }), e2(TitleBarButton_default, { active: !!selectionTarget, onClick: deleteSelected_default, children: e2(DeleteIcon_default, {}) })] }), e2("div", { style: { overflow: "scroll", opacity: camera === mainCamera_default ? 1 : 0.5 }, className: "lingo3d-ui", children: [appendables.map((appendable) => appendable instanceof Model ? e2(ModelTreeItem_default, { appendable, level: 0 }, appendable.uuid) : e2(TreeItem_default, { appendable, level: 0 }, appendable.uuid)), e2(EmptyItem_default, {})] })] }), e2(ContextMenu_default, {})] });
};
preact_custom_element_esm_default(SceneGraph, "lingo3d-scenegraph");

// node_modules/lingo3d/lib/editor/Toolbar/icons/TranslateIcon.js
preventTreeShake(v);
var TranslateIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M960 480L768 320v128H512V192h128L480 0 320 192h128v256H192V320L0 480l192 160V512h256v256H320l160 192 160-192H512V512h256v128l192-160z" }) });
};
var TranslateIcon_default = TranslateIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/RotateIcon.js
preventTreeShake(v);
var RotateIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M929 849a30 30 0 01-30-30v-83.137a447.514 447.514 0 01-70.921 92.209C722.935 933.225 578.442 975.008 442 953.482a444.917 444.917 0 01-241.139-120.591 30 30 0 1137.258-47.01l.231-.231A385.175 385.175 0 00442 892.625v-.006c120.855 22.123 250.206-13.519 343.656-106.975a386.646 386.646 0 0070.6-96.653h-87.247a30 30 0 010-60H929a30 30 0 0130 30V819a30 30 0 01-30 30zM512 392a120 120 0 11-120 120 120 120 0 01120-120zm293.005-147.025a29.87 29.87 0 01-19.117-6.882l-.232.231A386.5 386.5 0 00689.478 168h-.011c-145.646-75.182-329.021-51.747-451.117 70.35a386.615 386.615 0 00-70.6 96.65H255a30 30 0 010 60H95a30 30 0 01-30-30V205a30 30 0 0160 0v83.129a447.534 447.534 0 0170.923-92.206C317.981 73.866 493.048 37.2 647 85.836v-.045a444.883 444.883 0 01176.143 105.291 30 30 0 01-18.138 53.893z" }) });
};
var RotateIcon_default = RotateIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/ScaleIcon.js
preventTreeShake(v);
var ScaleIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M609.52 584.92a35.309 35.309 0 0124.98-10.36c9.37 0 18.36 3.73 24.98 10.36l189.29 189.22-.07-114.3.57-6.35c3.25-17.98 19.7-30.5 37.9-28.85 18.2 1.65 32.12 16.92 32.09 35.2v200.23c-.05 1.49-.19 2.97-.42 4.45l-.21 1.13c-.22 1.44-.55 2.85-.99 4.24l-.57 1.62-.56 1.41a34.163 34.163 0 01-7.62 11.36l2.12-2.4-.14.14-.92 1.06-1.06 1.2-.57.57-.56.57a36.378 36.378 0 01-16.23 8.39l-3.53.5-4.02.35h-199.6l-6.35-.63c-16.73-3.06-28.9-17.63-28.93-34.64l.56-6.35c3.07-16.76 17.67-28.93 34.71-28.92l114.29-.14-189.07-189.1-4.09-4.94c-9.71-14.01-8.01-32.95 4.02-45.02zm-162.06 0c12.06 12.05 13.78 30.99 4.09 45.01l-4.09 4.94-189.15 189.08 114.3.14c17.04-.01 31.65 12.17 34.71 28.92l.57 6.35c-.03 17.01-12.19 31.58-28.92 34.64l-6.35.63H173.09l-4.23-.42-3.39-.49a36.38 36.38 0 01-17.36-9.52l-1.06-1.13-.98-1.13.98 1.06-1.97-2.26.85 1.06-.42-.56a35.137 35.137 0 01-3.74-5.64l-1.13-2.68a34.71 34.71 0 01-2.11-7.33l-.28-1.13c-.21-1.47-.33-2.96-.36-4.45V659.78c-.03-18.28 13.89-33.55 32.09-35.2 18.2-1.65 34.65 10.87 37.9 28.85l.57 6.35-.07 114.36 189.29-189.22c13.77-13.77 36.11-13.77 49.88 0h-.09zm-74.71-471.71l6.35.57c16.76 3.06 28.93 17.67 28.92 34.71l-.63 6.35c-3.07 16.76-17.67 28.93-34.71 28.92l-114.3.14 189.15 189.08 4.09 4.94c10.26 15.02 7.42 35.37-6.55 47.01-13.98 11.63-34.51 10.74-47.42-2.07L208.29 233.71l.07 114.3-.57 6.35c-3.25 17.98-19.7 30.5-37.9 28.85-18.2-1.65-32.12-16.92-32.09-35.2V147.78c0-1.55.14-3.03.35-4.51l.21-1.13c.24-1.44.59-2.85 1.06-4.23a34.97 34.97 0 018.68-14.39l-2.12 2.4-.42.57 1.55-1.84-.99 1.06.92-.98 2.26-2.33c3.04-2.73 6.52-4.92 10.3-6.49l2.82-1.06c3.45-1.07 7.04-1.62 10.65-1.62l-3.6.14h.49l1.48-.14h201.31zm512.91 0l1.41.14h.42c2.43.29 4.84.79 7.19 1.48l2.82 1.06 2.61 1.2 3.04 1.76c2.09 1.33 4.03 2.89 5.78 4.66l1.13 1.2.78.98.21.14.49.64 2.33 3.17c2.35 3.83 3.98 8.07 4.8 12.49l.21 1.13c.21 1.48.35 2.96.35 4.44v200.37c-.16 18.13-14.03 33.19-32.08 34.83-18.06 1.64-34.42-10.67-37.83-28.48l-.57-6.35V233.65L659.54 422.87c-12.9 12.95-33.56 13.91-47.59 2.2-14.04-11.71-16.81-32.2-6.38-47.22l4.02-4.86 189.22-189.08-114.29-.14c-17.06.04-31.71-12.14-34.78-28.92l-.63-6.35c-.01-17.04 12.16-31.65 28.93-34.71l6.35-.57h201.27zm0 0" }) });
};
var ScaleIcon_default = ScaleIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/AbsoluteIcon.js
preventTreeShake(v);
var AbsoluteIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: [e2("path", { fill: "#fff", d: "M96 892.8V121.6c0-16 12.8-28.8 28.8-28.8h774.4c16 0 28.8 12.8 28.8 28.8v771.2c0 16-12.8 28.8-28.8 28.8H124.8c-16 3.2-28.8-9.6-28.8-28.8zm64-736v704h704v-704H160z" }), e2("path", { fill: "#fff", d: "M352 656V358.4c0-6.4 6.4-12.8 9.6-12.8h297.6c6.4 0 9.6 6.4 9.6 12.8V656c0 6.4-6.4 12.8-9.6 12.8H361.6c-3.2 0-9.6-6.4-9.6-12.8zm80-227.2v160h160v-160H432zm240 108.8v-48h192v48H672zm121.6-48H736v48h57.6v-48zm-633.6 48v-48h192v48H160zm124.8-48H224v48h57.6v-48z" }), e2("path", { fill: "#fff", d: "M489.6 156.8h48v192h-48v-192zm48 121.6v-57.6h-48v57.6h48zm-48 387.2h48v195.2h-48V665.6zm48 124.8v-57.6h-48v57.6h48z" })] });
};
var AbsoluteIcon_default = AbsoluteIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/RelativeIcon.js
preventTreeShake(v);
var RelativeIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M185.6 489.6h-48c-3.2 0-9.6 3.2-9.6 9.6v384c0 3.2 3.2 9.6 9.6 9.6h48c3.2 0 9.6-3.2 9.6-9.6v-384c-3.2-6.4-6.4-9.6-9.6-9.6zm217.6 236.8c6.4 0 12.8-3.2 12.8-9.6v-48c0-3.2-6.4-9.6-12.8-9.6H140.8c-6.4 0-12.8 3.2-12.8 9.6v48c0 3.2 6.4 9.6 12.8 9.6h262.4zm512-547.2v-48c0-3.2-3.2-9.6-9.6-9.6h-384c-3.2 0-9.6 3.2-9.6 9.6v48c0 3.2 3.2 9.6 9.6 9.6h384c6.4 0 9.6-6.4 9.6-9.6zM678.4 377.6c0 6.4 3.2 9.6 9.6 9.6h48c3.2 0 9.6-3.2 9.6-9.6V134.4c0-6.4-3.2-9.6-9.6-9.6h-48c-3.2 0-9.6 3.2-9.6 9.6v243.2zm-195.2 89.6v416c0 9.6 6.4 16 16 16h400c9.6 0 16-6.4 16-16v-416c0-9.6-6.4-16-16-16h-400c-9.6 0-16 9.6-16 16zm361.6 57.6v304h-288v-304h288z" }) });
};
var RelativeIcon_default = RelativeIcon;

// node_modules/lingo3d/lib/editor/Toolbar/IconButton.js
preventTreeShake(v);
var IconButton = ({ children: children2, onClick, active, disabled }) => {
  return e2("div", { style: {
    margin: 6,
    padding: 6,
    background: active ? "rgba(255, 255, 255, 0.1)" : void 0,
    borderRadius: 4,
    opacity: disabled ? 0.25 : active ? 1 : 0.75,
    cursor: "pointer"
  }, onClick: disabled || active ? void 0 : onClick, children: children2 });
};
var IconButton_default = IconButton;

// node_modules/lingo3d/lib/editor/Toolbar/icons/CursorIcon.js
preventTreeShake(v);
var CursorIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", style: { left: -2 }, children: e2("path", { fill: "#fff", d: "M279.552 198.879a22.26 22.26 0 0135.217-20.347L933.265 628.47a22.26 22.26 0 01-11.799 40.248l-324.43 19.456a22.26 22.26 0 00-17.23 9.972l-179.11 271.227a22.26 22.26 0 01-40.738-9.929L279.597 198.88z" }) });
};
var CursorIcon_default = CursorIcon;

// node_modules/lingo3d/lib/editor/Toolbar/Separator.js
preventTreeShake(v);
var Separator = () => {
  return e2("div", { style: { width: "60%", height: 2, background: "rgba(255, 255, 255, 0.1)", margin: 12 } });
};
var Separator_default = Separator;

// node_modules/lingo3d/lib/editor/Toolbar/icons/ExportIcon.js
preventTreeShake(v);
var ExportIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: [e2("path", { fill: "#fff", d: "M808.192 246.528a320.16 320.16 0 00-592.352 0A238.592 238.592 0 0032 479.936c0 132.352 107.648 240 240 240h91.488a32 32 0 100-64H272a176.192 176.192 0 01-176-176 175.04 175.04 0 01148.48-173.888l19.04-2.976 6.24-18.24C305.248 181.408 402.592 111.936 512 111.936a256 256 0 01242.208 172.896l6.272 18.24 19.04 2.976A175.04 175.04 0 01928 479.936c0 97.024-78.976 176-176 176h-97.28a32 32 0 100 64H752c132.352 0 240-107.648 240-240a238.592 238.592 0 00-183.808-233.408z" }), e2("path", { fill: "#fff", d: "M649.792 789.888L544 876.48V447.936a32 32 0 00-64 0V876.48l-106.752-87.424a31.968 31.968 0 10-40.544 49.504l159.04 130.24a32 32 0 0040.576 0l158.048-129.44a32 32 0 10-40.576-49.472z" })] });
};
var ExportIcon_default = ExportIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/OpenIcont.js
preventTreeShake(v);
var OpenIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: [e2("path", { fill: "#fff", d: "M870.4 342.4c-12.8 0-24-11.2-24-24V153.6c0-12.8 11.2-24 24-24s24 11.2 24 24v164.8c0 12.8-11.2 24-24 24z" }), e2("path", { fill: "#fff", d: "M870.4 177.6H705.6c-12.8 0-24-11.2-24-24s11.2-24 24-24h164.8c12.8 0 24 11.2 24 24s-11.2 24-24 24zm-96 716.8H249.6c-65.6 0-120-54.4-120-120V249.6c0-65.6 54.4-120 120-120H512c12.8 0 24 11.2 24 24s-11.2 24-24 24H249.6c-40 0-72 32-72 72v524.8c0 40 32 72 72 72h524.8c40 0 72-32 72-72V512c0-12.8 11.2-24 24-24s24 11.2 24 24v262.4c0 65.6-54.4 120-120 120z" }), e2("path", { fill: "#fff", d: "M526.4 521.6c-6.4 0-12.8-1.6-17.6-6.4-9.6-9.6-9.6-24 0-33.6l344-344c9.6-9.6 24-9.6 33.6 0 9.6 9.6 9.6 24 0 33.6l-344 344c-4.8 4.8-11.2 6.4-16 6.4z" })] });
};
var OpenIcont_default = OpenIcon;

// node_modules/browser-fs-access/dist/index.modern.js
var e4 = (() => {
  if (typeof self == "undefined")
    return false;
  if ("top" in self && self !== top)
    try {
      top;
    } catch (e5) {
      return false;
    }
  else if ("showOpenFilePicker" in self)
    return "showOpenFilePicker";
  return false;
})();
var t4 = e4 ? Promise.resolve().then(function() {
  return l4;
}) : Promise.resolve().then(function() {
  return h3;
});
async function n2(...e5) {
  return (await t4).default(...e5);
}
var r4 = e4 ? Promise.resolve().then(function() {
  return f3;
}) : Promise.resolve().then(function() {
  return b3;
});
var a4 = e4 ? Promise.resolve().then(function() {
  return m3;
}) : Promise.resolve().then(function() {
  return _3;
});
var s4 = async (e5) => {
  const t5 = await e5.getFile();
  return t5.handle = e5, t5;
};
var c4 = async (e5 = [{}]) => {
  Array.isArray(e5) || (e5 = [e5]);
  const t5 = [];
  e5.forEach((e6, n4) => {
    t5[n4] = { description: e6.description || "", accept: {} }, e6.mimeTypes ? e6.mimeTypes.map((r6) => {
      t5[n4].accept[r6] = e6.extensions || [];
    }) : t5[n4].accept["*/*"] = e6.extensions || [];
  });
  const n3 = await window.showOpenFilePicker({ id: e5[0].id, startIn: e5[0].startIn, types: t5, multiple: e5[0].multiple || false, excludeAcceptAllOption: e5[0].excludeAcceptAllOption || false }), r5 = await Promise.all(n3.map(s4));
  return e5[0].multiple ? r5 : r5[0];
};
var l4 = { __proto__: null, default: c4 };
function u4(e5) {
  function t5(e6) {
    if (Object(e6) !== e6)
      return Promise.reject(new TypeError(e6 + " is not an object."));
    var t6 = e6.done;
    return Promise.resolve(e6.value).then(function(e7) {
      return { value: e7, done: t6 };
    });
  }
  return u4 = function(e6) {
    this.s = e6, this.n = e6.next;
  }, u4.prototype = { s: null, n: null, next: function() {
    return t5(this.n.apply(this.s, arguments));
  }, return: function(e6) {
    var n3 = this.s.return;
    return n3 === void 0 ? Promise.resolve({ value: e6, done: true }) : t5(n3.apply(this.s, arguments));
  }, throw: function(e6) {
    var n3 = this.s.return;
    return n3 === void 0 ? Promise.reject(e6) : t5(n3.apply(this.s, arguments));
  } }, new u4(e5);
}
var p2 = async (e5, t5, n3 = e5.name, r5) => {
  const i4 = [], a5 = [];
  var o4, s5 = false, c5 = false;
  try {
    for (var l5, y4 = function(e6) {
      var t6, n4, r6, i5 = 2;
      for (typeof Symbol != "undefined" && (n4 = Symbol.asyncIterator, r6 = Symbol.iterator); i5--; ) {
        if (n4 && (t6 = e6[n4]) != null)
          return t6.call(e6);
        if (r6 && (t6 = e6[r6]) != null)
          return new u4(t6.call(e6));
        n4 = "@@asyncIterator", r6 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e5.values()); s5 = !(l5 = await y4.next()).done; s5 = false) {
      const o5 = l5.value, s6 = `${n3}/${o5.name}`;
      o5.kind === "file" ? a5.push(o5.getFile().then((t6) => (t6.directoryHandle = e5, t6.handle = o5, Object.defineProperty(t6, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s6 })))) : o5.kind !== "directory" || !t5 || r5 && r5(o5) || i4.push(p2(o5, t5, s6, r5));
    }
  } catch (e6) {
    c5 = true, o4 = e6;
  } finally {
    try {
      s5 && y4.return != null && await y4.return();
    } finally {
      if (c5)
        throw o4;
    }
  }
  return [...(await Promise.all(i4)).flat(), ...await Promise.all(a5)];
};
var y3 = async (e5 = {}) => {
  e5.recursive = e5.recursive || false;
  const t5 = await window.showDirectoryPicker({ id: e5.id, startIn: e5.startIn });
  return p2(t5, e5.recursive, void 0, e5.skipDirectory);
};
var f3 = { __proto__: null, default: y3 };
var d3 = async (e5, t5 = [{}], n3 = null, r5 = false, i4 = null) => {
  Array.isArray(t5) || (t5 = [t5]), t5[0].fileName = t5[0].fileName || "Untitled";
  const a5 = [];
  let o4 = null;
  if (e5 instanceof Blob && e5.type ? o4 = e5.type : e5.headers && e5.headers.get("content-type") && (o4 = e5.headers.get("content-type")), t5.forEach((e6, t6) => {
    a5[t6] = { description: e6.description || "", accept: {} }, e6.mimeTypes ? (t6 === 0 && o4 && e6.mimeTypes.push(o4), e6.mimeTypes.map((n4) => {
      a5[t6].accept[n4] = e6.extensions || [];
    })) : o4 ? a5[t6].accept[o4] = e6.extensions || [] : a5[t6].accept["*/*"] = e6.extensions || [];
  }), n3)
    try {
      await n3.getFile();
    } catch (e6) {
      if (n3 = null, r5)
        throw e6;
    }
  const s5 = n3 || await window.showSaveFilePicker({ suggestedName: t5[0].fileName, id: t5[0].id, startIn: t5[0].startIn, types: a5, excludeAcceptAllOption: t5[0].excludeAcceptAllOption || false });
  !n3 && i4 && i4();
  const c5 = await s5.createWritable();
  if ("stream" in e5) {
    const t6 = e5.stream();
    return await t6.pipeTo(c5), s5;
  }
  return "body" in e5 ? (await e5.body.pipeTo(c5), s5) : (await c5.write(await e5), await c5.close(), s5);
};
var m3 = { __proto__: null, default: d3 };
var w3 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), new Promise((t5, n3) => {
  const r5 = document.createElement("input");
  r5.type = "file";
  const i4 = [...e5.map((e6) => e6.mimeTypes || []), ...e5.map((e6) => e6.extensions || [])].join();
  r5.multiple = e5[0].multiple || false, r5.accept = i4 || "";
  const a5 = (e6) => {
    typeof o4 == "function" && o4(), t5(e6);
  }, o4 = e5[0].legacySetup && e5[0].legacySetup(a5, () => o4(n3), r5);
  r5.addEventListener("change", () => {
    a5(r5.multiple ? Array.from(r5.files) : r5.files[0]);
  }), r5.click();
}));
var h3 = { __proto__: null, default: w3 };
var v3 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), e5[0].recursive = e5[0].recursive || false, new Promise((t5, n3) => {
  const r5 = document.createElement("input");
  r5.type = "file", r5.webkitdirectory = true;
  const i4 = (e6) => {
    typeof a5 == "function" && a5(), t5(e6);
  }, a5 = e5[0].legacySetup && e5[0].legacySetup(i4, () => a5(n3), r5);
  r5.addEventListener("change", () => {
    let t6 = Array.from(r5.files);
    e5[0].recursive ? e5[0].recursive && e5[0].skipDirectory && (t6 = t6.filter((t7) => t7.webkitRelativePath.split("/").every((t8) => !e5[0].skipDirectory({ name: t8, kind: "directory" })))) : t6 = t6.filter((e6) => e6.webkitRelativePath.split("/").length === 2), i4(t6);
  }), r5.click();
}));
var b3 = { __proto__: null, default: v3 };
var P2 = async (e5, t5 = {}) => {
  Array.isArray(t5) && (t5 = t5[0]);
  const n3 = document.createElement("a");
  let r5 = e5;
  "body" in e5 && (r5 = await async function(e6, t6) {
    const n4 = e6.getReader(), r6 = new ReadableStream({ start: (e7) => async function t7() {
      return n4.read().then(({ done: n5, value: r7 }) => {
        if (!n5)
          return e7.enqueue(r7), t7();
        e7.close();
      });
    }() }), i5 = new Response(r6), a6 = await i5.blob();
    return n4.releaseLock(), new Blob([a6], { type: t6 });
  }(e5.body, e5.headers.get("content-type"))), n3.download = t5.fileName || "Untitled", n3.href = URL.createObjectURL(await r5);
  const i4 = () => {
    typeof a5 == "function" && a5();
  }, a5 = t5.legacySetup && t5.legacySetup(i4, () => a5(), n3);
  return n3.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n3.href), 3e4), i4();
  }), n3.click(), null;
};
var _3 = { __proto__: null, default: P2 };

// node_modules/lingo3d/lib/editor/Toolbar/icons/ReactIcon.js
preventTreeShake(v);
var ReactIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M836.8 353.6c-11.2-3.2-20.8-6.4-32-9.6 1.6-8 3.2-14.4 4.8-22.4 24-118.4 8-214.4-46.4-246.4C710.4 44.8 624 76.8 537.6 152c-8 8-17.6 14.4-25.6 22.4-4.8-4.8-11.2-9.6-16-16-91.2-81.6-182.4-115.2-236.8-83.2-52.8 30.4-68.8 120-46.4 233.6 1.6 11.2 4.8 22.4 8 33.6-12.8 3.2-25.6 8-36.8 11.2C76.8 392 0 451.2 0 510.4c0 62.4 81.6 124.8 192 163.2 9.6 3.2 17.6 6.4 27.2 8-3.2 12.8-6.4 24-8 36.8-20.8 110.4-4.8 198.4 48 228.8 54.4 32 145.6 0 233.6-78.4 6.4-6.4 14.4-12.8 20.8-19.2 8 8 17.6 16 27.2 24 84.8 73.6 169.6 104 222.4 73.6 54.4-32 72-126.4 48-241.6-1.6-8-3.2-17.6-6.4-27.2 6.4-1.6 12.8-3.2 19.2-6.4 116.8-35.2 200-97.6 200-161.6 0-59.2-78.4-118.4-187.2-156.8zM566.4 184c75.2-65.6 144-89.6 176-72 33.6 19.2 46.4 97.6 25.6 201.6-1.6 6.4-3.2 12.8-4.8 20.8-44.8-9.6-89.6-17.6-134.4-20.8C603.2 276.8 574.4 240 544 208c6.4-9.6 14.4-16 22.4-24zm-232 430.4c9.6 17.6 20.8 35.2 32 51.2-32-3.2-62.4-8-92.8-14.4 8-28.8 19.2-59.2 32-89.6 9.6 19.2 19.2 36.8 28.8 52.8zm-60.8-240c28.8-6.4 59.2-11.2 91.2-16-11.2 16-20.8 33.6-30.4 51.2-9.6 17.6-19.2 33.6-28.8 52.8-12.8-30.4-22.4-59.2-32-88zM328 512c12.8-27.2 27.2-54.4 43.2-81.6s32-52.8 48-78.4c30.4-1.6 60.8-3.2 91.2-3.2s62.4 1.6 91.2 3.2c17.6 25.6 33.6 51.2 48 76.8s30.4 52.8 43.2 81.6c-12.8 27.2-27.2 54.4-43.2 81.6-16 27.2-32 52.8-48 78.4-30.4 1.6-60.8 3.2-92.8 3.2s-62.4-1.6-91.2-3.2C400 644.8 384 619.2 368 592s-25.6-52.8-40-80zm361.6 102.4l28.8-52.8c12.8 28.8 24 59.2 33.6 88-30.4 6.4-62.4 12.8-94.4 16 11.2-16 22.4-33.6 32-51.2zm28.8-153.6L689.6 408c-9.6-17.6-20.8-33.6-30.4-49.6 32 4.8 62.4 9.6 91.2 16-8 30.4-19.2 59.2-32 86.4zM512 236.8c20.8 22.4 40 46.4 59.2 72-40-1.6-80-1.6-118.4 0 19.2-27.2 40-51.2 59.2-72zM280 113.6c33.6-19.2 108.8 8 187.2 78.4 4.8 4.8 9.6 9.6 16 14.4C452.8 240 424 275.2 396.8 312c-44.8 4.8-89.6 11.2-134.4 20.8-3.2-9.6-4.8-20.8-6.4-30.4-19.2-97.6-6.4-169.6 24-188.8zm-48 528c-8-3.2-16-4.8-25.6-8-43.2-12.8-91.2-35.2-126.4-62.4C59.2 556.8 46.4 536 41.6 512c0-36.8 64-83.2 155.2-115.2 11.2-4.8 22.4-8 35.2-11.2 14.4 43.2 30.4 86.4 49.6 128-19.2 40-36.8 83.2-49.6 128zm232 195.2c-33.6 30.4-72 54.4-113.6 70.4-22.4 11.2-48 11.2-70.4 3.2-32-19.2-44.8-89.6-27.2-184 1.6-11.2 4.8-22.4 8-33.6 44.8 9.6 89.6 16 136 19.2 25.6 36.8 56 73.6 86.4 107.2-6.4 6.4-12.8 12.8-19.2 17.6zm49.6-48c-20.8-22.4-40-46.4-60.8-72 19.2 0 38.4 1.6 59.2 1.6 20.8 0 41.6 0 60.8-1.6-19.2 24-38.4 48-59.2 72zM774.4 848c-1.6 24-14.4 48-33.6 62.4-32 19.2-99.2-4.8-172.8-68.8-8-8-16-14.4-25.6-22.4 30.4-33.6 59.2-68.8 84.8-107.2 46.4-3.2 91.2-11.2 136-20.8l4.8 24c11.2 43.2 12.8 89.6 6.4 132.8zm36.8-214.4c-4.8 1.6-11.2 3.2-17.6 4.8-14.4-43.2-32-86.4-51.2-128 19.2-40 35.2-83.2 49.6-126.4 11.2 3.2 20.8 6.4 30.4 9.6 92.8 32 158.4 80 158.4 116.8 0 40-68.8 89.6-169.6 123.2zM512 603.2c51.2 0 91.2-41.6 91.2-91.2s-41.6-91.2-91.2-91.2-91.2 41.6-91.2 91.2 40 91.2 91.2 91.2z" }) });
};
var ReactIcon_default = ReactIcon;

// node_modules/lingo3d/lib/editor/Toolbar/icons/VueIcon.js
preventTreeShake(v);
var VueIcon = () => {
  return e2("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 1024 1024", children: e2("path", { fill: "#fff", d: "M777.8 128.6H624L512 305.8l-96-177.2H64L512 896l448-767.4H777.8zm-602.4 64H283L512 589l228.8-396.4h107.6L512 769 175.4 192.6z" }) });
};
var VueIcon_default = VueIcon;

// node_modules/lingo3d/lib/editor/Toolbar/saveTextFile.js
var saveTextFile_default = (filename, data) => {
  const blob = new Blob([data], { type: "text/plain" });
  downloadBlob_default(filename, blob);
};

// node_modules/lingo3d/lib/editor/Toolbar/serializeReact.js
var serializeReact = (nodes) => {
  let result = "";
  for (const node of nodes) {
    const componentName = (0, import_lodash.upperFirst)(node.type);
    let props = "";
    for (const [key, value] of Object.entries(node)) {
      if (key === "children" || key === "type" || !value)
        continue;
      if (typeof value === "string")
        props += ` ${key}="${value}"`;
      else if (value === true)
        props += ` ${key}`;
      else if (typeof value === "object")
        props += ` ${key}={${JSON.stringify(value)}}`;
      else
        props += ` ${key}={${value}}`;
    }
    result += "children" in node && node.children ? `<${componentName}${props}>${serializeReact(node.children)}</${componentName}>` : `<${componentName}${props} />`;
  }
  return result;
};
var serializeReact_default = async () => {
  const prettier = (await import("./standalone-H3LAD43A.js")).default;
  const parser = (await import("./parser-babel-KCFS3UBD.js")).default;
  const code = prettier.format(`
        const App = () => {
            return (
                <World>
                    ${serializeReact(serialize_default())}
                </World>
            )
        }
    `, { parser: "babel", plugins: [parser] });
  saveTextFile_default("App.jsx", code);
};

// node_modules/lingo3d/lib/editor/Toolbar/serializeVue.js
var serializeVue = (nodes) => {
  let result = "";
  for (const node of nodes) {
    const componentName = (0, import_lodash.upperFirst)(node.type);
    let props = "";
    for (let [key, value] of Object.entries(node)) {
      if (key === "children" || key === "type" || !value)
        continue;
      key = (0, import_lodash.kebabCase)(key);
      if (typeof value === "string")
        props += ` ${key}='${value}'`;
      else if (value === true)
        props += ` ${key}`;
      else if (typeof value === "object")
        props += ` :${key}='${JSON.stringify(value)}'`;
      else
        props += ` :${key}='${value}'`;
    }
    result += "children" in node && node.children ? `<${componentName}${props}>
${serializeVue(node.children)}</${componentName}>
` : `<${componentName}${props} />
`;
  }
  return result;
};
var serializeVue_default = async () => {
  const prettier = (await import("./standalone-H3LAD43A.js")).default;
  const parser = (await import("./parser-html-YIC77IST.js")).default;
  const code = prettier.format(`
        <template>
            <World>
                ${serializeVue(serialize_default())}
            </World>
        </template>
    `, { parser: "vue", plugins: [parser] });
  saveTextFile_default("App.vue", code);
};

// node_modules/lingo3d/lib/editor/Toolbar/index.js
preventTreeShake(v);
var handleSave = async () => {
  const prettier = (await import("./standalone-H3LAD43A.js")).default;
  const parser = (await import("./parser-babel-KCFS3UBD.js")).default;
  const code = prettier.format(JSON.stringify(serialize_default()), { parser: "json", plugins: [parser] });
  saveTextFile_default("scene.json", code);
};
var handleOpen = async () => {
  const blob = await n2({
    extensions: [".json"]
  });
  const text = await blob.text();
  for (const child of appendableRoot)
    child.dispose();
  try {
    deserialize_default(JSON.parse(text));
  } catch {
  }
};
var Toolbar = () => {
  const [mode, setMode] = useTransformControlsMode();
  let [space, setSpace] = useTransformControlsSpace();
  if (mode === "scale")
    space = "local";
  const [target] = useSelectionTarget();
  const isPositioned = target && !(target instanceof SimpleObjectManager_default);
  h2(() => {
    if (isPositioned && mode === "scale")
      setMode("translate");
  }, [isPositioned]);
  _2(() => {
    emitEditorMountChange();
    return () => {
      emitEditorMountChange();
    };
  }, []);
  return e2("div", { className: "lingo3d-ui", style: {
    width: 50,
    height: "100%",
    background: "rgb(40, 41, 46)",
    borderRight: "1px solid rgba(255, 255, 255, 0.05)",
    overflow: "hidden"
  }, children: e2("div", { style: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    opacity: 0.75,
    paddingTop: 12
  }, children: [e2(IconButton_default, { active: mode === "select", onClick: () => setMode("select"), children: e2(CursorIcon_default, {}) }), e2(IconButton_default, { active: mode === "translate", onClick: () => setMode("translate"), children: e2(TranslateIcon_default, {}) }), e2(IconButton_default, { active: mode === "rotate", onClick: () => setMode("rotate"), children: e2(RotateIcon_default, {}) }), e2(IconButton_default, { active: mode === "scale", disabled: isPositioned, onClick: () => setMode("scale"), children: e2(ScaleIcon_default, {}) }), e2(Separator_default, {}), e2(IconButton_default, { active: space === "world", onClick: () => setSpace("world"), disabled: mode === "scale" || mode === "select", children: e2(AbsoluteIcon_default, {}) }), e2(IconButton_default, { active: space === "local", onClick: () => setSpace("local"), disabled: mode === "select", children: e2(RelativeIcon_default, {}) }), e2(Separator_default, {}), e2(IconButton_default, { onClick: handleOpen, children: e2(OpenIcont_default, {}) }), e2(IconButton_default, { onClick: handleSave, children: e2(ExportIcon_default, {}) }), e2(Separator_default, {}), e2(IconButton_default, { onClick: serializeReact_default, children: e2(ReactIcon_default, {}) }), e2(IconButton_default, { onClick: serializeVue_default, children: e2(VueIcon_default, {}) })] }) });
};
preact_custom_element_esm_default(Toolbar, "lingo3d-toolbar");

// node_modules/lingo3d/lib/editor/Library/ObjectIcon.js
preventTreeShake(v);
var draggingItem;
container.addEventListener("dragover", (e5) => e5.preventDefault());
container.addEventListener("dragenter", (e5) => e5.preventDefault());
container.addEventListener("drop", (e5) => {
  if (!draggingItem || !getSelection())
    return;
  const manager = createObject_default(draggingItem);
  const { x: x2, y: y4, z: z3 } = clientToWorld_default(e5, true);
  manager.outerObject3d.position.set(x2, y4, z3);
  emitSelectionTarget(manager);
});
var ObjectIcon = ({ name, iconName = name }) => {
  return e2("div", { onDragStart: () => draggingItem = name, onDragEnd: () => draggingItem = void 0, style: {
    width: "50%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    paddingTop: 20,
    paddingBottom: 20
  }, children: [e2("img", { style: { width: 50, height: 50 }, src: `https://unpkg.com/lingo3d-editor@1.0.2/assets/${iconName}.png` }), e2("div", { style: { marginTop: 6, opacity: 0.75, overflow: "hidden", textOverflow: "ellipsis", maxWidth: "100%" }, children: (0, import_lodash.upperFirst)(name) })] });
};
var ObjectIcon_default = ObjectIcon;

// node_modules/lingo3d/lib/editor/Library/ObjectGroup.js
preventTreeShake(v);
var getIconName = (name) => {
  if (typeof name === "string") {
    if (name.endsWith("Camera"))
      return "camera";
    if (name.endsWith("Light"))
      return "light";
    return name;
  }
  return Object.values(name)[0];
};
var getName = (name) => typeof name === "string" ? name : Object.keys(name)[0];
var ObjectGroup = ({ names }) => {
  const groups = [];
  let latestGroup = [];
  let i4 = 0;
  for (const name of names) {
    if (i4 === 0)
      groups.push(latestGroup = []);
    latestGroup.push(name);
    if (++i4 === 2)
      i4 = 0;
  }
  return e2(d, { children: groups.map(([name0, name1], i5) => e2("div", { style: { display: "flex" }, children: [e2(ObjectIcon_default, { name: getName(name0), iconName: getIconName(name0) }), name1 && e2(ObjectIcon_default, { name: getName(name1), iconName: getIconName(name1) })] }, i5)) });
};
var ObjectGroup_default = ObjectGroup;

// node_modules/lingo3d/lib/editor/Library/index.js
preventTreeShake(v);
var Library = () => {
  _2(() => {
    emitEditorMountChange();
    return () => {
      emitEditorMountChange();
    };
  }, []);
  return e2("div", { className: "lingo3d-ui", style: {
    width: 200,
    height: "100%",
    background: "rgb(40, 41, 46)",
    padding: 10
  }, children: e2(ObjectGroup_default, { names: [
    "model",
    "dummy",
    "svgMesh",
    { "sprite": "plane" },
    "trigger",
    "audio",
    "reflector",
    "cube",
    "sphere",
    "cone",
    "cylinder",
    "octahedron",
    "tetrahedron",
    "torus",
    "plane",
    "circle",
    "areaLight",
    "ambientLight",
    "skyLight",
    "directionalLight",
    "pointLight",
    "spotLight",
    "camera",
    "thirdPersonCamera",
    "firstPersonCamera",
    "orbitCamera"
  ] }) });
};
preact_custom_element_esm_default(Library, "lingo3d-library");

// node_modules/lingo3d/lib/editor/HUD/HotKeys.js
preventTreeShake(v);
var HotKeys_default = ({ hotkey, hotkeyFunction }) => {
  return e2("div", { style: {
    display: "flex",
    alignItems: "center",
    fontSize: "11px",
    lineHeight: "1.3",
    marginTop: "4px",
    minWidth: "150px"
  }, children: [e2("div", { style: {
    width: "20px",
    border: "1px solid white",
    borderRadius: "4px",
    padding: "2px 4px 2px 4px",
    display: "flex",
    justifyContent: "center"
  }, children: hotkey }), e2("div", { style: { padding: "0 1px 0 1px" }, children: "\xA0-\xA0" }), e2("div", { style: { padding: "2px 0px 2px 0px" }, children: hotkeyFunction })] });
};

// node_modules/lingo3d/lib/editor/HUD/index.js
preventTreeShake(v);
var HUD = () => {
  const [editorActive] = useEditorActive();
  if (!editorActive)
    return null;
  return e2("div", { className: "lingo3d-ui", style: {
    width: 0,
    zIndex: 1,
    position: "relative",
    left: 15,
    top: 10,
    overflow: "visible",
    opacity: 0.5,
    pointerEvents: "none"
  }, children: [e2(HotKeys_default, { hotkey: "W", hotkeyFunction: "move forward" }), e2(HotKeys_default, { hotkey: "S", hotkeyFunction: "move backwards" }), e2(HotKeys_default, { hotkey: "A", hotkeyFunction: "move left" }), e2(HotKeys_default, { hotkey: "D", hotkeyFunction: "move right" }), e2(HotKeys_default, { hotkey: "\u2191", hotkeyFunction: "move up" }), e2(HotKeys_default, { hotkey: "\u2193", hotkeyFunction: "move down" }), e2(HotKeys_default, { hotkey: "C", hotkeyFunction: "center selected" })] });
};
preact_custom_element_esm_default(HUD, "lingo3d-hud");

// node_modules/lingo3d/lib/editor/index.js
var style2 = createElement_default(`
    <style>
        .lingo3d-ui * {
            user-select: none;
            -webkit-user-select: none;
            position: relative;
            box-sizing: border-box;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji" !important;
        }
        .lingo3d-ui {
            position: relative;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: scroll;
            float: left;
            color: white;
            font-size: 11px;
        }
        .lingo3d-ui::-webkit-scrollbar {
            display: none;
        }
        .tp-lblv_l {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
`);
document.head.appendChild(style2);

// node_modules/lingo3d-react/lib/components/editor/LingoEditor.js
var LingoEditor = () => {
  return import_react3.default.createElement(import_react3.default.Fragment, null, import_react3.default.createElement("lingo3d-toolbar", null), import_react3.default.createElement("lingo3d-scenegraph", null), import_react3.default.createElement("lingo3d-editor", null), import_react3.default.createElement("lingo3d-library", null), import_react3.default.createElement("lingo3d-hud", null));
};
var LingoEditor_default = LingoEditor;

// node_modules/lingo3d-react/lib/components/editor/Editor.js
var import_react4 = __toESM(require_react());
var Editor2 = ({ keyboard: keyboard2, mouse }) => {
  return import_react4.default.createElement("lingo3d-editor", { keyboard: keyboard2, mouse });
};
var Editor_default = Editor2;

// node_modules/lingo3d-react/lib/components/editor/SceneGraph.js
var import_react5 = __toESM(require_react());
var SceneGraph2 = () => {
  return import_react5.default.createElement("lingo3d-scenegraph", null);
};
var SceneGraph_default = SceneGraph2;

// node_modules/lingo3d-react/lib/components/editor/Toolbar.js
var import_react6 = __toESM(require_react());
var Toolbar2 = () => {
  return import_react6.default.createElement("lingo3d-toolbar", null);
};
var Toolbar_default = Toolbar2;

// node_modules/lingo3d-react/lib/components/editor/Library.js
var import_react7 = __toESM(require_react());
var Library2 = () => {
  return import_react7.default.createElement("lingo3d-library", null);
};
var Library_default = Library2;

// node_modules/lingo3d-react/lib/components/Stats.js
var import_react8 = __toESM(require_react());
var import_stats = __toESM(require_stats_min());
var Stats = ({ mode = "fps" }) => {
  const divRef = (0, import_react8.useRef)(null);
  (0, import_react8.useLayoutEffect)(() => {
    const div = divRef.current;
    if (!div)
      return;
    const stats = new import_stats.default();
    stats.showPanel(mode === "fps" ? 0 : mode === "time" ? 1 : 2);
    div.appendChild(stats.dom);
    const beforeHandle = onBeforeRender(() => stats.begin());
    const afterHandle = onAfterRender(() => stats.end());
    return () => {
      beforeHandle.cancel();
      afterHandle.cancel();
    };
  }, []);
  return import_react8.default.createElement("div", { ref: divRef });
};
var Stats_default = Stats;

// node_modules/lingo3d-react/lib/components/api/Keyboard.js
var import_react27 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useManager.js
var import_react26 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useDiffProps.js
var import_react9 = __toESM(require_react());
var useDiffProps_default = (props, paused) => {
  const propsOldRef = (0, import_react9.useRef)({});
  const changes = [];
  const removed = [];
  if (paused)
    return [changes, removed];
  const propsOld = propsOldRef.current;
  for (const [key, value] of Object.entries(props)) {
    if (key === "children")
      continue;
    const valueOld = propsOld[key];
    if (valueOld === value)
      continue;
    if (value && typeof value === "object") {
      if (JSON.stringify(value) !== JSON.stringify(valueOld))
        changes.push([key, value]);
    } else
      changes.push([key, value]);
  }
  for (const key of Object.keys(propsOld))
    !(key in props) && removed.push(key);
  propsOldRef.current = props;
  return [changes, removed];
};

// node_modules/@lincode/hooks/lib/useTruthy.js
var import_react10 = __toESM(require_react());
var useTruthy_default = (value, condition) => {
  const ref = (0, import_react10.useRef)();
  if (condition === void 0)
    value && (ref.current = value);
  else
    condition && (ref.current = value);
  return ref.current;
};

// node_modules/@lincode/hooks/lib/useWindowSize.js
var import_react11 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useFileDrop.js
var import_react12 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useTimeout.js
var import_react13 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useCurrentRef.js
var import_react14 = __toESM(require_react());
var useCurrentRef_default = (value) => {
  const ref = (0, import_react14.useRef)(value);
  ref.current = value;
  return ref;
};

// node_modules/@lincode/hooks/lib/useMemoOnce.js
var import_react15 = __toESM(require_react());
var import_react16 = __toESM(require_react());
var log2 = console.log;
var cache4 = [];
var clear = () => cache4 = [];
var react18 = parseFloat(import_react16.default.version) > 17;
var tracked = /* @__PURE__ */ new WeakSet();
var strictMode = false;
var useMemoOnce_default = (factory, cleanup, strictCleanUp) => {
  if (react18) {
    const value = (0, import_react15.useMemo)(factory, []);
    const [tracker] = (0, import_react15.useState)(() => {
      const tracker2 = {};
      queueMicrotask(() => {
        if (tracked.has(tracker2))
          return;
        strictMode = true;
        cleanup === null || cleanup === void 0 ? void 0 : cleanup(value);
      });
      return tracker2;
    });
    (0, import_react15.useLayoutEffect)(() => {
      if (tracked.has(tracker))
        return () => {
          cleanup === null || cleanup === void 0 ? void 0 : cleanup(value);
          strictCleanUp === null || strictCleanUp === void 0 ? void 0 : strictCleanUp(value);
        };
      tracked.add(tracker);
      return () => {
        queueMicrotask(() => {
          if (strictMode)
            return;
          cleanup === null || cleanup === void 0 ? void 0 : cleanup(value);
          strictCleanUp === null || strictCleanUp === void 0 ? void 0 : strictCleanUp(value);
        });
      };
    }, []);
    return value;
  }
  const [result] = (0, import_react15.useState)(() => {
    if (log2 === console.log) {
      queueMicrotask(clear);
      const result2 = factory();
      cache4.push(result2);
      return result2;
    }
    return cache4.shift();
  });
  (0, import_react15.useLayoutEffect)(() => {
    return () => {
      cleanup === null || cleanup === void 0 ? void 0 : cleanup(result);
      strictCleanUp === null || strictCleanUp === void 0 ? void 0 : strictCleanUp(result);
    };
  }, []);
  return result;
};

// node_modules/@lincode/hooks/lib/useDebounce.js
var import_react17 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useDebounceEffect.js
var import_react18 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/usePrevious.js
var import_react19 = __toESM(require_react());
var usePrevious_default = (value) => {
  const ref = (0, import_react19.useRef)();
  (0, import_react19.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};

// node_modules/@lincode/hooks/lib/useResizeObserver.js
var import_react20 = __toESM(require_react());

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
        var entry = _a2[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
    var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
    var key = _a2[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y4,
    width,
    height,
    top: y4,
    right: x2 + width,
    bottom: height + y4,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y4, width, height) {
  return { x: x2, y: y4, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method].apply(_a2, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();

// node_modules/@lincode/hooks/lib/useVisibilityObserver.js
var import_react21 = __toESM(require_react());

// node_modules/intersection-observer/intersection-observer.js
(function() {
  "use strict";
  if (typeof window !== "object") {
    return;
  }
  if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return;
  }
  function getFrameElement(doc) {
    try {
      return doc.defaultView && doc.defaultView.frameElement || null;
    } catch (e5) {
      return null;
    }
  }
  var document2 = function(startDoc) {
    var doc = startDoc;
    var frame2 = getFrameElement(doc);
    while (frame2) {
      doc = frame2.ownerDocument;
      frame2 = getFrameElement(doc);
    }
    return doc;
  }(window.document);
  var registry2 = [];
  var crossOriginUpdater = null;
  var crossOriginRect = null;
  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = ensureDOMRect(entry.rootBounds);
    this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
    this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
    this.isIntersecting = !!entry.intersectionRect;
    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height;
    if (targetArea) {
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  function IntersectionObserver2(callback, opt_options) {
    var options = opt_options || {};
    if (typeof callback != "function") {
      throw new Error("callback must be a function");
    }
    if (options.root && options.root.nodeType != 1 && options.root.nodeType != 9) {
      throw new Error("root must be a Document or Element");
    }
    this._checkForIntersections = throttle2(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin);
    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function(margin) {
      return margin.value + margin.unit;
    }).join(" ");
    this._monitoringDocuments = [];
    this._monitoringUnsubscribes = [];
  }
  IntersectionObserver2.prototype.THROTTLE_TIMEOUT = 100;
  IntersectionObserver2.prototype.POLL_INTERVAL = null;
  IntersectionObserver2.prototype.USE_MUTATION_OBSERVER = true;
  IntersectionObserver2._setupCrossOriginUpdater = function() {
    if (!crossOriginUpdater) {
      crossOriginUpdater = function(boundingClientRect, intersectionRect) {
        if (!boundingClientRect || !intersectionRect) {
          crossOriginRect = getEmptyRect();
        } else {
          crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
        }
        registry2.forEach(function(observer) {
          observer._checkForIntersections();
        });
      };
    }
    return crossOriginUpdater;
  };
  IntersectionObserver2._resetCrossOriginUpdater = function() {
    crossOriginUpdater = null;
    crossOriginRect = null;
  };
  IntersectionObserver2.prototype.observe = function(target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
      return item.element == target;
    });
    if (isTargetAlreadyObserved) {
      return;
    }
    if (!(target && target.nodeType == 1)) {
      throw new Error("target must be an Element");
    }
    this._registerInstance();
    this._observationTargets.push({ element: target, entry: null });
    this._monitorIntersections(target.ownerDocument);
    this._checkForIntersections();
  };
  IntersectionObserver2.prototype.unobserve = function(target) {
    this._observationTargets = this._observationTargets.filter(function(item) {
      return item.element != target;
    });
    this._unmonitorIntersections(target.ownerDocument);
    if (this._observationTargets.length == 0) {
      this._unregisterInstance();
    }
  };
  IntersectionObserver2.prototype.disconnect = function() {
    this._observationTargets = [];
    this._unmonitorAllIntersections();
    this._unregisterInstance();
  };
  IntersectionObserver2.prototype.takeRecords = function() {
    var records = this._queuedEntries.slice();
    this._queuedEntries = [];
    return records;
  };
  IntersectionObserver2.prototype._initThresholds = function(opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold))
      threshold = [threshold];
    return threshold.sort().filter(function(t5, i4, a5) {
      if (typeof t5 != "number" || isNaN(t5) || t5 < 0 || t5 > 1) {
        throw new Error("threshold must be a number between 0 and 1 inclusively");
      }
      return t5 !== a5[i4 - 1];
    });
  };
  IntersectionObserver2.prototype._parseRootMargin = function(opt_rootMargin) {
    var marginString = opt_rootMargin || "0px";
    var margins = marginString.split(/\s+/).map(function(margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
      if (!parts) {
        throw new Error("rootMargin must be specified in pixels or percent");
      }
      return { value: parseFloat(parts[1]), unit: parts[2] };
    });
    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
    return margins;
  };
  IntersectionObserver2.prototype._monitorIntersections = function(doc) {
    var win = doc.defaultView;
    if (!win) {
      return;
    }
    if (this._monitoringDocuments.indexOf(doc) != -1) {
      return;
    }
    var callback = this._checkForIntersections;
    var monitoringInterval = null;
    var domObserver = null;
    if (this.POLL_INTERVAL) {
      monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
    } else {
      addEvent(win, "resize", callback, true);
      addEvent(doc, "scroll", callback, true);
      if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
        domObserver = new win.MutationObserver(callback);
        domObserver.observe(doc, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
    this._monitoringDocuments.push(doc);
    this._monitoringUnsubscribes.push(function() {
      var win2 = doc.defaultView;
      if (win2) {
        if (monitoringInterval) {
          win2.clearInterval(monitoringInterval);
        }
        removeEvent(win2, "resize", callback, true);
      }
      removeEvent(doc, "scroll", callback, true);
      if (domObserver) {
        domObserver.disconnect();
      }
    });
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    if (doc != rootDoc) {
      var frame2 = getFrameElement(doc);
      if (frame2) {
        this._monitorIntersections(frame2.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorIntersections = function(doc) {
    var index2 = this._monitoringDocuments.indexOf(doc);
    if (index2 == -1) {
      return;
    }
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    var hasDependentTargets = this._observationTargets.some(function(item) {
      var itemDoc = item.element.ownerDocument;
      if (itemDoc == doc) {
        return true;
      }
      while (itemDoc && itemDoc != rootDoc) {
        var frame3 = getFrameElement(itemDoc);
        itemDoc = frame3 && frame3.ownerDocument;
        if (itemDoc == doc) {
          return true;
        }
      }
      return false;
    });
    if (hasDependentTargets) {
      return;
    }
    var unsubscribe = this._monitoringUnsubscribes[index2];
    this._monitoringDocuments.splice(index2, 1);
    this._monitoringUnsubscribes.splice(index2, 1);
    unsubscribe();
    if (doc != rootDoc) {
      var frame2 = getFrameElement(doc);
      if (frame2) {
        this._unmonitorIntersections(frame2.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorAllIntersections = function() {
    var unsubscribes = this._monitoringUnsubscribes.slice(0);
    this._monitoringDocuments.length = 0;
    this._monitoringUnsubscribes.length = 0;
    for (var i4 = 0; i4 < unsubscribes.length; i4++) {
      unsubscribes[i4]();
    }
  };
  IntersectionObserver2.prototype._checkForIntersections = function() {
    if (!this.root && crossOriginUpdater && !crossOriginRect) {
      return;
    }
    var rootIsInDom = this._rootIsInDom();
    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
    this._observationTargets.forEach(function(item) {
      var target = item.element;
      var targetRect = getBoundingClientRect(target);
      var rootContainsTarget = this._rootContainsTarget(target);
      var oldEntry = item.entry;
      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
      var rootBounds = null;
      if (!this._rootContainsTarget(target)) {
        rootBounds = getEmptyRect();
      } else if (!crossOriginUpdater || this.root) {
        rootBounds = rootRect;
      }
      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target,
        boundingClientRect: targetRect,
        rootBounds,
        intersectionRect
      });
      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);
    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  IntersectionObserver2.prototype._computeTargetAndRootIntersection = function(target, targetRect, rootRect) {
    if (window.getComputedStyle(target).display == "none")
      return;
    var intersectionRect = targetRect;
    var parent = getParentNode(target);
    var atRoot = false;
    while (!atRoot && parent) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
      if (parentComputedStyle.display == "none")
        return null;
      if (parent == this.root || parent.nodeType == 9) {
        atRoot = true;
        if (parent == this.root || parent == document2) {
          if (crossOriginUpdater && !this.root) {
            if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
              parent = null;
              parentRect = null;
              intersectionRect = null;
            } else {
              parentRect = crossOriginRect;
            }
          } else {
            parentRect = rootRect;
          }
        } else {
          var frame2 = getParentNode(parent);
          var frameRect = frame2 && getBoundingClientRect(frame2);
          var frameIntersect = frame2 && this._computeTargetAndRootIntersection(frame2, frameRect, rootRect);
          if (frameRect && frameIntersect) {
            parent = frame2;
            parentRect = convertFromParentRect(frameRect, frameIntersect);
          } else {
            parent = null;
            intersectionRect = null;
          }
        }
      } else {
        var doc = parent.ownerDocument;
        if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != "visible") {
          parentRect = getBoundingClientRect(parent);
        }
      }
      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
      }
      if (!intersectionRect)
        break;
      parent = parent && getParentNode(parent);
    }
    return intersectionRect;
  };
  IntersectionObserver2.prototype._getRootRect = function() {
    var rootRect;
    if (this.root && !isDoc(this.root)) {
      rootRect = getBoundingClientRect(this.root);
    } else {
      var doc = isDoc(this.root) ? this.root : document2;
      var html = doc.documentElement;
      var body = doc.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html.clientWidth || body.clientWidth,
        width: html.clientWidth || body.clientWidth,
        bottom: html.clientHeight || body.clientHeight,
        height: html.clientHeight || body.clientHeight
      };
    }
    return this._expandRectByRootMargin(rootRect);
  };
  IntersectionObserver2.prototype._expandRectByRootMargin = function(rect) {
    var margins = this._rootMarginValues.map(function(margin, i4) {
      return margin.unit == "px" ? margin.value : margin.value * (i4 % 2 ? rect.width : rect.height) / 100;
    });
    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
    return newRect;
  };
  IntersectionObserver2.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
    if (oldRatio === newRatio)
      return;
    for (var i4 = 0; i4 < this.thresholds.length; i4++) {
      var threshold = this.thresholds[i4];
      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  IntersectionObserver2.prototype._rootIsInDom = function() {
    return !this.root || containsDeep(document2, this.root);
  };
  IntersectionObserver2.prototype._rootContainsTarget = function(target) {
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    return containsDeep(rootDoc, target) && (!this.root || rootDoc == target.ownerDocument);
  };
  IntersectionObserver2.prototype._registerInstance = function() {
    if (registry2.indexOf(this) < 0) {
      registry2.push(this);
    }
  };
  IntersectionObserver2.prototype._unregisterInstance = function() {
    var index2 = registry2.indexOf(this);
    if (index2 != -1)
      registry2.splice(index2, 1);
  };
  function now() {
    return window.performance && performance.now && performance.now();
  }
  function throttle2(fn, timeout) {
    var timer2 = null;
    return function() {
      if (!timer2) {
        timer2 = setTimeout(function() {
          fn();
          timer2 = null;
        }, timeout);
      }
    };
  }
  function addEvent(node, event2, fn, opt_useCapture) {
    if (typeof node.addEventListener == "function") {
      node.addEventListener(event2, fn, opt_useCapture || false);
    } else if (typeof node.attachEvent == "function") {
      node.attachEvent("on" + event2, fn);
    }
  }
  function removeEvent(node, event2, fn, opt_useCapture) {
    if (typeof node.removeEventListener == "function") {
      node.removeEventListener(event2, fn, opt_useCapture || false);
    } else if (typeof node.detachEvent == "function") {
      node.detachEvent("on" + event2, fn);
    }
  }
  function computeRectIntersection(rect1, rect2) {
    var top2 = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top2;
    return width >= 0 && height >= 0 && {
      top: top2,
      bottom,
      left,
      right,
      width,
      height
    } || null;
  }
  function getBoundingClientRect(el) {
    var rect;
    try {
      rect = el.getBoundingClientRect();
    } catch (err) {
    }
    if (!rect)
      return getEmptyRect();
    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }
    return rect;
  }
  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  function ensureDOMRect(rect) {
    if (!rect || "x" in rect) {
      return rect;
    }
    return {
      top: rect.top,
      y: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
    var top2 = parentIntersectionRect.top - parentBoundingRect.top;
    var left = parentIntersectionRect.left - parentBoundingRect.left;
    return {
      top: top2,
      left,
      height: parentIntersectionRect.height,
      width: parentIntersectionRect.width,
      bottom: top2 + parentIntersectionRect.height,
      right: left + parentIntersectionRect.width
    };
  }
  function containsDeep(parent, child) {
    var node = child;
    while (node) {
      if (node == parent)
        return true;
      node = getParentNode(node);
    }
    return false;
  }
  function getParentNode(node) {
    var parent = node.parentNode;
    if (node.nodeType == 9 && node != document2) {
      return getFrameElement(node);
    }
    if (parent && parent.assignedSlot) {
      parent = parent.assignedSlot.parentNode;
    }
    if (parent && parent.nodeType == 11 && parent.host) {
      return parent.host;
    }
    return parent;
  }
  function isDoc(node) {
    return node && node.nodeType === 9;
  }
  window.IntersectionObserver = IntersectionObserver2;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

// node_modules/@lincode/hooks/lib/useClickOutside.js
var import_react22 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useClick.js
var import_react23 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useScroll.js
var import_react24 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useAspectRatio.js
var import_react25 = __toESM(require_react());

// node_modules/lingo3d-react/lib/Props/utils/processDefaults.js
var cache5 = /* @__PURE__ */ new WeakMap();
var processed = /* @__PURE__ */ new WeakSet();
var processDefaults_default = (defaults) => {
  if (processed.has(defaults))
    return defaults;
  return forceGet(cache5, defaults, () => {
    const result = Object.fromEntries(Object.entries(defaults).map(([key, value]) => [
      key,
      Array.isArray(value) ? value[0] : value
    ]));
    processed.add(result);
    return result;
  });
};

// node_modules/lingo3d-react/lib/hooks/useManager.js
var ParentContext = import_react26.default.createContext(void 0);
var handleStore = /* @__PURE__ */ new WeakMap();
var makeHandleMap = () => /* @__PURE__ */ new Map();
var applyChanges = (manager, changed, removed) => {
  var _a2, _b;
  const handleMap = forceGet(handleStore, manager, makeHandleMap);
  for (const [key, value] of changed) {
    (_a2 = handleMap.get(key)) === null || _a2 === void 0 ? void 0 : _a2.cancel();
    if (value instanceof Reactive) {
      handleMap.set(key, value.get((v4) => manager[key] = v4));
      continue;
    }
    manager[key] = value;
  }
  if (!removed.length)
    return;
  const defaults = processDefaults_default(manager.constructor.defaults);
  for (const key of removed) {
    (_b = handleMap.get(key)) === null || _b === void 0 ? void 0 : _b.cancel();
    manager[key] = defaults[key];
  }
};
var appendedSet = /* @__PURE__ */ new WeakSet();
var useManager_default = (p3, ref, ManagerClass) => {
  const { children: children2, ...props } = p3;
  const parent = (0, import_react26.useContext)(ParentContext);
  const manager = useMemoOnce_default(() => {
    const manager2 = new ManagerClass();
    if (parent) {
      parent.append(manager2);
      appendedSet.add(manager2);
    }
    return manager2;
  }, (manager2) => {
    const handleMap = handleStore.get(manager2);
    if (handleMap)
      for (const handle of handleMap.values())
        handle.cancel();
    manager2.dispose();
  });
  (0, import_react26.useLayoutEffect)(() => {
    if (!parent || appendedSet.has(manager))
      return;
    parent.append(manager);
    appendedSet.add(manager);
  }, [parent]);
  const [changed, removed] = useDiffProps_default(props);
  applyChanges(manager, changed, removed);
  (0, import_react26.useLayoutEffect)(() => {
    if (!ref)
      return;
    if (typeof ref === "function")
      ref(manager);
    else
      ref.current = manager;
  }, [ref]);
  return manager;
};

// node_modules/lingo3d-react/lib/components/api/Keyboard.js
var Keyboard2 = import_react27.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Keyboard);
  return import_react27.default.createElement(ParentContext.Provider, { value: manager });
});
var Keyboard_default = Keyboard2;

// node_modules/lingo3d-react/lib/components/api/Mouse.js
var import_react28 = __toESM(require_react());
var Mouse2 = import_react28.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Mouse);
  return import_react28.default.createElement(ParentContext.Provider, { value: manager });
});
var Mouse_default = Mouse2;

// node_modules/lingo3d-react/lib/components/display/Group.js
var import_react29 = __toESM(require_react());
var Group3 = import_react29.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Group2);
  return import_react29.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Group_default = Group3;

// node_modules/lingo3d-react/lib/components/display/Model.js
var import_react30 = __toESM(require_react());
var Model2 = import_react30.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Model);
  return import_react30.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Model_default = Model2;

// node_modules/lingo3d-react/lib/components/display/Dummy.js
var import_react31 = __toESM(require_react());
var Dummy2 = import_react31.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Dummy);
  return import_react31.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Dummy_default = Dummy2;

// node_modules/lingo3d-react/lib/components/display/SvgMesh.js
var import_react32 = __toESM(require_react());
var SvgMesh2 = import_react32.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, SvgMesh_default);
  return import_react32.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var SvgMesh_default2 = SvgMesh2;

// node_modules/lingo3d-react/lib/components/display/Reflector.js
var import_react33 = __toESM(require_react());
var Reflector2 = import_react33.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Reflector);
  return import_react33.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Reflector_default = Reflector2;

// node_modules/lingo3d-react/lib/components/display/Skybox.js
var import_react34 = __toESM(require_react());
var Skybox2 = import_react34.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Skybox);
  return import_react34.default.createElement(ParentContext.Provider, { value: manager });
});
var Skybox_default = Skybox2;

// node_modules/lingo3d-react/lib/components/display/Environment.js
var import_react35 = __toESM(require_react());
var Environment2 = import_react35.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Environment);
  return import_react35.default.createElement(ParentContext.Provider, { value: manager });
});
var Environment_default = Environment2;

// node_modules/lingo3d-react/lib/components/display/Sprite.js
var import_react36 = __toESM(require_react());
var Sprite3 = import_react36.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Sprite_default);
  return import_react36.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Sprite_default2 = Sprite3;

// node_modules/lingo3d-react/lib/components/display/Trigger.js
var import_react37 = __toESM(require_react());
var Trigger2 = import_react37.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Trigger);
  return import_react37.default.createElement(ParentContext.Provider, { value: manager });
});
var Trigger_default = Trigger2;

// node_modules/lingo3d-react/lib/components/display/Audio.js
var import_react38 = __toESM(require_react());
var Audio2 = import_react38.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Audio);
  return import_react38.default.createElement(ParentContext.Provider, { value: manager });
});
var Audio_default = Audio2;

// node_modules/lingo3d-react/lib/components/display/cameras/Camera.js
var import_react39 = __toESM(require_react());
var Camera2 = import_react39.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Camera);
  return import_react39.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Camera_default = Camera2;

// node_modules/lingo3d-react/lib/components/display/cameras/OrbitCamera.js
var import_react40 = __toESM(require_react());
var OrbitCamera2 = import_react40.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, OrbitCamera);
  return import_react40.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var OrbitCamera_default = OrbitCamera2;

// node_modules/lingo3d-react/lib/components/display/cameras/ThirdPersonCamera.js
var import_react41 = __toESM(require_react());
var ThirdPersonCamera2 = import_react41.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, ThirdPersonCamera);
  return import_react41.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var ThirdPersonCamera_default = ThirdPersonCamera2;

// node_modules/lingo3d-react/lib/components/display/cameras/FirstPersonCamera.js
var import_react42 = __toESM(require_react());
var FirstPersonCamera2 = import_react42.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, FirstPersonCamera);
  return import_react42.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var FirstPersonCamera_default = FirstPersonCamera2;

// node_modules/lingo3d-react/lib/components/display/lights/AmbientLight.js
var import_react43 = __toESM(require_react());
var AmbientLight3 = import_react43.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, AmbientLight2);
  return import_react43.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var AmbientLight_default = AmbientLight3;

// node_modules/lingo3d-react/lib/components/display/lights/AreaLight.js
var import_react44 = __toESM(require_react());
var AreaLight2 = import_react44.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, AreaLight);
  return import_react44.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var AreaLight_default = AreaLight2;

// node_modules/lingo3d-react/lib/components/display/lights/DirectionalLight.js
var import_react45 = __toESM(require_react());
var DirectionalLight3 = import_react45.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, DirectionalLight2);
  return import_react45.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var DirectionalLight_default = DirectionalLight3;

// node_modules/lingo3d-react/lib/components/display/lights/PointLight.js
var import_react46 = __toESM(require_react());
var PointLight3 = import_react46.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, PointLight_default);
  return import_react46.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var PointLight_default2 = PointLight3;

// node_modules/lingo3d-react/lib/components/display/lights/SkyLight.js
var import_react47 = __toESM(require_react());
var SkyLight = import_react47.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Skylight);
  return import_react47.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var SkyLight_default = SkyLight;

// node_modules/lingo3d-react/lib/components/display/lights/SpotLight.js
var import_react48 = __toESM(require_react());
var SpotLight3 = import_react48.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, SpotLight_default);
  return import_react48.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var SpotLight_default2 = SpotLight3;

// node_modules/lingo3d-react/lib/components/display/primitives/Circle.js
var import_react49 = __toESM(require_react());
var Circle2 = import_react49.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Circle);
  return import_react49.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Circle_default = Circle2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cone.js
var import_react50 = __toESM(require_react());
var Cone2 = import_react50.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Cone);
  return import_react50.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Cone_default = Cone2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cube.js
var import_react51 = __toESM(require_react());
var Cube2 = import_react51.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Cube);
  return import_react51.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Cube_default = Cube2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cylinder.js
var import_react52 = __toESM(require_react());
var Cylinder2 = import_react52.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Cylinder);
  return import_react52.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Cylinder_default = Cylinder2;

// node_modules/lingo3d-react/lib/components/display/primitives/Octahedron.js
var import_react53 = __toESM(require_react());
var Octahedron2 = import_react53.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Octahedron);
  return import_react53.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Octahedron_default = Octahedron2;

// node_modules/lingo3d-react/lib/components/display/primitives/Plane.js
var import_react54 = __toESM(require_react());
var Plane2 = import_react54.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Plane);
  return import_react54.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Plane_default = Plane2;

// node_modules/lingo3d-react/lib/components/display/primitives/Sphere.js
var import_react55 = __toESM(require_react());
var Sphere2 = import_react55.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Sphere);
  return import_react55.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Sphere_default = Sphere2;

// node_modules/lingo3d-react/lib/components/display/primitives/Tetrahedron.js
var import_react56 = __toESM(require_react());
var Tetrahedron2 = import_react56.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Tetrahedron);
  return import_react56.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Tetrahedron_default = Tetrahedron2;

// node_modules/lingo3d-react/lib/components/display/primitives/Torus.js
var import_react57 = __toESM(require_react());
var Torus2 = import_react57.default.forwardRef((p3, ref) => {
  const manager = useManager_default(p3, ref, Torus);
  return import_react57.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Torus_default = Torus2;

// node_modules/lingo3d-react/lib/components/logical/HTML/index.js
var import_react58 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var HTML = ({ children: children2 }) => {
  const parent = (0, import_react58.useContext)(ParentContext);
  const divRef = (0, import_react58.useRef)(null);
  (0, import_react58.useLayoutEffect)(() => {
    const div = divRef.current;
    if (!div || !parent)
      return;
    let frustumVisibleOld = false;
    const handle = onAfterRender(() => {
      const { frustumVisible } = parent;
      if (frustumVisible !== frustumVisibleOld)
        div.style.display = frustumVisible ? "block" : "none";
      frustumVisibleOld = frustumVisible;
      if (!frustumVisible)
        return;
      div.style.transform = `translateX(${parent.clientX}px) translateY(${parent.clientY}px)`;
    });
    return () => {
      handle.cancel();
    };
  }, [parent]);
  return import_react_dom.default.createPortal(import_react58.default.createElement("div", { ref: divRef, style: { display: "none" } }, children2), htmlContainer_default);
};
var HTML_default = HTML;

// node_modules/lingo3d-react/lib/components/logical/UI.js
var import_react59 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
var UI = ({ children: children2 }) => {
  return import_react_dom2.default.createPortal(import_react59.default.createElement("div", { style: { pointerEvents: "all", position: "static" } }, children2), htmlContainer_default);
};
var UI_default = UI;

// node_modules/lingo3d-react/lib/components/logical/Find.js
var import_react60 = __toESM(require_react());
var Find = import_react60.default.forwardRef(({ name, onLoad, ...p3 }, ref) => {
  const parent = (0, import_react60.useContext)(ParentContext);
  const [manager, setManager] = (0, import_react60.useState)();
  (0, import_react60.useLayoutEffect)(() => {
    if (!parent || !name)
      return;
    if ("loaded" in parent) {
      const handle = parent.loaded.then(() => {
        setManager(parent.find(name));
      });
      return () => {
        handle.cancel();
      };
    }
    setManager(parent.find(name));
  }, [parent, name]);
  const [changed, removed] = useDiffProps_default(p3, !manager);
  manager && applyChanges(manager, changed, removed);
  (0, import_react60.useLayoutEffect)(() => {
    if (!ref || !manager)
      return;
    if (typeof ref === "function")
      ref(manager);
    else
      ref.current = manager;
  }, [ref, manager]);
  (0, import_react60.useLayoutEffect)(() => {
    manager && (onLoad === null || onLoad === void 0 ? void 0 : onLoad());
  }, [manager]);
  return import_react60.default.createElement(ParentContext.Provider, { value: manager }, p3.children);
});
var Find_default = Find;

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/lingo3d-react/lib/hooks/useSpawn.js
var import_react61 = __toESM(require_react());
var useSpawn_default = (o4) => {
  const doneRef = (0, import_react61.useRef)(false);
  const optionSet = useMemoOnce_default(() => /* @__PURE__ */ new Set(), void 0, () => doneRef.current = true);
  const [options, setOptions] = (0, import_react61.useState)([]);
  const spawn2 = (_o) => {
    var _a2;
    if (doneRef.current)
      return;
    const options2 = { ...o4, ..._o };
    (_a2 = options2.id) !== null && _a2 !== void 0 ? _a2 : options2.id = nanoid();
    optionSet.add(options2);
    setOptions([...optionSet]);
    options2.lifetime && setTimeout(() => {
      if (doneRef.current)
        return;
      optionSet.delete(options2);
      setOptions([...optionSet]);
    }, options2.lifetime);
  };
  return [options, spawn2];
};

// node_modules/tslib/tslib.es6.js
function __rest2(s5, e5) {
  var t5 = {};
  for (var p3 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p3) && e5.indexOf(p3) < 0)
      t5[p3] = s5[p3];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s5); i4 < p3.length; i4++) {
      if (e5.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p3[i4]))
        t5[p3[i4]] = s5[p3[i4]];
    }
  return t5;
}

// node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/popmotion/dist/es/utils/clamp.mjs
var clamp = (min, max, v4) => Math.min(Math.max(v4, min), max);

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a5 = exponentialDecay - velocity;
      const b4 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c5 = Math.exp(-delta);
      return safeMin - a5 / b4 * c5;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d4 = delta * velocity + velocity;
      const e5 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f4 = Math.exp(-delta);
      const g3 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d4 - e5) * f4) / g3;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a5 = Math.exp(-undampedFreq2 * duration);
      const b4 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a5 * b4;
    };
    derivative = (undampedFreq2) => {
      const a5 = Math.exp(-undampedFreq2 * duration);
      const b4 = (velocity - undampedFreq2) * (duration * duration);
      return a5 * b4;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i4 = 1; i4 < rootIterations; i4++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a2) {
  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a2, options = __rest2(_a2, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t5) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t5) + initialDelta * Math.cos(angularFreq * t5));
      };
      resolveVelocity = (t5) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t5) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t5)) - envelope * (Math.cos(angularFreq * t5) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t5));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t5) => to - Math.exp(-undampedAngularFreq * t5) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t5);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t5) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
        const freqForT = Math.min(dampedAngularFreq * t5, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t5) => {
      const current = resolveSpring(t5);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t5) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t5 >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from, to] = [to, from];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a5, b4) => typeof a5 === "string" || typeof b4 === "string";
var zero = (_t) => 0;

// node_modules/popmotion/dist/es/utils/progress.mjs
var progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

// node_modules/popmotion/dist/es/utils/mix.mjs
var mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;

// node_modules/style-value-types/dist/es/utils.mjs
var clamp2 = (min, max) => (v4) => Math.max(Math.min(v4, max), min);
var sanitize = (v4) => v4 % 1 ? Number(v4.toFixed(5)) : v4;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString2(v4) {
  return typeof v4 === "string";
}

// node_modules/style-value-types/dist/es/numbers/index.mjs
var number = {
  test: (v4) => typeof v4 === "number",
  parse: parseFloat,
  transform: (v4) => v4
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp2(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });

// node_modules/style-value-types/dist/es/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v4) => isString2(v4) && v4.endsWith(unit) && v4.split(" ").length === 1,
  parse: parseFloat,
  transform: (v4) => `${v4}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v4) => percent.parse(v4) / 100, transform: (v4) => percent.transform(v4 * 100) });

// node_modules/style-value-types/dist/es/color/utils.mjs
var isColorString = (type2, testProp) => (v4) => {
  return Boolean(isString2(v4) && singleColorRegex.test(v4) && v4.startsWith(type2) || testProp && Object.prototype.hasOwnProperty.call(v4, testProp));
};
var splitColor = (aName, bName, cName) => (v4) => {
  if (!isString2(v4))
    return v4;
  const [a5, b4, c5, alpha2] = v4.match(floatRegex);
  return {
    [aName]: parseFloat(a5),
    [bName]: parseFloat(b4),
    [cName]: parseFloat(c5),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/style-value-types/dist/es/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/style-value-types/dist/es/color/rgba.mjs
var clampRgbUnit = clamp2(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v4) => Math.round(clampRgbUnit(v4)) });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/style-value-types/dist/es/color/hex.mjs
function parseHex(v4) {
  let r5 = "";
  let g3 = "";
  let b4 = "";
  let a5 = "";
  if (v4.length > 5) {
    r5 = v4.substr(1, 2);
    g3 = v4.substr(3, 2);
    b4 = v4.substr(5, 2);
    a5 = v4.substr(7, 2);
  } else {
    r5 = v4.substr(1, 1);
    g3 = v4.substr(2, 1);
    b4 = v4.substr(3, 1);
    a5 = v4.substr(4, 1);
    r5 += r5;
    g3 += g3;
    b4 += b4;
    a5 += a5;
  }
  return {
    red: parseInt(r5, 16),
    green: parseInt(g3, 16),
    blue: parseInt(b4, 16),
    alpha: a5 ? parseInt(a5, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/style-value-types/dist/es/color/index.mjs
var color = {
  test: (v4) => rgba.test(v4) || hex.test(v4) || hsla.test(v4),
  parse: (v4) => {
    if (rgba.test(v4)) {
      return rgba.parse(v4);
    } else if (hsla.test(v4)) {
      return hsla.parse(v4);
    } else {
      return hex.parse(v4);
    }
  },
  transform: (v4) => {
    return isString2(v4) ? v4 : v4.hasOwnProperty("red") ? rgba.transform(v4) : hsla.transform(v4);
  }
};

// node_modules/style-value-types/dist/es/complex/index.mjs
var colorToken = "${c}";
var numberToken = "${n}";
function test(v4) {
  var _a2, _b, _c, _d;
  return isNaN(v4) && isString2(v4) && ((_b = (_a2 = v4.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v4.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v4) {
  if (typeof v4 === "number")
    v4 = `${v4}`;
  const values = [];
  let numColors = 0;
  const colors = v4.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v4 = v4.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v4.match(floatRegex);
  if (numbers) {
    v4 = v4.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v4 };
}
function parse(v4) {
  return analyse(v4).values;
}
function createTransformer(v4) {
  const { values, numColors, tokenised } = analyse(v4);
  const numValues = values.length;
  return (v5) => {
    let output = tokenised;
    for (let i4 = 0; i4 < numValues; i4++) {
      output = output.replace(i4 < numColors ? colorToken : numberToken, i4 < numColors ? color.transform(v5[i4]) : sanitize(v5[i4]));
    }
    return output;
  };
}
var convertNumbersToZero = (v4) => typeof v4 === "number" ? 0 : v4;
function getAnimatableNone(v4) {
  const parsed = parse(v4);
  const transformer = createTransformer(v4);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse, createTransformer, getAnimatableNone };

// node_modules/style-value-types/dist/es/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v4) {
  let [name, value] = v4.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v4;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v4;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v4) => {
  const functions = v4.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v4;
} });

// node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p3, q2, t5) {
  if (t5 < 0)
    t5 += 1;
  if (t5 > 1)
    t5 -= 1;
  if (t5 < 1 / 6)
    return p3 + (q2 - p3) * 6 * t5;
  if (t5 < 1 / 2)
    return q2;
  if (t5 < 2 / 3)
    return p3 + (q2 - p3) * (2 / 3 - t5) * 6;
  return p3;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p3 = 2 * lightness - q2;
    red = hueToRgb(p3, q2, hue + 1 / 3);
    green = hueToRgb(p3, q2, hue);
    blue = hueToRgb(p3, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/popmotion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from, to, v4) => {
  const fromExpo = from * from;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v4 * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = (v4) => colorTypes.find((type2) => type2.test(v4));
var notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;
var mixColor = (from, to) => {
  let fromColorType = getColorType(from);
  let toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from));
  invariant(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v4) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v4);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v4);
    return fromColorType.transform(blended);
  };
};

// node_modules/popmotion/dist/es/utils/inc.mjs
var isNum = (v4) => typeof v4 === "number";

// node_modules/popmotion/dist/es/utils/pipe.mjs
var combineFunctions = (a5, b4) => (v4) => b4(a5(v4));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v4) => mix(origin, target, v4);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = (from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i4) => getMixer(fromThis, to[i4]));
  return (v4) => {
    for (let i4 = 0; i4 < numValues; i4++) {
      output[i4] = blendValue[i4](v4);
    }
    return output;
  };
};
var mixObject = (origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v4) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v4);
    }
    return output;
  };
};
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i4 = 0; i4 < numValues; i4++) {
    if (numNumbers || typeof parsed[i4] === "number") {
      numNumbers++;
    } else {
      if (parsed[i4].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p3) => `${p3 > 0 ? target : origin}`;
  }
};

// node_modules/popmotion/dist/es/utils/interpolate.mjs
var mixNumber = (from, to) => (p3) => mix(from, to, p3);
function detectMixerFactory(v4) {
  if (typeof v4 === "number") {
    return mixNumber;
  } else if (typeof v4 === "string") {
    if (color.test(v4)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v4)) {
    return mixArray;
  } else if (typeof v4 === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i4 = 0; i4 < numMixers; i4++) {
    let mixer = mixerFactory(output[i4], output[i4 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i4] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from, to], [mixer]) {
  return (v4) => mixer(progress(from, to, v4));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v4) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v4 <= input[0]) {
      foundMixerIndex = true;
    } else if (v4 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i4 = 1;
      for (; i4 < inputLength; i4++) {
        if (input[i4] > v4 || i4 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i4 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v4);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v4) => interpolator(clamp(input[0], input[inputLength - 1], v4)) : interpolator;
}

// node_modules/popmotion/dist/es/easing/utils.mjs
var reverseEasing = (easing) => (p3) => 1 - easing(1 - p3);
var mirrorEasing = (easing) => (p3) => p3 <= 0.5 ? easing(2 * p3) / 2 : (2 - easing(2 * (1 - p3))) / 2;
var createExpoIn = (power) => (p3) => Math.pow(p3, power);
var createBackIn = (power) => (p3) => p3 * p3 * ((power + 1) * p3 - power);
var createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p3) => (p3 *= 2) < 1 ? 0.5 * backEasing(p3) : 0.5 * (2 - Math.pow(2, -10 * (p3 - 1)));
};

// node_modules/popmotion/dist/es/easing/index.mjs
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = (p3) => 1 - Math.sin(Math.acos(p3));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = (p3) => {
  if (p3 === 1 || p3 === 0)
    return p3;
  const p22 = p3 * p3;
  return p3 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p3 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p3 + 3.4 : p3 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p3 + cc : 10.8 * p3 * p3 - 20.52 * p3 + 10.72;
};
var bounceIn = reverseEasing(bounceOut);

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i4) => i4 !== 0 ? i4 / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o4) => o4 * duration);
}
function keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from };
  const values = Array.isArray(to) ? to : [from, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t5) => {
      state.value = interpolator(t5);
      state.done = t5 >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// node_modules/popmotion/dist/es/animations/generators/decay.mjs
function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from;
  return {
    next: (t5) => {
      const delta = -amplitude * Math.exp(-t5 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring;
  }
  return keyframes;
}

// node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i4 = 0; i4 < numToRun; i4++) {
          const callback = toRun[i4];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}

// node_modules/framesync/dist/es/index.mjs
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = (stepId) => steps[stepId].process(frame);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var es_default = sync;

// node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

// node_modules/popmotion/dist/es/animations/index.mjs
var framesync = (update2) => {
  const passTimestamp = ({ delta }) => update2(delta);
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a2) {
  var _b, _c;
  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a2, options = __rest2(_a2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update2(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update2);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// node_modules/popmotion/dist/es/utils/attract.mjs
var identity = (v4) => v4;
var createAttractor = (alterDisplacement = identity) => (constant, origin, v4) => {
  const displacement = origin - v4;
  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
  return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
};
var attract = createAttractor();
var attractExpo = createAttractor(Math.sqrt);

// node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);

// node_modules/lingo3d-react/lib/hooks/useSpring.js
var import_react63 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useValue.js
var import_react62 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/utils/AnimReactive.js
var AnimReactive = class extends Reactive {
};

// node_modules/lingo3d-react/lib/hooks/useValue.js
var useValue_default = (o4) => {
  const reactive = (0, import_react62.useMemo)(() => {
    var _a2, _b, _c;
    const value = typeof (o4 === null || o4 === void 0 ? void 0 : o4.from) === "function" ? o4.from() : (_a2 = o4 === null || o4 === void 0 ? void 0 : o4.from) !== null && _a2 !== void 0 ? _a2 : 0;
    return new AnimReactive((_c = (_b = o4 === null || o4 === void 0 ? void 0 : o4.map) === null || _b === void 0 ? void 0 : _b.call(o4, value)) !== null && _c !== void 0 ? _c : value);
  }, []);
  (0, import_react62.useLayoutEffect)(() => {
    if (typeof (o4 === null || o4 === void 0 ? void 0 : o4.from) !== "function")
      return;
    const { map } = o4;
    if (map) {
      const handle2 = o4.from((v4) => reactive.set(map(v4)));
      return () => {
        handle2.cancel();
      };
    }
    const handle = o4.from(reactive.set);
    return () => {
      handle.cancel();
    };
  }, []);
  (0, import_react62.useLayoutEffect)(() => {
    const step = o4 === null || o4 === void 0 ? void 0 : o4.step;
    if (!step)
      return;
    const handle = reactive.get(step);
    return () => {
      handle.cancel();
    };
  }, []);
  return reactive;
};

// node_modules/lingo3d-react/lib/hooks/useSpring.js
var useSpring_default = (o4) => {
  const { to, from = to, step, delay, ...options } = typeof o4 === "number" ? { to: o4 } : o4;
  const reactive = useValue_default({ from, step });
  const [r5, render] = (0, import_react63.useState)({});
  const rOld = usePrevious_default(r5);
  reactive.restart = () => render({});
  (0, import_react63.useLayoutEffect)(() => {
    const handle = new Cancellable();
    (async () => {
      await new Promise((resolve) => setTimeout(resolve, delay));
      if (handle.done)
        return;
      const anim = spring({ from: rOld === r5 ? reactive.get() : from, to, ...options });
      const time = Date.now();
      handle.watch(loop(() => {
        const { value, done: done2 } = anim.next(Date.now() - time);
        reactive.set(value);
        if (done2) {
          handle.cancel();
          return;
        }
      }));
    })();
    return () => {
      handle.cancel();
    };
  }, [to, r5]);
  return reactive;
};

// node_modules/lingo3d-react/lib/hooks/useAnimation.js
var import_react64 = __toESM(require_react());
var useAnimation_default = ({ from, to, duration = 1e3, stopped, step, ...options }) => {
  const reactive = useValue_default({ from, step });
  const [r5, render] = (0, import_react64.useState)({});
  const rOld = usePrevious_default(r5);
  reactive.restart = () => render({});
  (0, import_react64.useLayoutEffect)(() => {
    if (stopped)
      return;
    const anim = animate({
      from: rOld === r5 ? reactive.get() : from,
      to,
      duration,
      ...options,
      onUpdate: reactive.set
    });
    return () => {
      anim.stop();
    };
  }, [to, stopped, r5]);
  return reactive;
};

// node_modules/lingo3d-react/lib/hooks/useLoop.js
var import_react65 = __toESM(require_react());
var useLoop_default = (cb2, play = true) => {
  const cbCurrentRef = useCurrentRef_default(cb2);
  (0, import_react65.useLayoutEffect)(() => {
    if (!play)
      return;
    const handle = loop(() => cbCurrentRef.current());
    return () => {
      handle.cancel();
    };
  }, [play]);
};

// node_modules/lingo3d-react/lib/hooks/useMouse.js
var import_react66 = __toESM(require_react());
var useMouse_default = () => {
  const statusRef = (0, import_react66.useRef)({ isDown: false });
  const [, render] = (0, import_react66.useState)({});
  (0, import_react66.useLayoutEffect)(() => {
    const mouse = new Mouse();
    mouse.onMouseDown = () => {
      statusRef.current.isDown = true;
      render({});
    };
    mouse.onMouseUp = () => {
      statusRef.current.isDown = false;
      render({});
    };
    return () => {
      mouse.dispose();
    };
  }, []);
  return statusRef.current;
};

// node_modules/lingo3d-react/lib/hooks/useKeyboard.js
var import_react67 = __toESM(require_react());
var useKeyboard_default = (cb2) => {
  const [keys, setKeys] = (0, import_react67.useState)("");
  const cbCurrentRef = useCurrentRef_default(cb2);
  (0, import_react67.useLayoutEffect)(() => {
    const keyboard2 = new Keyboard();
    let latestKey = "";
    keyboard2.onKeyDown = (k3) => {
      if (latestKey === k3)
        return;
      latestKey = k3;
      setKeys([...isPressed2].join(" "));
    };
    keyboard2.onKeyUp = () => {
      latestKey = "";
      setKeys([...isPressed2].join(" "));
    };
    keyboard2.onKeyPress = (k3) => {
      var _a2;
      return (_a2 = cbCurrentRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(cbCurrentRef, k3);
    };
    return () => {
      keyboard2.dispose();
    };
  }, []);
  return keys;
};

// node_modules/lingo3d-react/lib/hooks/usePreload.js
var import_react69 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useLayoutEffectOnce.js
var import_react68 = __toESM(require_react());
var useLayoutEffectOnce_default = (effect, deps) => {
  const effectRef = (0, import_react68.useRef)(effect);
  const depsRef = (0, import_react68.useRef)();
  const cleanUpRef = (0, import_react68.useRef)();
  (0, import_react68.useLayoutEffect)(() => {
    var _a2;
    let shouldRun = false;
    if (!depsRef.current)
      shouldRun = true;
    else
      for (let i4 = 0; i4 < depsRef.current.length; i4++)
        if (depsRef.current[i4] !== deps[i4])
          shouldRun = true;
    depsRef.current = deps;
    if (!shouldRun)
      return;
    (_a2 = cleanUpRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(cleanUpRef);
    cleanUpRef.current = effectRef.current();
  });
};

// node_modules/lingo3d-react/lib/hooks/usePreload.js
var usePreload_default = (urls, total) => {
  const [progress2, setProgress] = (0, import_react69.useState)(0);
  useLayoutEffectOnce_default(() => {
    preload_default(urls, total, (val) => setProgress(val)).then(() => setProgress(100));
  }, []);
  return progress2;
};

// node_modules/lingo3d-react/lib/hooks/useTimer.js
var import_react70 = __toESM(require_react());
var useTimer_default = (duration, repeat, cb2, play = true) => {
  const cbCurrentRef = useCurrentRef_default(cb2);
  (0, import_react70.useLayoutEffect)(() => {
    if (!play)
      return;
    const handle = timer(duration, repeat, () => cbCurrentRef.current());
    return () => {
      handle.cancel();
    };
  }, [play, duration, repeat]);
};

// node_modules/lingo3d-react/lib/hooks/useWindowSize.js
var import_react71 = __toESM(require_react());
var useWindowSize_default2 = () => {
  const [windowSize, setWindowSize] = (0, import_react71.useState)({ width: window.innerWidth, height: window.innerHeight });
  (0, import_react71.useLayoutEffect)(() => {
    const cb2 = () => setWindowSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener("resize", cb2);
    return () => {
      window.removeEventListener("resize", cb2);
    };
  }, []);
  return windowSize;
};

// node_modules/lingo3d-react/lib/hooks/useDocumentScroll.js
var import_react72 = __toESM(require_react());
var useDocumentScroll_default = () => {
  const [scroll, setScroll] = (0, import_react72.useState)({ x: window.scrollX, y: window.scrollY });
  (0, import_react72.useLayoutEffect)(() => {
    const cb2 = () => setScroll({ x: window.scrollX, y: window.scrollY });
    document.addEventListener("scroll", cb2, { passive: true });
    return () => {
      document.removeEventListener("scroll", cb2);
    };
  }, []);
  return scroll;
};

// node_modules/lingo3d-react/lib/hooks/useRenderer.js
var import_react73 = __toESM(require_react());
var useRenderer_default = () => {
  const [renderer, setRenderer] = (0, import_react73.useState)(() => getRenderer());
  (0, import_react73.useLayoutEffect)(() => {
    const handle = getRenderer((value) => {
      setRenderer(value);
    });
    return () => {
      handle.cancel();
    };
  }, []);
  return renderer;
};

// node_modules/lingo3d-react/lib/hooks/useScene.js
var useScene_default = () => {
  return scene_default;
};

// node_modules/@lincode/react-reticle/lib/index.js
var import_react74 = __toESM(require_react());
var reticles = [
  import_react74.default.lazy(() => import("./Reticle0-X54RZKLK.js")),
  import_react74.default.lazy(() => import("./Reticle1-FEYVLH2D.js")),
  import_react74.default.lazy(() => import("./Reticle2-JJZTNZFW.js")),
  import_react74.default.lazy(() => import("./Reticle3-J7ZST3NE.js")),
  import_react74.default.lazy(() => import("./Reticle4-Q5VXHTMF.js")),
  import_react74.default.lazy(() => import("./Reticle5-VHIBKITS.js")),
  import_react74.default.lazy(() => import("./Reticle6-ASYZJBQQ.js")),
  import_react74.default.lazy(() => import("./Reticle7-G4MMYQG3.js"))
];
var Reticle = ({ variant = 0, ...props }) => {
  return import_react74.default.createElement(import_react74.default.Suspense, { fallback: null }, import_react74.default.createElement(reticles[variant], props));
};
var lib_default2 = Reticle;

// node_modules/@lincode/react-joystick/lib/index.js
var import_react75 = __toESM(require_react());
var import_react_device_detect = __toESM(require_lib());
var diameter = 100;
var radius = diameter / 2;
var useDrag = (cb2) => {
  const [el, setEl] = (0, import_react75.useState)(null);
  (0, import_react75.useEffect)(() => {
    if (!el)
      return;
    let down = false;
    const getCenter = () => {
      const { left, right, top: top2, bottom } = el.getBoundingClientRect();
      return { x: (left + right) / 2, y: (top2 + bottom) / 2 };
    };
    const onMouseDown = (e5) => {
      down = true;
      const { x: x2, y: y4 } = getCenter();
      cb2({ deltaX: e5.clientX - x2, deltaY: e5.clientY - y4 });
    };
    const onTouchStart = (e5) => {
      e5.stopPropagation();
      e5.preventDefault();
      down = true;
      const { x: x2, y: y4 } = getCenter();
      cb2({ deltaX: e5.targetTouches[0].clientX - x2, deltaY: e5.targetTouches[0].clientY - y4 });
    };
    const onMouseMove = (e5) => {
      if (!down)
        return;
      const { x: x2, y: y4 } = getCenter();
      cb2({ deltaX: e5.clientX - x2, deltaY: e5.clientY - y4 });
    };
    const onTouchMove = (e5) => {
      e5.stopPropagation();
      if (!down)
        return;
      const { x: x2, y: y4 } = getCenter();
      cb2({ deltaX: e5.targetTouches[0].clientX - x2, deltaY: e5.targetTouches[0].clientY - y4 });
    };
    const onMouseUp = () => {
      down = false;
      cb2({ deltaX: 0, deltaY: 0 });
    };
    const onTouchEnd = (e5) => {
      e5.stopPropagation();
      down = false;
      cb2({ deltaX: 0, deltaY: 0 });
    };
    if (import_react_device_detect.isMobile) {
      el.addEventListener("touchstart", onTouchStart);
      el.addEventListener("touchmove", onTouchMove);
      el.addEventListener("touchend", onTouchEnd);
    } else {
      el.addEventListener("mousedown", onMouseDown);
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    return () => {
      if (import_react_device_detect.isMobile) {
        el.removeEventListener("touchstart", onTouchStart);
        el.removeEventListener("touchmove", onTouchMove);
        el.removeEventListener("touchend", onTouchEnd);
      } else {
        el.removeEventListener("mousedown", onMouseDown);
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
    };
  }, [el]);
  return setEl;
};
var circleElement = import_react75.default.createElement("div", { style: {
  width: "100%",
  height: "100%",
  borderRadius: 9999,
  backgroundColor: "currentColor",
  border: "1px solid white",
  opacity: 0.25
} });
var Joystick = ({ onMove, onMoveStart, onMoveEnd, position = "bottom-left", style: style3, outerElement, innerElement, ...restProps }) => {
  const [delta, setDelta] = (0, import_react75.useState)([0, 0, 0]);
  const deltaRef = useCurrentRef_default(delta);
  const isMoved = delta[0] !== 0 || delta[1] !== 0;
  const isMovedTruthy = useTruthy_default(isMoved);
  (0, import_react75.useLayoutEffect)(() => {
    if (!isMovedTruthy)
      return;
    const data = { x: 0, y: 0, angle: 0 };
    isMoved ? onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart(data) : onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd(data);
    if (!isMoved)
      return;
    let anim;
    const loop2 = () => anim = requestAnimationFrame(() => {
      loop2();
      const [x2, y4, angle2] = deltaRef.current;
      onMove === null || onMove === void 0 ? void 0 : onMove({ x: x2, y: y4, angle: angle2 });
    });
    loop2();
    return () => {
      cancelAnimationFrame(anim);
    };
  }, [isMoved, isMovedTruthy]);
  const setDragEl = useDrag(({ deltaX, deltaY }) => {
    const angle2 = Math.atan2(deltaY, deltaX) * rad2Deg;
    const dist = Math.min(distance(0, 0, deltaX, deltaY), radius);
    const { x: x2, y: y4 } = endPoint(0, 0, angle2, dist);
    setDelta([x2, y4, angle2]);
  });
  const [ly, lx] = position.split("-");
  return import_react75.default.createElement("div", { ...restProps, ref: setDragEl, style: {
    width: diameter,
    height: diameter,
    color: "#999999",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    position: "absolute",
    left: lx === "left" ? "0px" : void 0,
    right: lx === "right" ? "0px" : void 0,
    top: ly === "top" ? "0px" : void 0,
    bottom: ly === "bottom" ? "0px" : void 0,
    margin: "5%",
    ...style3
  } }, import_react75.default.createElement("div", { style: { position: "absolute", width: "100%", height: "100%" } }, outerElement !== null && outerElement !== void 0 ? outerElement : circleElement), import_react75.default.createElement("div", { style: { width: radius, height: radius, transform: `translate(${delta[0]}px, ${delta[1]}px)` } }, innerElement !== null && innerElement !== void 0 ? innerElement : circleElement));
};
var lib_default3 = Joystick;
export {
  AmbientLight_default as AmbientLight,
  AreaLight_default as AreaLight,
  Audio_default as Audio,
  Camera_default as Camera,
  Circle_default as Circle,
  Cone_default as Cone,
  Cube_default as Cube,
  Cylinder_default as Cylinder,
  DirectionalLight_default as DirectionalLight,
  Dummy_default as Dummy,
  Editor_default as Editor,
  Environment_default as Environment,
  Find_default as Find,
  FirstPersonCamera_default as FirstPersonCamera,
  Group_default as Group,
  HTML_default as HTML,
  lib_default3 as Joystick,
  Keyboard_default as Keyboard,
  Library_default as Library,
  LingoEditor_default as LingoEditor,
  Model_default as Model,
  Mouse_default as Mouse,
  Octahedron_default as Octahedron,
  OrbitCamera_default as OrbitCamera,
  Plane_default as Plane,
  PointLight_default2 as PointLight,
  Reflector_default as Reflector,
  lib_default2 as Reticle,
  SceneGraph_default as SceneGraph,
  Setup_default as Setup,
  SkyLight_default as SkyLight,
  Skybox_default as Skybox,
  Sphere_default as Sphere,
  SpotLight_default2 as SpotLight,
  Sprite_default2 as Sprite,
  Stats_default as Stats,
  SvgMesh_default2 as SvgMesh,
  Tetrahedron_default as Tetrahedron,
  ThirdPersonCamera_default as ThirdPersonCamera,
  Toolbar_default as Toolbar,
  Torus_default as Torus,
  Trigger_default as Trigger,
  UI_default as UI,
  World_default as World,
  createProxy_default as createProxy,
  deserialize_default as deserialize,
  keyboard_default as keyboard,
  loop,
  mainOrbitCamera_default as mainOrbitCamera,
  mouse_default as mouse,
  onAfterRender,
  onBeforeRender,
  screenshot_default as screenshot,
  serialize_default as serialize,
  setWasmPath,
  useAnimation_default as useAnimation,
  useDocumentScroll_default as useDocumentScroll,
  useKeyboard_default as useKeyboard,
  useLoop_default as useLoop,
  useMouse_default as useMouse,
  usePreload_default as usePreload,
  useRenderer_default as useRenderer,
  useScene_default as useScene,
  useSpawn_default as useSpawn,
  useSpring_default as useSpring,
  useTimer_default as useTimer,
  useValue_default as useValue,
  useWindowSize_default2 as useWindowSize
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! Tweakpane 3.1.0 (c) 2016 cocopon, licensed under the MIT license. */
//# sourceMappingURL=lingo3d-react.js.map
