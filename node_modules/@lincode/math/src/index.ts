export class Point {
    public constructor(
        public x: number,
        public y: number
    ) {}
}

export class Point3d {
    public constructor(
        public x: number,
        public y: number,
        public z: number
    ) {}
}

export class Size {
    public constructor(
        public width: number,
        public height: number
    ) {}
}

export type Line = [Point, Point]

type IntersectType = "parallel" | "colinear" | "none" | "intersect"

export class Intersect {
    public constructor(
        public type: IntersectType,
        public point?: Point
    ) {}
}

export const rad2Deg = 180 / Math.PI
export const deg2Rad = Math.PI / 180

export const mapRange = (
    value: number, minFrom: number, maxFrom: number, minTo: number, maxTo: number, constrain?: boolean

): number => {
    
    const rangeFrom = maxFrom - minFrom
    const rangeTo = maxTo - minTo
    const result = minTo + ((value - minFrom) / rangeFrom * rangeTo)

    if (!constrain)
        return result

    let minVal: number
    let maxVal: number
    if (minTo < maxTo) {
        minVal = minTo
        maxVal = maxTo
    }
    else {
        minVal = maxTo
        maxVal = minTo
    }
    if (result < minVal)
        return minVal
    if (result > maxVal)
        return maxVal

    return result
}

export const rangeOverlap = (min0: number, max0: number, min1: number, max1: number): number => {
    return Math.max(Math.min(max0, max1) - Math.max(min0, min1), 0)
}

export const distance = (x0: number, y0: number, x1: number, y1: number): number => {
    return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2)
}

export const distance3d = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): number => {
    return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2)
}

export const geoDistance = (lng0: number, lat0: number, lng1: number, lat1: number): number => { //km
    const dLat = (lat1 - lat0) * deg2Rad
    const dLng = (lng1 - lng0) * deg2Rad

    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat0 * deg2Rad) * Math.cos(lat1 * deg2Rad) * Math.sin(dLng / 2) * Math.sin(dLng / 2)

    return 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
}

export const vertexAngle = (vertex: Point, pt1: Point, pt2: Point, reflex?: boolean): number => {
    const p01 = distance(vertex.x, vertex.y, pt1.x, pt1.y)
    const p02 = distance(vertex.x, vertex.y, pt2.x, pt2.y)
    const p12 = distance(pt1.x, pt1.y, pt2.x, pt2.y)
    const angle = Math.acos(((p01 * p01) + (p02 * p02) - (p12 * p12)) / (2 * p01 * p02)) * rad2Deg
    return reflex ? 360 - angle : angle
}

export const vertexAngle3d = (vertex: Point3d, pt1: Point3d, pt2: Point3d, reflex?: boolean): number => {
    const p01 = distance3d(vertex.x, vertex.y, vertex.z, pt1.x, pt1.y, pt1.z)
    const p02 = distance3d(vertex.x, vertex.y, vertex.z, pt2.x, pt2.y, pt2.z)
    const p12 = distance3d(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z)
    const angle = Math.acos(((p01 * p01) + (p02 * p02) - (p12 * p12)) / (2 * p01 * p02)) * rad2Deg
    return reflex ? 360 - angle : angle
}

export const quaternion2Euler = (x: number, y: number, z: number, w: number): Point3d => {
    const sinr_cosp = 2 * (w * x + y * z)
    const cosr_cosp = 1 - 2 * (x * x + y * y)
    const roll = Math.atan2(sinr_cosp, cosr_cosp)

    const sinp = 2 * (w * y - z * x)
    const pitch = Math.abs(sinp) >= 1
        ? sinp > 0 ? Math.PI / 2 : -Math.PI / 2
        : Math.asin(sinp)

    const siny_cosp = 2 * (w * z + x * y)
    const cosy_cosp = 1 - 2 * (y * y + z * z)
    const yaw = Math.atan2(siny_cosp, cosy_cosp)

    return new Point3d(roll * rad2Deg, pitch * rad2Deg, yaw * rad2Deg)
}

export const polar2Cartesian = (centerX: number, centerY: number, radius: number, angle: number): Point => {
    const theta = (angle - 90) * deg2Rad
    return new Point(centerX + (radius * Math.cos(theta)), centerY + (radius * Math.sin(theta)))
}

export const rotatePoint = (pt: Point, origin: Point, theta: number): Point => {
    const rad = theta * deg2Rad
    const deltaX = pt.x - origin.x
    const deltaY = pt.y - origin.y
    const rotatedX = (deltaX * Math.cos(rad)) - (deltaY * Math.sin(rad))
    const rotatedY = (deltaX * Math.sin(rad)) + (deltaY * Math.cos(rad))

    return new Point(rotatedX + origin.x, rotatedY + origin.y)
}

export const rotatedBoundingSize = (w: number, h: number, theta: number): Size => {
    const rad = theta * deg2Rad
    const width = Math.abs(w * Math.cos(rad)) + Math.abs(h * Math.sin(rad))
    const height = Math.abs(w * Math.sin(rad)) + Math.abs(h * Math.cos(rad))

    return new Size(width, height)
}

export const midPoint = (x0: number, y0: number, x1: number, y1: number): Point => {
    return new Point((x0 + x1) / 2, (y0 + y1) / 2)
}

export const centroid = (points: Array<Point>): Point => {
    const res = new Point(0, 0)
    for (const pt of points) {
        res.x += pt.x
        res.y += pt.y
    }
    res.x /= points.length
    res.y /= points.length
    return res
}

export const centroid3d = (points: Array<Point3d>): Point3d => {
    const res = new Point3d(0, 0, 0)
    for (const pt of points) {
        res.x += pt.x
        res.y += pt.y
        res.z += pt.z
    }
    res.x /= points.length
    res.y /= points.length
    res.z /= points.length
    return res
}

export const wrapRange = (val: number, min: number, max: number): number => {
    max += 1
    const valMin = val - min, maxMin = max - min, remainder = valMin % maxMin
    if (remainder < 0) return max + remainder
    return min + remainder
}

export const wrapDegree = (val: number): number => {
    return wrapRange(val, 0, 359)
}

export const wrapRadian = (val: number): number => {
    return wrapDegree(val * rad2Deg) * deg2Rad
}

export const intersect = (line0: Line, line1: Line, lineSegment = true): Intersect => {
    const [p00, p01] = line0
    const [p10, p11] = line1
    const x0 = p00.x, y0 = p00.y, x1 = p01.x, y1 = p01.y
    const x2 = p10.x, y2 = p10.y, x3 = p11.x, y3 = p11.y

    const denom = ((y3 - y2) * (x1 - x0)) - ((x3 - x2) * (y1 - y0))
    const numeA = ((x3 - x2) * (y0 - y2)) - ((y3 - y2) * (x0 - x2))
    const numeB = ((x1 - x0) * (y0 - y2)) - ((y1 - y0) * (x0 - x2))

    if (denom === 0) {
        if (numeA === 0 && numeB === 0)
            return new Intersect("colinear")
        else
            return new Intersect("parallel")
    }

    const uA = numeA / denom, uB = numeB / denom

    if (!lineSegment || (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1))
        return new Intersect("intersect", new Point(x0 + (uA * (x1 - x0)), y0 + (uA * (y1 - y0))))

    return new Intersect("none")
}

export const normalIntersect = (line: Line, pt: Point): Point => {
    const [p0, p1] = line
    const x0 = p0.x, y0 = p0.y, x1 = p1.x, y1 = p1.y, x = pt.x, y = pt.y

    const k = ((y1 - y0) * (x - x0) - (x1 - x0) * (y - y0)) / ((y1 - y0) ** 2 + (x1 - x0) ** 2)
    return new Point(x - k * (y1 - y0), y + k * (x1 - x0))
}

export const quadrant = (x: number, y: number, originX: number, originY: number): 1 | 2 | 3 | 4 => {
    if (x >= originX && y <= originY) return 1
    if (x <= originX && y <= originY) return 2
    if (x <= originX && y >= originY) return 3
    return 4
}

export const endPoint = (x: number, y: number, theta: number, dist: number): Point => {
    const rad = theta *= deg2Rad
    return new Point(x + dist * Math.cos(rad), y + dist * Math.sin(rad))
}

export const polygonArea = (xList: Array<number>, yList: Array<number>) => {
    const n = xList.length
    let area = 0
    let j = n - 1
    for (let i = 0; i < n; i++) {
        area += (xList[j] + xList[i]) * (yList[j] - yList[i])
        j = i
    }
    return Math.abs(area / 2.0)
}

export class UnitBezier {
    private epsilon = 1e-6
    private cx: number
    private bx: number
    private ax: number
    private cy: number
    private by: number
    private ay: number

    public constructor(p1x: number, p1y: number, p2x: number, p2y: number) {
        this.cx = 3.0 * p1x, this.bx = 3.0 * (p2x - p1x) - this.cx, this.ax = 1.0 - this.cx - this.bx
        this.cy = 3.0 * p1y, this.by = 3.0 * (p2y - p1y) - this.cy, this.ay = 1.0 - this.cy - this.by
    }

    private sampleCurveX(t: number): number {
        return ((this.ax * t + this.bx) * t + this.cx) * t
    }

    private sampleCurveY(t: number): number {
        return ((this.ay * t + this.by) * t + this.cy) * t
    }

    private sampleCurveDerivativeX(t: number): number {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx
    }

    private solveCurveX(x: number): number {
        let t0: number, t1: number, t2: number, x2: number, d2: number, i: number

        for (t2 = x, i = 0; i < 8; ++i) {
            x2 = this.sampleCurveX(t2) - x

            if (Math.abs(x2) < this.epsilon)
                return t2

            d2 = this.sampleCurveDerivativeX(t2)

            if (Math.abs(d2) < this.epsilon)
                break

            t2 = t2 - x2 / d2
        }

        t0 = 0.0, t1 = 1.0, t2 = x

        if (t2 < t0)
            return t0
        else if (t2 > t1)
            return t1

        while (t0 < t1) {
            x2 = this.sampleCurveX(t2)

            if (Math.abs(x2 - x) < this.epsilon)
                return t2

            if (x > x2)
                t0 = t2
            else
                t1 = t2

            t2 = (t1 - t0) * 0.5 + t0
        }
        return t2
    }

    public solve(x: number): number {
        return this.sampleCurveY(this.solveCurveX(x))
    }
}

export class PerspectiveTransform {
    private srcX: Array<number> = []
    private srcY: Array<number> = []
    private dstX: Array<number> = []
    private dstY: Array<number> = []
    private srcMat: Array<number> = []
    private dstMat: Array<number> = []
    private warpMat: Array<number> = []
    private dirty: boolean = false

    public setSource(
        x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number
    ): void {
        this.srcX[0] = x0, this.srcY[0] = y0, this.srcX[1] = x1, this.srcY[1] = y1
        this.srcX[2] = x2, this.srcY[2] = y2, this.srcX[3] = x3, this.srcY[3] = y3
        this.dirty = true
    }

    public setDestination(
        x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number
    ): void {
        this.dstX[0] = x0, this.dstY[0] = y0, this.dstX[1] = x1, this.dstY[1] = y1
        this.dstX[2] = x2, this.dstY[2] = y2, this.dstX[3] = x3, this.dstY[3] = y3
        this.dirty = true
    }

    private computeSquareToQuad(
        x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, mat: Array<number>
    ): void {
        const dx1 = x1 - x2, dy1 = y1 - y2
        const dx2 = x3 - x2, dy2 = y3 - y2
        const sx = x0 - x1 + x2 - x3, sy = y0 - y1 + y2 - y3
        const g = (sx * dy2 - dx2 * sy) / (dx1 * dy2 - dx2 * dy1)
        const h = (dx1 * sy - sx * dy1) / (dx1 * dy2 - dx2 * dy1)
        const a = x1 - x0 + g * x1, b = x3 - x0 + h * x3
        const c = x0, d = y1 - y0 + g * y1, e = y3 - y0 + h * y3, f = y0

        mat[0] = a, mat[1] = d, mat[2] = 0, mat[3] = g
        mat[4] = b, mat[5] = e, mat[6] = 0, mat[7] = h
        mat[8] = 0, mat[9] = 0, mat[10] = 1, mat[11] = 0
        mat[12] = c, mat[13] = f, mat[14] = 0, mat[15] = 1
    }

    private computeQuadToSquare(
        x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, mat: Array<number>
    ): void {
        this.computeSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3, mat)

        const a = mat[0], d = mat[1], g = mat[3], b = mat[4]
        const e = mat[5], h = mat[7], c = mat[12], f = mat[13]

        const A = e - f * h, B = c * h - b, C = b * f - c * e
        const D = f * g - d, E = a - c * g, F = c * d - a * f
        const G = d * h - e * g, H = b * g - a * h, I = a * e - b * d

        const id = 1 / (a * A + b * D + c * G)

        mat[0] = A * id, mat[1] = D * id, mat[2] = 0, mat[3] = G * id
        mat[4] = B * id, mat[5] = E * id, mat[6] = 0, mat[7] = H * id
        mat[8] = 0, mat[9] = 0, mat[10] = 1, mat[11] = 0
        mat[12] = C * id, mat[13] = F * id, mat[14] = 0, mat[15] = I * id
    }

    private multMats(srcMat: Array<number>, dstMat: Array<number>, resMat: Array<number>): void {
        for (let r = 0; r < 4; ++r) {
            const ri = r * 4
            for (let c = 0; c < 4; ++c)
                resMat[ri + c] = srcMat[ri] * dstMat[c] +
                    srcMat[ri + 1] * dstMat[c + 4] +
                    srcMat[ri + 2] * dstMat[c + 8] +
                    srcMat[ri + 3] * dstMat[c + 12]
        }
    }

    private computeWarp(): void {
        this.computeQuadToSquare(
            this.srcX[0], this.srcY[0], this.srcX[1], this.srcY[1],
            this.srcX[2], this.srcY[2], this.srcX[3], this.srcY[3], this.srcMat
        )
        this.computeSquareToQuad(
            this.dstX[0], this.dstY[0], this.dstX[1], this.dstY[1],
            this.dstX[2], this.dstY[2], this.dstX[3], this.dstY[3], this.dstMat
        )
        this.multMats(this.srcMat, this.dstMat, this.warpMat)
        this.dirty = false
    }

    private warp(mat: Array<number>, srcX: number, srcY: number): Point {
        const result = [], z = 0
        result[0] = srcX * mat[0] + srcY * mat[4] + z * mat[8] + mat[12]
        result[1] = srcX * mat[1] + srcY * mat[5] + z * mat[9] + mat[13]
        result[2] = srcX * mat[2] + srcY * mat[6] + z * mat[10] + mat[14]
        result[3] = srcX * mat[3] + srcY * mat[7] + z * mat[11] + mat[15]

        return new Point(result[0] / result[3], result[1] / result[3])
    }

    public solve(srcX: number, srcY: number): Point {
        if (this.dirty) this.computeWarp()
        return this.warp(this.warpMat, srcX, srcY)
    }
}

export class LowPassFilter {
    private nOld: number | undefined

    public constructor(
        private alpha = 0.5,
        private maxDelta = Infinity
    ) {}

    public next(n: number, alpha = this.alpha, maxDelta = this.maxDelta): number {
        if (this.nOld == null) this.nOld = n

        let delta = (n - this.nOld) * alpha
        if (Math.abs(delta) > maxDelta) delta = maxDelta * (delta < 0 ? -1 : 1)

        let result = this.nOld + delta
        if (result < 0.00001 && result > -0.00001) result = 0
        return this.nOld = result
    }
}