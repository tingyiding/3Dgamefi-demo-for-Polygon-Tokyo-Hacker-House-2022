export class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
export class Point3d {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
export class Size {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
}
export class Intersect {
    constructor(type, point) {
        this.type = type;
        this.point = point;
    }
}
export const rad2Deg = 180 / Math.PI;
export const deg2Rad = Math.PI / 180;
export const mapRange = (value, minFrom, maxFrom, minTo, maxTo, constrain) => {
    const rangeFrom = maxFrom - minFrom;
    const rangeTo = maxTo - minTo;
    const result = minTo + ((value - minFrom) / rangeFrom * rangeTo);
    if (!constrain)
        return result;
    let minVal;
    let maxVal;
    if (minTo < maxTo) {
        minVal = minTo;
        maxVal = maxTo;
    }
    else {
        minVal = maxTo;
        maxVal = minTo;
    }
    if (result < minVal)
        return minVal;
    if (result > maxVal)
        return maxVal;
    return result;
};
export const rangeOverlap = (min0, max0, min1, max1) => {
    return Math.max(Math.min(max0, max1) - Math.max(min0, min1), 0);
};
export const distance = (x0, y0, x1, y1) => {
    return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);
};
export const distance3d = (x0, y0, z0, x1, y1, z1) => {
    return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2);
};
export const geoDistance = (lng0, lat0, lng1, lat1) => {
    const dLat = (lat1 - lat0) * deg2Rad;
    const dLng = (lng1 - lng0) * deg2Rad;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat0 * deg2Rad) * Math.cos(lat1 * deg2Rad) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
    return 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};
export const vertexAngle = (vertex, pt1, pt2, reflex) => {
    const p01 = distance(vertex.x, vertex.y, pt1.x, pt1.y);
    const p02 = distance(vertex.x, vertex.y, pt2.x, pt2.y);
    const p12 = distance(pt1.x, pt1.y, pt2.x, pt2.y);
    const angle = Math.acos(((p01 * p01) + (p02 * p02) - (p12 * p12)) / (2 * p01 * p02)) * rad2Deg;
    return reflex ? 360 - angle : angle;
};
export const vertexAngle3d = (vertex, pt1, pt2, reflex) => {
    const p01 = distance3d(vertex.x, vertex.y, vertex.z, pt1.x, pt1.y, pt1.z);
    const p02 = distance3d(vertex.x, vertex.y, vertex.z, pt2.x, pt2.y, pt2.z);
    const p12 = distance3d(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z);
    const angle = Math.acos(((p01 * p01) + (p02 * p02) - (p12 * p12)) / (2 * p01 * p02)) * rad2Deg;
    return reflex ? 360 - angle : angle;
};
export const quaternion2Euler = (x, y, z, w) => {
    const sinr_cosp = 2 * (w * x + y * z);
    const cosr_cosp = 1 - 2 * (x * x + y * y);
    const roll = Math.atan2(sinr_cosp, cosr_cosp);
    const sinp = 2 * (w * y - z * x);
    const pitch = Math.abs(sinp) >= 1
        ? sinp > 0 ? Math.PI / 2 : -Math.PI / 2
        : Math.asin(sinp);
    const siny_cosp = 2 * (w * z + x * y);
    const cosy_cosp = 1 - 2 * (y * y + z * z);
    const yaw = Math.atan2(siny_cosp, cosy_cosp);
    return new Point3d(roll * rad2Deg, pitch * rad2Deg, yaw * rad2Deg);
};
export const polar2Cartesian = (centerX, centerY, radius, angle) => {
    const theta = (angle - 90) * deg2Rad;
    return new Point(centerX + (radius * Math.cos(theta)), centerY + (radius * Math.sin(theta)));
};
export const rotatePoint = (pt, origin, theta) => {
    const rad = theta * deg2Rad;
    const deltaX = pt.x - origin.x;
    const deltaY = pt.y - origin.y;
    const rotatedX = (deltaX * Math.cos(rad)) - (deltaY * Math.sin(rad));
    const rotatedY = (deltaX * Math.sin(rad)) + (deltaY * Math.cos(rad));
    return new Point(rotatedX + origin.x, rotatedY + origin.y);
};
export const rotatedBoundingSize = (w, h, theta) => {
    const rad = theta * deg2Rad;
    const width = Math.abs(w * Math.cos(rad)) + Math.abs(h * Math.sin(rad));
    const height = Math.abs(w * Math.sin(rad)) + Math.abs(h * Math.cos(rad));
    return new Size(width, height);
};
export const midPoint = (x0, y0, x1, y1) => {
    return new Point((x0 + x1) / 2, (y0 + y1) / 2);
};
export const centroid = (points) => {
    const res = new Point(0, 0);
    for (const pt of points) {
        res.x += pt.x;
        res.y += pt.y;
    }
    res.x /= points.length;
    res.y /= points.length;
    return res;
};
export const centroid3d = (points) => {
    const res = new Point3d(0, 0, 0);
    for (const pt of points) {
        res.x += pt.x;
        res.y += pt.y;
        res.z += pt.z;
    }
    res.x /= points.length;
    res.y /= points.length;
    res.z /= points.length;
    return res;
};
export const wrapRange = (val, min, max) => {
    max += 1;
    const valMin = val - min, maxMin = max - min, remainder = valMin % maxMin;
    if (remainder < 0)
        return max + remainder;
    return min + remainder;
};
export const wrapDegree = (val) => {
    return wrapRange(val, 0, 359);
};
export const wrapRadian = (val) => {
    return wrapDegree(val * rad2Deg) * deg2Rad;
};
export const intersect = (line0, line1, lineSegment = true) => {
    const [p00, p01] = line0;
    const [p10, p11] = line1;
    const x0 = p00.x, y0 = p00.y, x1 = p01.x, y1 = p01.y;
    const x2 = p10.x, y2 = p10.y, x3 = p11.x, y3 = p11.y;
    const denom = ((y3 - y2) * (x1 - x0)) - ((x3 - x2) * (y1 - y0));
    const numeA = ((x3 - x2) * (y0 - y2)) - ((y3 - y2) * (x0 - x2));
    const numeB = ((x1 - x0) * (y0 - y2)) - ((y1 - y0) * (x0 - x2));
    if (denom === 0) {
        if (numeA === 0 && numeB === 0)
            return new Intersect("colinear");
        else
            return new Intersect("parallel");
    }
    const uA = numeA / denom, uB = numeB / denom;
    if (!lineSegment || (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1))
        return new Intersect("intersect", new Point(x0 + (uA * (x1 - x0)), y0 + (uA * (y1 - y0))));
    return new Intersect("none");
};
export const normalIntersect = (line, pt) => {
    const [p0, p1] = line;
    const x0 = p0.x, y0 = p0.y, x1 = p1.x, y1 = p1.y, x = pt.x, y = pt.y;
    const k = ((y1 - y0) * (x - x0) - (x1 - x0) * (y - y0)) / ((y1 - y0) ** 2 + (x1 - x0) ** 2);
    return new Point(x - k * (y1 - y0), y + k * (x1 - x0));
};
export const quadrant = (x, y, originX, originY) => {
    if (x >= originX && y <= originY)
        return 1;
    if (x <= originX && y <= originY)
        return 2;
    if (x <= originX && y >= originY)
        return 3;
    return 4;
};
export const endPoint = (x, y, theta, dist) => {
    const rad = theta *= deg2Rad;
    return new Point(x + dist * Math.cos(rad), y + dist * Math.sin(rad));
};
export const polygonArea = (xList, yList) => {
    const n = xList.length;
    let area = 0;
    let j = n - 1;
    for (let i = 0; i < n; i++) {
        area += (xList[j] + xList[i]) * (yList[j] - yList[i]);
        j = i;
    }
    return Math.abs(area / 2.0);
};
export class UnitBezier {
    constructor(p1x, p1y, p2x, p2y) {
        this.epsilon = 1e-6;
        this.cx = 3.0 * p1x, this.bx = 3.0 * (p2x - p1x) - this.cx, this.ax = 1.0 - this.cx - this.bx;
        this.cy = 3.0 * p1y, this.by = 3.0 * (p2y - p1y) - this.cy, this.ay = 1.0 - this.cy - this.by;
    }
    sampleCurveX(t) {
        return ((this.ax * t + this.bx) * t + this.cx) * t;
    }
    sampleCurveY(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
    }
    sampleCurveDerivativeX(t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
    }
    solveCurveX(x) {
        let t0, t1, t2, x2, d2, i;
        for (t2 = x, i = 0; i < 8; ++i) {
            x2 = this.sampleCurveX(t2) - x;
            if (Math.abs(x2) < this.epsilon)
                return t2;
            d2 = this.sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < this.epsilon)
                break;
            t2 = t2 - x2 / d2;
        }
        t0 = 0.0, t1 = 1.0, t2 = x;
        if (t2 < t0)
            return t0;
        else if (t2 > t1)
            return t1;
        while (t0 < t1) {
            x2 = this.sampleCurveX(t2);
            if (Math.abs(x2 - x) < this.epsilon)
                return t2;
            if (x > x2)
                t0 = t2;
            else
                t1 = t2;
            t2 = (t1 - t0) * 0.5 + t0;
        }
        return t2;
    }
    solve(x) {
        return this.sampleCurveY(this.solveCurveX(x));
    }
}
export class PerspectiveTransform {
    constructor() {
        this.srcX = [];
        this.srcY = [];
        this.dstX = [];
        this.dstY = [];
        this.srcMat = [];
        this.dstMat = [];
        this.warpMat = [];
        this.dirty = false;
    }
    setSource(x0, y0, x1, y1, x2, y2, x3, y3) {
        this.srcX[0] = x0, this.srcY[0] = y0, this.srcX[1] = x1, this.srcY[1] = y1;
        this.srcX[2] = x2, this.srcY[2] = y2, this.srcX[3] = x3, this.srcY[3] = y3;
        this.dirty = true;
    }
    setDestination(x0, y0, x1, y1, x2, y2, x3, y3) {
        this.dstX[0] = x0, this.dstY[0] = y0, this.dstX[1] = x1, this.dstY[1] = y1;
        this.dstX[2] = x2, this.dstY[2] = y2, this.dstX[3] = x3, this.dstY[3] = y3;
        this.dirty = true;
    }
    computeSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3, mat) {
        const dx1 = x1 - x2, dy1 = y1 - y2;
        const dx2 = x3 - x2, dy2 = y3 - y2;
        const sx = x0 - x1 + x2 - x3, sy = y0 - y1 + y2 - y3;
        const g = (sx * dy2 - dx2 * sy) / (dx1 * dy2 - dx2 * dy1);
        const h = (dx1 * sy - sx * dy1) / (dx1 * dy2 - dx2 * dy1);
        const a = x1 - x0 + g * x1, b = x3 - x0 + h * x3;
        const c = x0, d = y1 - y0 + g * y1, e = y3 - y0 + h * y3, f = y0;
        mat[0] = a, mat[1] = d, mat[2] = 0, mat[3] = g;
        mat[4] = b, mat[5] = e, mat[6] = 0, mat[7] = h;
        mat[8] = 0, mat[9] = 0, mat[10] = 1, mat[11] = 0;
        mat[12] = c, mat[13] = f, mat[14] = 0, mat[15] = 1;
    }
    computeQuadToSquare(x0, y0, x1, y1, x2, y2, x3, y3, mat) {
        this.computeSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3, mat);
        const a = mat[0], d = mat[1], g = mat[3], b = mat[4];
        const e = mat[5], h = mat[7], c = mat[12], f = mat[13];
        const A = e - f * h, B = c * h - b, C = b * f - c * e;
        const D = f * g - d, E = a - c * g, F = c * d - a * f;
        const G = d * h - e * g, H = b * g - a * h, I = a * e - b * d;
        const id = 1 / (a * A + b * D + c * G);
        mat[0] = A * id, mat[1] = D * id, mat[2] = 0, mat[3] = G * id;
        mat[4] = B * id, mat[5] = E * id, mat[6] = 0, mat[7] = H * id;
        mat[8] = 0, mat[9] = 0, mat[10] = 1, mat[11] = 0;
        mat[12] = C * id, mat[13] = F * id, mat[14] = 0, mat[15] = I * id;
    }
    multMats(srcMat, dstMat, resMat) {
        for (let r = 0; r < 4; ++r) {
            const ri = r * 4;
            for (let c = 0; c < 4; ++c)
                resMat[ri + c] = srcMat[ri] * dstMat[c] +
                    srcMat[ri + 1] * dstMat[c + 4] +
                    srcMat[ri + 2] * dstMat[c + 8] +
                    srcMat[ri + 3] * dstMat[c + 12];
        }
    }
    computeWarp() {
        this.computeQuadToSquare(this.srcX[0], this.srcY[0], this.srcX[1], this.srcY[1], this.srcX[2], this.srcY[2], this.srcX[3], this.srcY[3], this.srcMat);
        this.computeSquareToQuad(this.dstX[0], this.dstY[0], this.dstX[1], this.dstY[1], this.dstX[2], this.dstY[2], this.dstX[3], this.dstY[3], this.dstMat);
        this.multMats(this.srcMat, this.dstMat, this.warpMat);
        this.dirty = false;
    }
    warp(mat, srcX, srcY) {
        const result = [], z = 0;
        result[0] = srcX * mat[0] + srcY * mat[4] + z * mat[8] + mat[12];
        result[1] = srcX * mat[1] + srcY * mat[5] + z * mat[9] + mat[13];
        result[2] = srcX * mat[2] + srcY * mat[6] + z * mat[10] + mat[14];
        result[3] = srcX * mat[3] + srcY * mat[7] + z * mat[11] + mat[15];
        return new Point(result[0] / result[3], result[1] / result[3]);
    }
    solve(srcX, srcY) {
        if (this.dirty)
            this.computeWarp();
        return this.warp(this.warpMat, srcX, srcY);
    }
}
export class LowPassFilter {
    constructor(alpha = 0.5, maxDelta = Infinity) {
        this.alpha = alpha;
        this.maxDelta = maxDelta;
    }
    next(n, alpha = this.alpha, maxDelta = this.maxDelta) {
        if (this.nOld == null)
            this.nOld = n;
        let delta = (n - this.nOld) * alpha;
        if (Math.abs(delta) > maxDelta)
            delta = maxDelta * (delta < 0 ? -1 : 1);
        let result = this.nOld + delta;
        if (result < 0.00001 && result > -0.00001)
            result = 0;
        return this.nOld = result;
    }
}
