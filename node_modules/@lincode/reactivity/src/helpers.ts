import { omit as omit0, merge as merge0, filter as filter0, valueof, traverse } from "@lincode/utils"
import { SetGlobalState, GetGlobalState } from "./store"

export const assign = <T extends Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => (val: Partial<T>) => {
    const state = getState()
    if (state && Object.entries(val).some(([key, value]) => state[key] !== value))
        setState({ ...state, ...val })
}

export const merge = <T extends Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => (val: Partial<T>) => {
    const state = getState()
    state && setState(merge0(state, val))
}

export const omit = <T extends Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => (val: keyof T | Array<keyof T>) => {
    const state = getState()
    //@ts-ignore
    state && setState(omit0(state, val))
}

type Filter = {
    <T extends Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>): (predicate: (v: valueof<T>, k: keyof T) => boolean) => void
    <T>(setState: SetGlobalState<Array<T>>, getState: GetGlobalState<Array<T>>): (predicate: (v: T, i: number) => boolean) => void
}

export const filter: Filter = (setState: SetGlobalState<any>, getState: GetGlobalState<any>) => (predicate: (v: any, k: any) => boolean) => {
    const state = getState()
    if (!state) return

    if (Array.isArray(state))
        setState(state.filter(predicate))
    else
        setState(filter0(state, predicate))
}

export const rename = <T extends Record<any, any> | Array<string> | string | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => (from: string, to: string) => {
    const state = getState()
    if (!state) return

    if (typeof state === "string") {
        //@ts-ignore
        state === from && setState(to)
        return
    }

    if (Array.isArray(state)) {
        let update = false
        const newState = state.map(val => {
            if (val === from) {
                update = true
                return to
            }
            return val
        })
        //@ts-ignore
        update && setState(newState)
        return
    }

    if (!(from in state)) return

    //@ts-ignore
    setState(Object.assign(omit0(state, from), { [to]: state[from] }))
}

export const renameStartsWith = <T extends Record<any, any> | Array<string> | string | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => (from: string, to: string) => {
    const state = getState()
    if (!state) return

    if (typeof state === "string") {
        //@ts-ignore
        state.startsWith(from) && setState(state.replace(from, to))
        return
    }

    if (Array.isArray(state)) {
        let update = false
        const newState = state.map(val => {
            if (val.startsWith(from)) {
                update = true
                return val.replace(from, to)
            }
            return val
        })
        //@ts-ignore
        update && setState(newState)
        return
    }

    const replaced: Record<string, valueof<T>> = {}
    const filtered = filter0(state, (v, k) => {
        //@ts-ignore
        const replace = k.startsWith(from)
        //@ts-ignore
        replace && (replaced[k.replace(from, to)] = v)
        return !replace
    })
    
    if (Object.keys(replaced).length === 0) return

    //@ts-ignore
    setState(Object.assign(filtered, replaced))
}

export const push = <A>(setState: SetGlobalState<Array<A>>, getState: GetGlobalState<Array<A> | undefined>) => (val: A) => {
    const array = getState()
    array && setState([...array, val])
}

export const pull = <A>(setState: SetGlobalState<Array<A>>, getState: GetGlobalState<Array<A> | undefined>) => (val: A) => {
    const array = getState()
    array && setState(array.filter(item => item !== val))
}

export const concat = <A>(setState: SetGlobalState<Array<A>>, getState: GetGlobalState<Array<A> | undefined>) => (val: Array<A>) => {
    const array = getState()
    array && setState([...array, ...val])
}

export const refresh = <T extends Array<any> | Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => () => {
    const state = getState()
    if (!state) return

    if (Array.isArray(state))
        //@ts-ignore
        setState([...state])
    else
        setState({...state})
}

export const reset = <T extends Array<any> | Record<any, any> | undefined>(setState: SetGlobalState<T>, getState: GetGlobalState<T>) => {
    const state = getState()

    if (state && typeof state === "object") {
        traverse(state, (_, v) => Object.freeze(v))
        Object.freeze(state)
    }
    return () => setState(state)
}