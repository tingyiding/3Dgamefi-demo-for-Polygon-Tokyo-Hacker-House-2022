import { Cancellable } from "@lincode/promiselikes"
import { debounce } from "@lincode/utils"
import { GetGlobalState } from "./store"

const fiberStack: Array<{ count: number, fiber: Array<any>, handle: Cancellable }> = []

const fiberCache = <T>(value: () => T): T => {
    const store = fiberStack[fiberStack.length - 1]
    return store.fiber[store.count++] ??= value()
}

const fiberStore = <T>(value: T): [() => T, (val: T) => void] => {
    const store = fiberStack[fiberStack.length - 1]
    const index = store.count++
    store.fiber[index] ??= value
    return [
        () => store.fiber[index],
        (val: T) => store.fiber[index] = val
    ]
}

const diffAndRun = (
    handle: Cancellable,
    cleanup: (() => void) | undefined,
    fiber: Array<any>,
    getStates: Array<GetGlobalState<any> | any>,
    statesOld: Array<any> | undefined,
    cb: () => (() => void) | void
) => {
    fiberStack.push({ count: 0, fiber, handle })
    const states = getStates.map(s => typeof s === "function" ? s() : s)
    const shouldRun = !statesOld || states.some((s, i) => s !== statesOld![i])
    shouldRun && typeof cleanup === "function" && cleanup()
    const result = shouldRun ? cb() : undefined
    fiberStack.pop()

    return <const>[result, states, shouldRun]
}

export const createNestedEffect = (
    cb: () => (() => void) | void,
    getStates: Array<GetGlobalState<any> | any>
) => {
    const handle = fiberCache(() => {
        const parentHandle = fiberStack[fiberStack.length - 1].handle
        return parentHandle.watch(new Cancellable(() => getCleanUp()?.()))
    })
    if (handle.done) return handle

    const fiber: Array<any> = fiberCache(() => [])

    const [getCleanUp, setCleanUp] = fiberStore<(() => void) | undefined>(undefined)
    const [getStatesOld, setStatesOld] = fiberStore<Array<any> | undefined>(undefined)

    const cleanup = getCleanUp()
    const statesOld = getStatesOld()

    if (cleanup && typeof cleanup !== "function")
        console.warn("cleanup is not a function")

    const [result, states, shouldRun] = diffAndRun(handle, cleanup, fiber, getStates, statesOld, cb)

    shouldRun && setCleanUp(typeof result === "function" ? result : undefined)
    setStatesOld(states)

    return handle
}

export const createEffect = (
    cb: () => (() => void) | void,
    getStates: Array<GetGlobalState<any> | any>
) => {
    const handle = new Cancellable(() => setTimeout(() => cleanup?.()))
    const fiber: Array<any> = []
    
    let cleanup: (() => void) | undefined
    let statesOld: Array<any> | undefined

    const rerun = debounce(() => {
        const [result, states, shouldRun] = diffAndRun(handle, cleanup, fiber, getStates, statesOld, cb)

        shouldRun && (cleanup = typeof result === "function" ? result : undefined)
        statesOld = states

    }, 0, "trailing")
    
    rerun()
    
    for (const getState of getStates)
        typeof getState === "function" && handle.watch(getState(rerun))

    return handle
}

export const createRef = <T>(value?: T | (() => T)): { current: T } => {
    const store = fiberStack[fiberStack.length - 1]
    //@ts-ignore
    return store.fiber[store.count++] ??= { current: typeof value === "function" ? value() : value }
}

export const createPrevious = <T>(value: T) => {
    const valueRef = createRef(value)

    createEffect(() => {
        queueMicrotask(() => valueRef.current = value)
    }, [value])

    return valueRef.current
}

export const createMemo = <T>(
    value: () => T,
    getStates: Array<GetGlobalState<any> | any>
) => {
    const valueRef = createRef(value)

    createEffect(() => {
        valueRef.current = value()
    }, getStates)

    return valueRef.current
}