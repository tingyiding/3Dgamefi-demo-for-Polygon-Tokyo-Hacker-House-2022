import { Cancellable } from "@lincode/promiselikes";
import { debounce } from "@lincode/utils";
const fiberStack = [];
const fiberCache = (value) => {
    var _a;
    var _b, _c;
    const store = fiberStack[fiberStack.length - 1];
    return (_a = (_b = store.fiber)[_c = store.count++]) !== null && _a !== void 0 ? _a : (_b[_c] = value());
};
const fiberStore = (value) => {
    var _a;
    var _b;
    const store = fiberStack[fiberStack.length - 1];
    const index = store.count++;
    (_a = (_b = store.fiber)[index]) !== null && _a !== void 0 ? _a : (_b[index] = value);
    return [
        () => store.fiber[index],
        (val) => store.fiber[index] = val
    ];
};
const diffAndRun = (handle, cleanup, fiber, getStates, statesOld, cb) => {
    fiberStack.push({ count: 0, fiber, handle });
    const states = getStates.map(s => typeof s === "function" ? s() : s);
    const shouldRun = !statesOld || states.some((s, i) => s !== statesOld[i]);
    shouldRun && typeof cleanup === "function" && cleanup();
    const result = shouldRun ? cb() : undefined;
    fiberStack.pop();
    return [result, states, shouldRun];
};
export const createNestedEffect = (cb, getStates) => {
    const handle = fiberCache(() => {
        const parentHandle = fiberStack[fiberStack.length - 1].handle;
        return parentHandle.watch(new Cancellable(() => { var _a; return (_a = getCleanUp()) === null || _a === void 0 ? void 0 : _a(); }));
    });
    if (handle.done)
        return handle;
    const fiber = fiberCache(() => []);
    const [getCleanUp, setCleanUp] = fiberStore(undefined);
    const [getStatesOld, setStatesOld] = fiberStore(undefined);
    const cleanup = getCleanUp();
    const statesOld = getStatesOld();
    if (cleanup && typeof cleanup !== "function")
        console.warn("cleanup is not a function");
    const [result, states, shouldRun] = diffAndRun(handle, cleanup, fiber, getStates, statesOld, cb);
    shouldRun && setCleanUp(typeof result === "function" ? result : undefined);
    setStatesOld(states);
    return handle;
};
export const createEffect = (cb, getStates) => {
    const handle = new Cancellable(() => setTimeout(() => cleanup === null || cleanup === void 0 ? void 0 : cleanup()));
    const fiber = [];
    let cleanup;
    let statesOld;
    const rerun = debounce(() => {
        const [result, states, shouldRun] = diffAndRun(handle, cleanup, fiber, getStates, statesOld, cb);
        shouldRun && (cleanup = typeof result === "function" ? result : undefined);
        statesOld = states;
    }, 0, "trailing");
    rerun();
    for (const getState of getStates)
        typeof getState === "function" && handle.watch(getState(rerun));
    return handle;
};
export const createRef = (value) => {
    var _a;
    var _b, _c;
    const store = fiberStack[fiberStack.length - 1];
    //@ts-ignore
    return (_a = (_b = store.fiber)[_c = store.count++]) !== null && _a !== void 0 ? _a : (_b[_c] = { current: typeof value === "function" ? value() : value });
};
export const createPrevious = (value) => {
    const valueRef = createRef(value);
    createEffect(() => {
        queueMicrotask(() => valueRef.current = value);
    }, [value]);
    return valueRef.current;
};
export const createMemo = (value, getStates) => {
    const valueRef = createRef(value);
    createEffect(() => {
        valueRef.current = value();
    }, getStates);
    return valueRef.current;
};
