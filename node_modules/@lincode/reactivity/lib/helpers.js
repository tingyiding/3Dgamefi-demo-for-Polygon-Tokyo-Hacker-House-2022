import { omit as omit0, merge as merge0, filter as filter0, traverse } from "@lincode/utils";
export const assign = (setState, getState) => (val) => {
    const state = getState();
    if (state && Object.entries(val).some(([key, value]) => state[key] !== value))
        setState({ ...state, ...val });
};
export const merge = (setState, getState) => (val) => {
    const state = getState();
    state && setState(merge0(state, val));
};
export const omit = (setState, getState) => (val) => {
    const state = getState();
    //@ts-ignore
    state && setState(omit0(state, val));
};
export const filter = (setState, getState) => (predicate) => {
    const state = getState();
    if (!state)
        return;
    if (Array.isArray(state))
        setState(state.filter(predicate));
    else
        setState(filter0(state, predicate));
};
export const rename = (setState, getState) => (from, to) => {
    const state = getState();
    if (!state)
        return;
    if (typeof state === "string") {
        //@ts-ignore
        state === from && setState(to);
        return;
    }
    if (Array.isArray(state)) {
        let update = false;
        const newState = state.map(val => {
            if (val === from) {
                update = true;
                return to;
            }
            return val;
        });
        //@ts-ignore
        update && setState(newState);
        return;
    }
    if (!(from in state))
        return;
    //@ts-ignore
    setState(Object.assign(omit0(state, from), { [to]: state[from] }));
};
export const renameStartsWith = (setState, getState) => (from, to) => {
    const state = getState();
    if (!state)
        return;
    if (typeof state === "string") {
        //@ts-ignore
        state.startsWith(from) && setState(state.replace(from, to));
        return;
    }
    if (Array.isArray(state)) {
        let update = false;
        const newState = state.map(val => {
            if (val.startsWith(from)) {
                update = true;
                return val.replace(from, to);
            }
            return val;
        });
        //@ts-ignore
        update && setState(newState);
        return;
    }
    const replaced = {};
    const filtered = filter0(state, (v, k) => {
        //@ts-ignore
        const replace = k.startsWith(from);
        //@ts-ignore
        replace && (replaced[k.replace(from, to)] = v);
        return !replace;
    });
    if (Object.keys(replaced).length === 0)
        return;
    //@ts-ignore
    setState(Object.assign(filtered, replaced));
};
export const push = (setState, getState) => (val) => {
    const array = getState();
    array && setState([...array, val]);
};
export const pull = (setState, getState) => (val) => {
    const array = getState();
    array && setState(array.filter(item => item !== val));
};
export const concat = (setState, getState) => (val) => {
    const array = getState();
    array && setState([...array, ...val]);
};
export const refresh = (setState, getState) => () => {
    const state = getState();
    if (!state)
        return;
    if (Array.isArray(state))
        //@ts-ignore
        setState([...state]);
    else
        setState({ ...state });
};
export const reset = (setState, getState) => {
    const state = getState();
    if (state && typeof state === "object") {
        traverse(state, (_, v) => Object.freeze(v));
        Object.freeze(state);
    }
    return () => setState(state);
};
