import { pull } from "@lincode/utils";
class Thenable {
    constructor(_cb = undefined) {
        this._cb = _cb;
        this.done = undefined;
        this._value = undefined;
        this._callbacks = undefined;
        this._watched = undefined;
    }
    then(cb) {
        var _a;
        if (this.done) {
            cb(this._value);
            return cancelled;
        }
        ;
        ((_a = this._callbacks) !== null && _a !== void 0 ? _a : (this._callbacks = new Set())).add(cb);
        return new Cancellable(() => this._callbacks.delete(cb));
    }
    watch(item) {
        var _a;
        if (this.done)
            return item._resolve(this._value);
        ((_a = this._watched) !== null && _a !== void 0 ? _a : (this._watched = new Set())).add(item);
        item.then(() => this._watched.delete(item));
        return item;
    }
    _resolve(val) {
        var _a;
        if (this.done)
            return this;
        this.done = true;
        this._value = val;
        (_a = this._cb) === null || _a === void 0 ? void 0 : _a.call(this, val);
        if (this._callbacks)
            for (const cb of this._callbacks)
                cb(val);
        if (this._watched)
            for (const item of this._watched)
                item._resolve(val);
        return this;
    }
}
export class Resolvable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    resolve(val) {
        return this._resolve(val);
    }
}
export class Cancellable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    cancel() {
        return this._resolve();
    }
}
export class Disposable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    _resolve() {
        this.dispose();
        return this;
    }
    dispose() {
        return super._resolve();
    }
}
const cancelled = new Cancellable().cancel();
export class Queue {
    constructor() {
        this.queue = [];
        this.count = 0;
    }
    then(cb) {
        if ((this.count++) === 0) {
            cb();
            return cancelled;
        }
        this.queue.push(cb);
        return new Cancellable(() => pull(this.queue, cb));
    }
    resolve() {
        var _a;
        this.count--;
        (_a = this.queue.shift()) === null || _a === void 0 ? void 0 : _a();
        return this;
    }
}
