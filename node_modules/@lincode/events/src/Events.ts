import { Cancellable } from "@lincode/promiselikes"
import { forceGet } from "@lincode/utils"

export default class <Payload = void, Names extends string = string> {
    private cbsMap = new Map<string, Set<(val: Payload) => void>>()
    private states?: Map<string, Payload>

    public on(name: Names | Array<Names>, cb: (val: Payload) => void): Cancellable {
        if (Array.isArray(name)) {
            const handle = new Cancellable()
            for (const n of name)
                handle.watch(this.on(n, cb))

            return handle
        }
        if (this.states?.has(name))
            cb(this.states.get(name)!)

        const cbs = forceGet(this.cbsMap, name, () => new Set<(val: Payload) => void>())
        
        cbs.add(cb)
        return new Cancellable(() => cbs.delete(cb))
    }
    
    public once(name: Names | Array<Names>, cb: (val: Payload) => void): Cancellable {
        const handle = new Cancellable()
        handle.watch(this.on(name, value => {
            handle.cancel()
            cb(value)
        }))
        return handle
    }

    public emit(name: Names, value: Payload): void {
        if (this.cbsMap.has(name))
            for (const cb of this.cbsMap.get(name)!)
                cb(value)
    }

    public hasState(name: Names): boolean {
        return !!this.states?.has(name)
    }

    public setState(name: Names, value: Payload): void {
        this.states ??= new Map()
        if (this.states.has(name) && this.states.get(name) === value) return
        this.states.set(name, value)
        this.emit(name, value)
    }

    public getState(name: Names): Payload | undefined {
        return this.states?.get(name)
    }

    public deleteState(name: Names): void {
        this.states?.delete(name)
    }

    public clear(): void {
        this.cbsMap.clear()
        this.states?.clear()
    }
}