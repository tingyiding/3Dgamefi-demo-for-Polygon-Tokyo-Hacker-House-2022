import { useFileDrop } from ".";
const getAllFileEntries = async (dataTransferItemList) => {
    if (!dataTransferItemList)
        return [];
    const fileEntries = [];
    const queue = [];
    for (let i = 0; i < dataTransferItemList.length; i++)
        queue.push(dataTransferItemList[i].webkitGetAsEntry());
    while (queue.length > 0) {
        const entry = queue.shift();
        if (!entry)
            continue;
        if (entry.isFile)
            fileEntries.push(entry);
        else if (entry.isDirectory) {
            const entries = await readAllDirectoryEntries(entry.createReader());
            queue.push(...entries);
        }
    }
    return fileEntries;
};
const readAllDirectoryEntries = async (directoryReader) => {
    const entries = [];
    let readEntries = await readEntriesPromise(directoryReader);
    while (readEntries.length > 0) {
        entries.push(...readEntries);
        readEntries = await readEntriesPromise(directoryReader);
    }
    return entries;
};
const readEntriesPromise = (directoryReader) => {
    return new Promise((resolve, reject) => {
        directoryReader.readEntries(resolve, reject);
    });
};
const getFile = (fileEntry) => new Promise((resolve, reject) => fileEntry.file(resolve, reject));
export default (cb, disabled) => {
    const [setDropEl, dragOver] = useFileDrop(e => {
        if (e.dataTransfer && [...e.dataTransfer.items].some(item => item.kind !== "file")) {
            cb(e, []);
            return;
        }
        (async () => {
            var _a;
            const fileEntries = await getAllFileEntries((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.items);
            const fileData = [];
            for (const fileEntry of fileEntries)
                fileData.push({ fullPath: fileEntry.fullPath, file: await getFile(fileEntry) });
            cb(e, fileData);
        })();
    }, disabled);
    return [setDropEl, dragOver];
};
