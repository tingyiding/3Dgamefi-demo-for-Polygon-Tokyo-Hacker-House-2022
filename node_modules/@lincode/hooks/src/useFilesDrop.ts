import { useFileDrop } from "."

const getAllFileEntries = async (dataTransferItemList?: DataTransferItemList) => {
    if (!dataTransferItemList) return []

	const fileEntries: Array<any> = []
	const queue: Array<any> = []
	for (let i = 0; i < dataTransferItemList.length; i++)
		queue.push(dataTransferItemList[i].webkitGetAsEntry())

	while (queue.length > 0) {
		const entry = queue.shift()
		if (!entry) continue
		
		if (entry.isFile)
			fileEntries.push(entry)
		else if (entry.isDirectory) {
            const entries = await readAllDirectoryEntries(entry.createReader())
			queue.push(...entries)
        }
	}
	return fileEntries
}

const readAllDirectoryEntries = async (directoryReader: any) => {
	const entries: Array<any> = []
	let readEntries = await readEntriesPromise(directoryReader)
	while (readEntries.length > 0) {
		entries.push(...readEntries)
		readEntries = await readEntriesPromise(directoryReader)
	}
	return entries
}

const readEntriesPromise = (directoryReader: any) => {
    return new Promise<Array<any>>((resolve, reject) => {
        directoryReader.readEntries(resolve, reject)
    })
}

const getFile = (fileEntry: any) => new Promise<File>((resolve, reject) => fileEntry.file(resolve, reject))

type FileData = { fullPath: string, file: File }

export default (cb: (e: DragEvent, fileData: Array<FileData>) => void, disabled?: boolean) => {
    const [setDropEl, dragOver] = useFileDrop(e => {
		if (e.dataTransfer && [...e.dataTransfer.items].some(item => item.kind !== "file")) {
			cb(e, [])
			return
		}
		(async () => {
			const fileEntries = await getAllFileEntries(e.dataTransfer?.items)

			const fileData: Array<FileData> = []
			for (const fileEntry of fileEntries)
				fileData.push({ fullPath: fileEntry.fullPath, file: await getFile(fileEntry) })

			cb(e, fileData)
		})()
		
    }, disabled)

    return <const>[setDropEl, dragOver]
}