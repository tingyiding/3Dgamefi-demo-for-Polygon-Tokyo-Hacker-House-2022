import { jsx as _jsx, jsxs as _jsxs } from "preact/jsx-runtime";
import { preventTreeShake } from "@lincode/utils";
import { Fragment, h } from "preact";
import { useEffect, useState } from "preact/hooks";
import Loaded from "../../display/core/Loaded";
import { isMeshItem } from "../../display/core/MeshItem";
import Dummy, { dummyTypeMap } from "../../display/Dummy";
import { onSelectionTarget } from "../../events/onSelectionTarget";
import { DUMMY_URL, YBOT_URL } from "../../globals";
import { setSceneGraphExpanded } from "../../states/useSceneGraphExpanded";
import { setSceneGraphTarget } from "../../states/useSceneGraphTarget";
import { addSelectionFrozen, clearSelectionFrozen } from "../../states/useSelectionFrozen";
import downloadBlob from "../../utils/downloadBlob";
import { useSelectionFrozen, useSelectionTarget } from "../states";
preventTreeShake(h);
const traverseUp = (obj, expandedSet) => {
    expandedSet.add(obj);
    const nextParent = obj.userData.manager?.parent?.outerObject3d ?? obj.parent;
    nextParent && traverseUp(nextParent, expandedSet);
};
const search = (n, target) => {
    const name = n.toLowerCase();
    let found;
    if (target instanceof Loaded)
        target.loadedGroup.traverse(item => {
            if (found)
                return;
            item.name.toLowerCase().includes(name) && (found = item);
        });
    else
        target.outerObject3d.traverse(item => {
            if (found)
                return;
            item.name.toLowerCase().includes(name) && (found = item);
        });
    if (!found)
        return;
    const expandedSet = new Set();
    traverseUp(found, expandedSet);
    setSceneGraphExpanded(expandedSet);
    setSceneGraphTarget(found);
};
const MenuItem = ({ disabled, onClick, children }) => {
    const [hover, setHover] = useState(false);
    return (_jsx("div", { style: {
            padding: 6,
            whiteSpace: "nowrap",
            background: !disabled && hover ? "rgba(255, 255, 255, 0.1)" : undefined,
            opacity: disabled ? 0.5 : 1
        }, onClick: disabled ? undefined : onClick, onMouseEnter: disabled ? undefined : () => setHover(true), onMouseLeave: disabled ? undefined : () => setHover(false), children: children }));
};
const ContextMenu = () => {
    const [data, setData] = useState(undefined);
    const [showSearch, setShowSearch] = useState(false);
    const [selectionTarget] = useSelectionTarget();
    const [[selectionFrozen]] = useSelectionFrozen();
    useEffect(() => {
        let [clientX, clientY] = [0, 0];
        const cb = (e) => [clientX, clientY] = [e.clientX, e.clientY];
        document.addEventListener("mousemove", cb);
        const handle = onSelectionTarget(({ target, rightClick }) => {
            rightClick && setData({ x: clientX, y: clientY, target });
        });
        return () => {
            handle.cancel();
            document.removeEventListener("mousemove", cb);
        };
    }, []);
    useEffect(() => {
        !data && setShowSearch(false);
    }, [data]);
    if (!data)
        return null;
    return (_jsx("div", { className: "lingo3d-ui", onMouseDown: () => setData(undefined), style: {
            zIndex: 9999,
            position: "absolute",
            left: 0,
            top: 0,
            width: "100%",
            height: "100%",
            overflow: "hidden"
        }, children: _jsx("div", { onMouseDown: e => e.stopPropagation(), style: {
                position: "absolute",
                left: data.x,
                top: data.y,
                background: "rgb(40, 41, 46)",
                padding: 6
            }, children: showSearch ? (_jsx("input", { ref: el => el?.focus(), style: { all: "unset", padding: 6 }, onKeyDown: e => {
                    e.stopPropagation();
                    if (e.key !== "Enter" && e.key !== "Escape")
                        return;
                    e.key === "Enter" && selectionTarget && search(e.target.value, selectionTarget);
                    setData(undefined);
                } })) : _jsxs(Fragment, { children: [data.target && (_jsxs(Fragment, { children: [_jsx(MenuItem, { onClick: () => setShowSearch(true), children: "Search children" }), _jsx(MenuItem, { onClick: () => {
                                    isMeshItem(selectionTarget) && addSelectionFrozen(selectionTarget);
                                    setData(undefined);
                                }, children: "Freeze selection" }), selectionTarget instanceof Dummy && dummyTypeMap.has(selectionTarget) && (_jsx(MenuItem, { onClick: async () => {
                                    setData(undefined);
                                    const url = dummyTypeMap.get(selectionTarget) === "dummy"
                                        ? YBOT_URL
                                        : DUMMY_URL + "readyplayerme/reference.fbx";
                                    const res = await fetch(url);
                                    downloadBlob("model.fbx", await res.blob());
                                }, children: "Download for Mixamo" }))] })), _jsx(MenuItem, { disabled: !selectionFrozen.size, onClick: () => {
                            clearSelectionFrozen();
                            setData(undefined);
                        }, children: "Unfreeze all" })] }) }) }));
};
export default ContextMenu;
//# sourceMappingURL=ContextMenu.js.map