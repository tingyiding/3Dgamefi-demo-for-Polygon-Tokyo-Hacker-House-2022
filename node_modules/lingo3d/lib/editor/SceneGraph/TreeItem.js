import { jsx as _jsx, jsxs as _jsxs } from "preact/jsx-runtime";
import { h } from "preact";
import { useState, useEffect, useRef, useMemo } from "preact/hooks";
import { preventTreeShake } from "@lincode/utils";
import { hiddenAppendables } from "../../api/core/Appendable";
import CubeIcon from "./icons/CubeIcon";
import ExpandIcon from "./icons/ExpandIcon";
import CollapseIcon from "./icons/CollapseIcon";
import { useMultipleSelectionTargets, useSceneGraphExpanded, useSceneGraphPreventDrag, useSelectionTarget } from "../states";
import { emitEditorCenterView } from "../../events/onEditorCenterView";
import Model from "../../display/Model";
import ModelTreeItem from "./ModelTreeItem";
import { emitSelectionTarget } from "../../events/onSelectionTarget";
import useClick from "./useClick";
import { isPositionedItem } from "../../api/core/PositionedItem";
import { Object3D } from "three";
import { setSceneGraphTarget } from "../../states/useSceneGraphTarget";
import { getSelectionTarget } from "../../states/useSelectionTarget";
import mainOrbitCamera from "../../engine/mainOrbitCamera";
import getComponentName from "../getComponentName";
preventTreeShake(h);
export const makeTreeItemCallbacks = (target, parent) => {
    const setClickEl = useClick(e => {
        e.stopPropagation();
        mainOrbitCamera.activate();
        isPositionedItem(parent) && getSelectionTarget() !== parent && emitSelectionTarget(parent);
        if (target instanceof Object3D)
            queueMicrotask(() => setSceneGraphTarget(target));
        else
            emitSelectionTarget(target);
    });
    const handleClick = (e) => e.stopPropagation();
    const handleDoubleClick = (e) => {
        e.stopPropagation();
        if (!isPositionedItem(target))
            return;
        emitEditorCenterView(target);
        emitSelectionTarget(target);
    };
    return { setClickEl, handleClick, handleDoubleClick };
};
export const draggingItemPtr = [undefined];
const TreeItem = ({ appendable, level, children }) => {
    const name = getComponentName(appendable);
    const appendableChildren = useMemo(() => {
        return appendable.children ? [...appendable.children].filter(item => !hiddenAppendables.has(item)) : undefined;
    }, [appendable.children?.size]);
    const expandIconStyle = { opacity: (appendableChildren?.length || children) ? 0.5 : 0.05, cursor: "pointer" };
    const [dragOver, setDragOver] = useState(false);
    const [expanded, setExpanded] = useState(false);
    // const [expanded, setExpanded] = useState(!!appendableChildren?.length)
    const [selectionTarget] = useSelectionTarget();
    const [multipleSelectionTargets] = useMultipleSelectionTargets();
    const selected = selectionTarget === appendable || multipleSelectionTargets.includes(appendable);
    const { setClickEl, handleClick, handleDoubleClick } = makeTreeItemCallbacks(appendable);
    const [sceneGraphExpanded, setSceneGraphExpanded] = useSceneGraphExpanded();
    useEffect(() => {
        if (!sceneGraphExpanded)
            return;
        if (sceneGraphExpanded.has(appendable.outerObject3d))
            setExpanded(true);
    }, [sceneGraphExpanded]);
    const startRef = useRef(null);
    const endRef = useRef(null);
    const highlightWidth = useMemo(() => {
        if (!selected || !startRef.current || !endRef.current)
            return;
        const boundsStart = startRef.current.getBoundingClientRect();
        const boundsEnd = endRef.current.getBoundingClientRect();
        return boundsEnd.right - boundsStart.left + 4;
    }, [selected, expanded]);
    const [preventDrag] = useSceneGraphPreventDrag();
    return (_jsxs("div", { ref: setClickEl, onClick: handleClick, onDblClick: handleDoubleClick, draggable: !preventDrag, onDragStart: e => (e.stopPropagation(), draggingItemPtr[0] = appendable), onDragEnd: e => (e.stopPropagation(), draggingItemPtr[0] = undefined), onDragOver: e => {
            e.stopPropagation();
            e.preventDefault();
            if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
                return;
            setDragOver(true);
        }, onDragEnter: e => {
            e.stopPropagation();
            e.preventDefault();
            if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
                return;
            setDragOver(true);
        }, onDragLeave: e => {
            e.stopPropagation();
            if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
                return;
            setDragOver(false);
        }, onDrop: e => {
            e.stopPropagation();
            if (!draggingItemPtr[0] || draggingItemPtr[0] === appendable)
                return;
            setDragOver(false);
            appendable.attach(draggingItemPtr[0]);
        }, style: {
            color: "rgba(255, 255, 255, 0.75)",
            marginLeft: 8,
            borderLeft: "1px solid rgba(255, 255, 255, 0.05)",
            background: dragOver ? "rgba(255, 255, 255, 0.5)" : "none"
        }, children: [_jsxs("div", { ref: startRef, style: {
                    display: "flex",
                    alignItems: "center",
                    backgroundColor: selected ? "rgba(255, 255, 255, 0.1)" : undefined,
                    width: highlightWidth,
                    minWidth: "100%",
                    cursor: "default"
                }, children: [expanded ? (_jsx(CollapseIcon, { style: expandIconStyle, onClick: () => (setExpanded(false), setSceneGraphExpanded(undefined)) })) : (_jsx(ExpandIcon, { style: expandIconStyle, onClick: () => setExpanded(true) })), _jsx(CubeIcon, {}), _jsx("div", { ref: endRef, children: name })] }), expanded && appendableChildren?.map(childAppendable => (childAppendable instanceof Model ? (_jsx(ModelTreeItem, { appendable: childAppendable, level: level + 1 }, childAppendable.uuid)) : (_jsx(TreeItem, { appendable: childAppendable, level: level + 1 }, childAppendable.uuid)))), expanded && children] }));
};
export default TreeItem;
//# sourceMappingURL=TreeItem.js.map