import { Cancellable } from "@lincode/promiselikes";
import { createEffect } from "@lincode/reactivity";
import { timer } from "../../engine/eventLoop";
import { onBeforeRender } from "../../events/onBeforeRender";
import Appendable from "./Appendable";
export default class EventLoopItem extends Appendable {
    _proxy;
    get proxy() {
        return this._proxy;
    }
    set proxy(val) {
        if (this._proxy === val)
            return;
        //@ts-ignore
        this._proxy && (this._proxy.__target = undefined);
        this._proxy = val;
        //@ts-ignore
        val && (val.__target = this);
    }
    timer(time, repeat, cb) {
        return this.watch(timer(time, repeat, cb));
    }
    beforeRender(cb) {
        return this.watch(onBeforeRender(cb));
    }
    queueMicrotask(cb) {
        queueMicrotask(() => !this.done && cb());
    }
    cancellable(cb) {
        return this.watch(new Cancellable(cb));
    }
    createEffect(cb, getStates) {
        return this.watch(createEffect(cb, getStates));
    }
    handles;
    cancelHandle(name, lazyHandle) {
        const handles = this.handles ??= new Map();
        handles.get(name)?.cancel();
        if (!lazyHandle)
            return;
        const handle = lazyHandle();
        handles.set(name, handle);
        return handle;
    }
    dispose() {
        if (this.done)
            return this;
        super.dispose();
        if (this.handles)
            for (const handle of this.handles.values())
                handle.cancel();
        return this;
    }
    _onLoop;
    get onLoop() {
        return this._onLoop;
    }
    set onLoop(cb) {
        this._onLoop = cb;
        this.cancelHandle("onLoop", cb && (() => onBeforeRender(cb)));
    }
}
//# sourceMappingURL=EventLoopItem.js.map