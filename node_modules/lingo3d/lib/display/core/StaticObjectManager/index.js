import { distance3d, Point3d } from "@lincode/math";
import { Color, Matrix3, MeshStandardMaterial, MeshToonMaterial, PropertyBinding } from "three";
import { clickSet, mouseDownSet, mouseOutSet, mouseMoveSet, mouseOverSet, mouseUpSet } from "./raycast";
import { frustum, matrix4, ray, vector3, vector3_1, vector3_half } from "../../utils/reusables";
import { applyMixins, forceGet, throttle } from "@lincode/utils";
import { OBB } from "three/examples/jsm/math/OBB";
import { scaleDown, scaleUp } from "../../../engine/constants";
import { addBloom, deleteBloom } from "../../../engine/renderLoop/effectComposer/selectiveBloomPass/renderSelectiveBloom";
import worldToClient from "../../utils/worldToClient";
import { Cancellable } from "@lincode/promiselikes";
import { point2Vec, vec2Point } from "../../utils/vec2Point";
import { addSSR, deleteSSR } from "../../../engine/renderLoop/effectComposer/ssrPass";
import { addOutline, deleteOutline } from "../../../engine/renderLoop/effectComposer/outlinePass";
import getCenter from "../../utils/getCenter";
import EventLoopItem from "../../../api/core/EventLoopItem";
import AnimationMixin from "../mixins/AnimationMixin";
import { getObject3d } from "../MeshItem";
import { Reactive } from "@lincode/reactivity";
import copyStandard from "./applyMaterialProperties/copyStandard";
import copyToon from "./applyMaterialProperties/copyToon";
import { getCameraRendered } from "../../../states/useCameraRendered";
import { onBeforeRender } from "../../../events/onBeforeRender";
import diffQuaternions from "../../utils/diffQuaternions";
import getWorldPosition from "../../utils/getWorldPosition";
const thisOBB = new OBB();
const targetOBB = new OBB();
const updateFrustum = throttle(() => {
    const camera = getCameraRendered();
    frustum.setFromProjectionMatrix(matrix4.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
}, 200, "leading");
const forcePBRSet = new WeakSet();
const setNumber = (child, property, factor) => {
    const defaultValue = (child.userData[property] ??=
        child.material[property]);
    child.material[property] =
        factor === undefined
            ? defaultValue
            : (defaultValue || (forcePBRSet.has(child.material) ? 1 : 0)) *
                factor;
};
const setBoolean = (child, property, value) => {
    const defaultValue = (child.userData[property] ??=
        child.material[property]);
    child.material[property] = value === undefined ? defaultValue : value;
};
const setColor = (child, property, value) => {
    const defaultValue = (child.userData[property] ??=
        child.material[property]);
    child.material[property] = value === undefined ? defaultValue : value;
};
export const idMap = new Map();
const makeSet = () => new Set();
class StaticObjectManager extends EventLoopItem {
    object3d;
    constructor(object3d) {
        super(object3d);
        this.object3d = object3d;
    }
    dispose() {
        if (this.done)
            return this;
        super.dispose();
        this._id !== undefined && idMap.get(this._id).delete(this);
        return this;
    }
    _id;
    get id() {
        return this._id;
    }
    set id(val) {
        this._id !== undefined && idMap.get(this._id).delete(this);
        this._id = val;
        val !== undefined && forceGet(idMap, val, makeSet).add(this);
    }
    addToRaycastSet(set) {
        set.add(this.object3d);
        return new Cancellable(() => set.delete(this.object3d));
    }
    _onClick;
    get onClick() {
        return this._onClick;
    }
    set onClick(cb) {
        this._onClick = cb;
        this.cancelHandle("onClick", cb && (() => this.addToRaycastSet(clickSet)));
    }
    _onMouseDown;
    get onMouseDown() {
        return this._onMouseDown;
    }
    set onMouseDown(cb) {
        this._onMouseDown = cb;
        this.cancelHandle("onMouseDown", cb && (() => this.addToRaycastSet(mouseDownSet)));
    }
    _onMouseUp;
    get onMouseUp() {
        return this._onMouseUp;
    }
    set onMouseUp(cb) {
        this._onMouseUp = cb;
        this.cancelHandle("onMouseUp", cb && (() => this.addToRaycastSet(mouseUpSet)));
    }
    _onMouseOver;
    get onMouseOver() {
        return this._onMouseOver;
    }
    set onMouseOver(cb) {
        this._onMouseOver = cb;
        this.cancelHandle("onMouseOver", cb && (() => this.addToRaycastSet(mouseOverSet)));
    }
    _onMouseOut;
    get onMouseOut() {
        return this._onMouseOut;
    }
    set onMouseOut(cb) {
        this._onMouseOut = cb;
        this.cancelHandle("onMouseOut", cb && (() => this.addToRaycastSet(mouseOutSet)));
    }
    _onMouseMove;
    get onMouseMove() {
        return this._onMouseMove;
    }
    set onMouseMove(cb) {
        this._onMouseMove = cb;
        this.cancelHandle("onMouseMove", cb && (() => this.addToRaycastSet(mouseMoveSet)));
    }
    get name() {
        return this.outerObject3d.name;
    }
    set name(val) {
        this.outerObject3d.name = PropertyBinding.sanitizeNodeName(val);
    }
    getRay() {
        return ray.set(getWorldPosition(this.object3d), this.object3d.getWorldDirection(vector3));
    }
    pointAt(distance) {
        return vec2Point(this.getRay().at(distance * scaleDown, vector3));
    }
    rayIntersectsAt(target, maxDistance) {
        if (this.done)
            return undefined;
        if (target.done)
            return undefined;
        if (this === target)
            return undefined;
        targetOBB.set(getWorldPosition(target.object3d), vector3_half, new Matrix3().setFromMatrix4(target.object3d.matrixWorld));
        const vec = targetOBB.intersectRay(this.getRay(), vector3);
        if (!vec)
            return;
        if (maxDistance) {
            const { x, y, z } = getWorldPosition(this.object3d);
            if (distance3d(vec.x, vec.y, vec.z, x, y, z) * scaleUp >
                maxDistance)
                return;
        }
        return vec2Point(vec);
    }
    rayIntersects(target) {
        return !!this.rayIntersectsAt(target);
    }
    intersects(target) {
        if (this.done)
            return false;
        if (target.done)
            return false;
        if (this === target)
            return false;
        thisOBB.set(getWorldPosition(this.object3d), vector3_1.clone(), new Matrix3());
        thisOBB.applyMatrix4(this.object3d.matrixWorld);
        targetOBB.set(getWorldPosition(target.object3d), vector3_1.clone(), new Matrix3());
        targetOBB.applyMatrix4(target.object3d.matrixWorld);
        return thisOBB.intersectsOBB(targetOBB, 0);
    }
    get clientX() {
        return worldToClient(this.object3d).x;
    }
    get clientY() {
        return worldToClient(this.object3d).y;
    }
    get reflection() {
        return !!this.object3d.userData.ssr;
    }
    set reflection(val) {
        val && addSSR(this.object3d);
        this.cancelHandle("reflection", val && (() => new Cancellable(() => deleteSSR(this.object3d))));
    }
    get bloom() {
        return !!this.outerObject3d.userData.bloom;
    }
    set bloom(val) {
        val && addBloom(this.outerObject3d);
        this.cancelHandle("bloom", val &&
            (() => new Cancellable(() => deleteBloom(this.outerObject3d))));
    }
    get outline() {
        return !!this.object3d.userData.outline;
    }
    set outline(val) {
        val && addOutline(this.object3d);
        this.cancelHandle("outline", val && (() => new Cancellable(() => deleteOutline(this.object3d))));
    }
    _visible;
    get visible() {
        return this._visible !== false;
    }
    set visible(val) {
        this._visible = val;
        this.outerObject3d.visible = val;
    }
    get frustumCulled() {
        return this.outerObject3d.frustumCulled;
    }
    set frustumCulled(val) {
        this.outerObject3d.traverse((child) => (child.frustumCulled = val));
    }
    _refreshFactors;
    refreshFactors() {
        if (this._refreshFactors) {
            this._refreshFactors.set({});
            return;
        }
        this._refreshFactors = new Reactive({});
        this.createEffect(() => {
            const handle = new Cancellable();
            const { _toon, _pbr, _metalnessFactor, _roughnessFactor, _opacityFactor, _emissiveIntensityFactor, _emissiveColorFactor, _colorFactor } = this;
            this.outerObject3d.traverse((child) => {
                let { material } = child;
                if (!material)
                    return;
                Array.isArray(material) && (material = material[0]);
                if (_toon) {
                    child.material = new MeshToonMaterial();
                    copyToon(material, child.material);
                }
                else if (_pbr) {
                    forcePBRSet.add((child.material = new MeshStandardMaterial()));
                    copyStandard(material, child.material);
                }
                if (_metalnessFactor !== undefined)
                    setNumber(child, "metalness", _metalnessFactor !== 0 ? _metalnessFactor : undefined);
                if (_roughnessFactor !== undefined)
                    setNumber(child, "roughness", _roughnessFactor !== 1 ? _roughnessFactor : undefined);
                if (_opacityFactor !== undefined) {
                    setNumber(child, "opacity", _opacityFactor);
                    setBoolean(child, "transparent", _opacityFactor !== 1 ? true : undefined);
                }
                if (_emissiveIntensityFactor !== undefined)
                    setNumber(child, "emissiveIntensity", _emissiveIntensityFactor !== 1
                        ? _emissiveIntensityFactor
                        : undefined);
                if (_emissiveColorFactor !== undefined)
                    setColor(child, "emissive", _emissiveColorFactor !== "#000000"
                        ? new Color(_emissiveColorFactor)
                        : undefined);
                if (_colorFactor !== undefined)
                    setColor(child, "color", _colorFactor !== "#ffffff"
                        ? new Color(_colorFactor)
                        : undefined);
                handle.then(() => {
                    child.material.dispose();
                    child.material = material;
                });
            });
            return () => {
                handle.cancel();
            };
        }, [this._refreshFactors.get]);
    }
    _metalnessFactor;
    get metalnessFactor() {
        return this._metalnessFactor;
    }
    set metalnessFactor(val) {
        this._metalnessFactor = val;
        this.refreshFactors();
    }
    _roughnessFactor;
    get roughnessFactor() {
        return this._roughnessFactor;
    }
    set roughnessFactor(val) {
        this._roughnessFactor = val;
        this.refreshFactors();
    }
    _opacityFactor;
    get opacityFactor() {
        return this._opacityFactor;
    }
    set opacityFactor(val) {
        this._opacityFactor = val;
        this.refreshFactors();
    }
    _emissiveIntensityFactor;
    get emissiveIntensityFactor() {
        return this._emissiveIntensityFactor;
    }
    set emissiveIntensityFactor(val) {
        this._emissiveIntensityFactor = val;
        this.refreshFactors();
    }
    _emissiveColorFactor;
    get emissiveColorFactor() {
        return this._emissiveColorFactor;
    }
    set emissiveColorFactor(val) {
        this._emissiveColorFactor = val;
        this.refreshFactors();
    }
    _colorFactor;
    get colorFactor() {
        return this._colorFactor;
    }
    set colorFactor(val) {
        this._colorFactor = val;
        this.refreshFactors();
    }
    _toon;
    get toon() {
        return this._toon ?? false;
    }
    set toon(val) {
        this._toon = val;
        this.refreshFactors();
    }
    _pbr;
    get pbr() {
        return this._pbr ?? false;
    }
    set pbr(val) {
        this._pbr = val;
        this.refreshFactors();
    }
    get frustumVisible() {
        updateFrustum();
        return frustum.containsPoint(getCenter(this.object3d));
    }
    lookAt(a0, a1, a2) {
        if (typeof a0 === "number") {
            this.lookAt(new Point3d(a0, a1 === undefined
                ? this.outerObject3d.position.y * scaleUp
                : a1, a2));
            return;
        }
        if ("outerObject3d" in a0)
            this.outerObject3d.lookAt(getWorldPosition(getObject3d(a0)));
        else
            this.outerObject3d.lookAt(point2Vec(a0));
    }
    onLookToEnd;
    lookTo(a0, a1, a2, a3) {
        if (typeof a0 === "number") {
            this.lookTo(new Point3d(a0, a1 === undefined
                ? this.outerObject3d.position.y * scaleUp
                : a1, a2), a3);
            return;
        }
        const { quaternion } = this.outerObject3d;
        const quaternionOld = quaternion.clone();
        this.lookAt(a0);
        const quaternionNew = quaternion.clone();
        quaternion.copy(quaternionOld);
        this.cancelHandle("lookTo", () => onBeforeRender(() => {
            quaternion.slerp(quaternionNew, a1);
            const { x, y, z } = diffQuaternions(quaternion, quaternionNew);
            if (Math.abs(x) + Math.abs(y) + Math.abs(z) < 0.001) {
                this.cancelHandle("lookTo", undefined);
                this.onLookToEnd?.();
                quaternion.copy(quaternionNew);
            }
        }));
    }
}
applyMixins(StaticObjectManager, [AnimationMixin]);
export default StaticObjectManager;
//# sourceMappingURL=index.js.map