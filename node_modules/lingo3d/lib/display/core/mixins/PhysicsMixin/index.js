import cubeShape from "./cannon/shapes/cubeShape";
import { Cancellable } from "@lincode/promiselikes";
import { assertExhaustive } from "@lincode/utils";
import PositionedItem from "../../../../api/core/PositionedItem";
import { Point3d } from "@lincode/math";
export default class PhysicsMixin extends PositionedItem {
    _mAV;
    getMAV() {
        return this._mAV ??= new Point3d(Infinity, Infinity, Infinity);
    }
    get maxAngularVelocityX() {
        return this._mAV?.x ?? Infinity;
    }
    set maxAngularVelocityX(val) {
        this.getMAV().x = val;
    }
    get maxAngularVelocityY() {
        return this._mAV?.y ?? Infinity;
    }
    set maxAngularVelocityY(val) {
        this.getMAV().y = val;
    }
    get maxAngularVelocityZ() {
        return this._mAV?.z ?? Infinity;
    }
    set maxAngularVelocityZ(val) {
        this.getMAV().z = val;
    }
    _mV;
    getMV() {
        return this._mV ??= new Point3d(Infinity, Infinity, Infinity);
    }
    get maxVelocityX() {
        return this._mV?.x ?? Infinity;
    }
    set maxVelocityX(val) {
        this.getMV().x = val;
    }
    get maxVelocityY() {
        return this._mV?.y ?? Infinity;
    }
    set maxVelocityY(val) {
        this.getMV().y = val;
    }
    get maxVelocityZ() {
        return this._mV?.z ?? Infinity;
    }
    set maxVelocityZ(val) {
        this.getMV().z = val;
    }
    physicsUpdate;
    physicsRotate() {
        if (!this.physicsUpdate)
            return;
        const rotation = this.physicsUpdate.rotation ??= {};
        rotation.x = true;
        rotation.y = true;
        rotation.z = true;
    }
    physicsMove() {
        if (!this.physicsUpdate)
            return;
        const position = this.physicsUpdate.position ??= {};
        position.x = true;
        position.y = true;
        position.z = true;
    }
    physicsMoveXZ() {
        if (!this.physicsUpdate)
            return;
        const position = this.physicsUpdate.position ??= {};
        position.x = true;
        position.z = true;
    }
    cannonBody;
    applyForce(x, y, z) {
        setTimeout(() => this.cannonBody?.applyForce({ x, y, z }));
    }
    applyImpulse(x, y, z) {
        setTimeout(() => this.cannonBody?.applyImpulse({ x, y, z }));
    }
    applyLocalForce(x, y, z) {
        setTimeout(() => this.cannonBody?.applyLocalForce({ x, y, z }));
    }
    applyLocalImpulse(x, y, z) {
        setTimeout(() => this.cannonBody?.applyLocalImpulse({ x, y, z }));
    }
    applyTorque(x, y, z) {
        setTimeout(() => this.cannonBody?.applyTorque({ x, y, z }));
    }
    get velocity() {
        if (this.bvhVelocity)
            return this.bvhVelocity;
        if (this.cannonBody)
            return this.cannonBody.velocity;
        return new Point3d(0, 0, 0);
    }
    set velocity(val) {
        if (this.bvhVelocity)
            Object.assign(this.bvhVelocity, val);
        else if (this.cannonBody)
            Object.assign(this.cannonBody.velocity, val);
    }
    refreshCannon() {
        this.physicsUpdate && (this.physics = this._physics ?? false);
    }
    _noTumble;
    get noTumble() {
        return this._noTumble;
    }
    set noTumble(val) {
        this._noTumble = val;
        this.refreshCannon();
    }
    _slippery;
    get slippery() {
        return this._slippery;
    }
    set slippery(val) {
        this._slippery = val;
        this.refreshCannon();
    }
    _mass;
    get mass() {
        return this._mass;
    }
    set mass(val) {
        this._mass = val;
        this.refreshCannon();
    }
    _physicsGroup;
    get physicsGroup() {
        return this._physicsGroup;
    }
    set physicsGroup(val) {
        this._physicsGroup = val;
        this.refreshCannon();
    }
    _ignorePhysicsGroups;
    get ignorePhysicsGroups() {
        return this._ignorePhysicsGroups;
    }
    set ignorePhysicsGroups(val) {
        this._ignorePhysicsGroups = val;
        this.refreshCannon();
    }
    _physicsShape;
    get physicsShape() {
        return this._physicsShape ??= cubeShape;
    }
    set physicsShape(val) {
        this._physicsShape = val;
        this.refreshCannon();
    }
    bvhVelocity;
    bvhOnGround;
    bvhRadius;
    bvhHalfHeight;
    bvhMap;
    bvhCharacter;
    initPhysics(val, handle) {
        if (!val || handle.done)
            return;
        switch (val) {
            case true:
            case "2d":
                import("./enableCannon").then(module => module.default.call(this, handle));
                break;
            case "map":
                this.bvhMap = true;
                import("./enableBVHMap").then(module => module.default.call(this, handle, false));
                break;
            case "map-debug":
                this.bvhMap = true;
                import("./enableBVHMap").then(module => module.default.call(this, handle, true));
                break;
            case "character":
                this.bvhCharacter = true;
                import("./enableBVHCharacter").then(module => module.default.call(this, handle));
                break;
            default:
                assertExhaustive(val);
        }
    }
    _physics;
    get physics() {
        return this._physics ?? false;
    }
    set physics(val) {
        if (this._physics === val)
            return;
        this._physics = val;
        this.initPhysics(val, this.cancelHandle("physics", () => new Cancellable()));
    }
}
//# sourceMappingURL=index.js.map