import { rad2Deg, deg2Rad, distance3d } from "@lincode/math";
import { Vector3 } from "three";
import { vector3 } from "../../utils/reusables";
import { scaleDown, scaleUp } from "../../../engine/constants";
import { point2Vec } from "../../utils/vec2Point";
import getCenter from "../../utils/getCenter";
import PositionedItem from "../../../api/core/PositionedItem";
import StaticObjectManager, { idMap } from "../StaticObjectManager";
import { applyMixins } from "@lincode/utils";
import PhysicsMixin from "../mixins/PhysicsMixin";
import bvhContactMap from "../mixins/PhysicsMixin/bvh/bvhContactMap";
import { cannonContactBodies, cannonContactMap } from "../mixins/PhysicsMixin/cannon/cannonLoop";
import { Reactive } from "@lincode/reactivity";
import { getObject3d } from "../MeshItem";
import { onBeforeRender } from "../../../events/onBeforeRender";
import getWorldPosition from "../../utils/getWorldPosition";
import getWorldQuaternion from "../../utils/getWorldQuaternion";
const ptDistCache = new WeakMap();
const distance3dCached = (pt, vecSelf) => {
    const cached = ptDistCache.get(pt);
    if (cached)
        return cached;
    const result = distance3d(pt.x, pt.y, pt.z, vecSelf.x * scaleUp, vecSelf.y * scaleUp, vecSelf.z * scaleUp);
    ptDistCache.set(pt, result);
    return result;
};
class SimpleObjectManager extends StaticObjectManager {
    getRayIntersectionsAt(id, maxDistance) {
        const result = [];
        for (const target of idMap.get(id) ?? []) {
            if (target === this)
                continue;
            const pt = this.rayIntersectsAt(target, maxDistance);
            pt && result.push([target, pt]);
        }
        const vec = getWorldPosition(this.object3d);
        return result.sort((a, b) => {
            return distance3dCached(a[1], vec) - distance3dCached(b[1], vec);
        });
    }
    getRayIntersections(id, maxDistance) {
        return this.getRayIntersectionsAt(id, maxDistance).map(result => result[0]);
    }
    listenToRayIntersection(id, cb, maxDistance) {
        return this.beforeRender(() => {
            for (const [target, pt] of this.getRayIntersectionsAt(id, maxDistance))
                cb(target, pt);
        });
    }
    getIntersections(id) {
        const result = [];
        for (const target of idMap.get(id) ?? []) {
            if (target === this)
                continue;
            this.intersects(target) && result.push(target);
        }
        return result;
    }
    listenToIntersection(id, cb, cbOut) {
        let intersectionsOld = [];
        return this.beforeRender(() => {
            const intersections = this.getIntersections(id);
            if (cb)
                for (const target of intersections)
                    if (!intersectionsOld.includes(target))
                        cb(target);
            if (cbOut)
                for (const target of intersectionsOld)
                    if (!intersections.includes(target))
                        cbOut(target);
            intersectionsOld = intersections;
        });
    }
    onIntersectState;
    onIntersectOutState;
    intersectIdsState;
    initIntersect() {
        if (this.onIntersectState)
            return;
        this.onIntersectState = new Reactive(undefined);
        this.onIntersectOutState = new Reactive(undefined);
        this.intersectIdsState = new Reactive(undefined);
        this.createEffect(() => {
            const { onIntersect, onIntersectOut, intersectIds } = this;
            if (!intersectIds || (!onIntersect && !onIntersectOut))
                return;
            const handles = [];
            for (const id of intersectIds)
                handles.push(this.listenToIntersection(id, onIntersect, onIntersectOut));
            return () => {
                for (const handle of handles)
                    handle.cancel();
            };
        }, [this.onIntersectState.get, this.onIntersectOutState.get, this.intersectIdsState.get]);
    }
    get onIntersect() {
        return this.onIntersectState?.get();
    }
    set onIntersect(val) {
        this.initIntersect();
        this.onIntersectState?.set(val);
    }
    get onIntersectOut() {
        return this.onIntersectOutState?.get();
    }
    set onIntersectOut(val) {
        this.initIntersect();
        this.onIntersectOutState?.set(val);
    }
    get intersectIds() {
        return this.intersectIdsState?.get();
    }
    set intersectIds(val) {
        this.initIntersect();
        this.intersectIdsState?.set(val);
    }
    intersects(target) {
        if (this.done)
            return false;
        if (target.done)
            return false;
        if (this === target)
            return false;
        if (target instanceof SimpleObjectManager) {
            if ((this.bvhMap && target.bvhCharacter) || (this.bvhCharacter && target.bvhMap))
                return (bvhContactMap.get(this)?.has(target) ||
                    bvhContactMap.get(target)?.has(this) || false);
            if (this.cannonBody && target.cannonBody) {
                cannonContactBodies.add(this.cannonBody);
                cannonContactBodies.add(target.cannonBody);
                return (cannonContactMap.get(this.cannonBody)?.has(target.cannonBody) ||
                    cannonContactMap.get(target.cannonBody)?.has(this.cannonBody) || false);
            }
        }
        return super.intersects(target);
    }
    get width() {
        return this.object3d.scale.x * scaleUp;
    }
    set width(val) {
        this.object3d.scale.x = val * scaleDown;
    }
    get height() {
        return this.object3d.scale.y * scaleUp;
    }
    set height(val) {
        this.object3d.scale.y = val * scaleDown;
    }
    get depth() {
        return this.object3d.scale.z * scaleUp;
    }
    set depth(val) {
        this.object3d.scale.z = val * scaleDown;
    }
    get x() {
        return this.outerObject3d.position.x * scaleUp;
    }
    set x(val) {
        this.outerObject3d.position.x = val * scaleDown;
        this.physicsUpdate && ((this.physicsUpdate.position ??= {}).x = true);
    }
    get y() {
        return this.outerObject3d.position.y * scaleUp;
    }
    set y(val) {
        this.outerObject3d.position.y = val * scaleDown;
        this.physicsUpdate && ((this.physicsUpdate.position ??= {}).y = true);
    }
    get z() {
        return this.outerObject3d.position.z * scaleUp;
    }
    set z(val) {
        this.outerObject3d.position.z = val * scaleDown;
        this.physicsUpdate && ((this.physicsUpdate.position ??= {}).z = true);
    }
    get scaleX() {
        return this.outerObject3d.scale.x;
    }
    set scaleX(val) {
        this.outerObject3d.scale.x = val;
    }
    get scaleY() {
        return this.outerObject3d.scale.y;
    }
    set scaleY(val) {
        this.outerObject3d.scale.y = val;
    }
    get scaleZ() {
        return this.outerObject3d.scale.z;
    }
    set scaleZ(val) {
        this.outerObject3d.scale.z = val;
    }
    get scale() {
        return this.scaleX;
    }
    set scale(val) {
        this.scaleX = val;
        this.scaleY = val;
        this.scaleZ = val;
    }
    get rotationX() {
        return this.outerObject3d.rotation.x * rad2Deg;
    }
    set rotationX(val) {
        this.outerObject3d.rotation.x = val * deg2Rad;
        this.physicsUpdate && ((this.physicsUpdate.rotation ??= {}).x = true);
    }
    get rotationY() {
        return this.outerObject3d.rotation.y * rad2Deg;
    }
    set rotationY(val) {
        this.outerObject3d.rotation.y = val * deg2Rad;
        this.physicsUpdate && ((this.physicsUpdate.rotation ??= {}).y = true);
    }
    get rotationZ() {
        return this.outerObject3d.rotation.z * rad2Deg;
    }
    set rotationZ(val) {
        this.outerObject3d.rotation.z = val * deg2Rad;
        this.physicsUpdate && ((this.physicsUpdate.rotation ??= {}).z = true);
    }
    get rotation() {
        return this.rotationZ;
    }
    set rotation(val) {
        this.rotationZ = val;
    }
    get innerVisible() {
        return this.object3d.visible;
    }
    set innerVisible(val) {
        this.object3d.visible = val;
    }
    lookAt(a0, a1, a2) {
        super.lookAt(a0, a1, a2);
        this.physicsRotate();
    }
    translateX(val) {
        this.outerObject3d.translateX(val * scaleDown);
        this.physicsMove();
    }
    translateY(val) {
        this.outerObject3d.translateY(val * scaleDown);
        this.physicsMove();
    }
    translateZ(val) {
        this.outerObject3d.translateZ(val * scaleDown);
        this.physicsMove();
    }
    placeAt(object) {
        if ("outerObject3d" in object) {
            this.outerObject3d.position.copy(getCenter(getObject3d(object)));
            this.outerObject3d.quaternion.copy(getWorldQuaternion(object.outerObject3d));
        }
        else
            this.outerObject3d.position.copy(point2Vec(object));
        this.physicsMove();
        this.physicsRotate();
    }
    moveForward(distance) {
        if (distance === 0)
            return;
        vector3.setFromMatrixColumn(this.outerObject3d.matrix, 0);
        vector3.crossVectors(this.outerObject3d.up, vector3);
        this.outerObject3d.position.addScaledVector(vector3, distance * scaleDown);
        this.physicsMoveXZ();
    }
    moveRight(distance) {
        if (distance === 0)
            return;
        vector3.setFromMatrixColumn(this.outerObject3d.matrix, 0);
        this.outerObject3d.position.addScaledVector(vector3, distance * scaleDown);
        this.physicsMoveXZ();
    }
    onMoveToEnd;
    lerpTo(x, y, z, alpha) {
        const from = new Vector3(this.x, this.y, this.z);
        const to = new Vector3(x, y, z);
        this.cancelHandle("lerpTo", () => onBeforeRender(() => {
            const { x, y, z } = from.lerp(to, alpha);
            if (Math.abs(this.x - x) < 0.1 && Math.abs(this.y - y) < 0.1 && Math.abs(this.z - z) < 0.1) {
                this.cancelHandle("lerpTo", undefined);
                this.onMoveToEnd?.();
            }
            this.x = x;
            this.y = y;
            this.z = z;
            this.physicsMove();
        }));
    }
    moveTo(x, y, z, speed) {
        const { x: rx, y: ry, z: rz } = new Vector3(x - this.x, y === undefined ? 0 : y - this.y, z - this.z).normalize();
        const sx = speed * rx;
        const sy = speed * ry;
        const sz = speed * rz;
        let distOld = Infinity;
        this.cancelHandle("lerpTo", () => onBeforeRender(() => {
            this.x += sx;
            y !== undefined && (this.y += sy);
            this.z += sz;
            let dist = distance3d(this.x, y === undefined ? 0 : this.y, this.z, x, y === undefined ? 0 : y, z);
            if (dist >= distOld) {
                this.cancelHandle("lerpTo", undefined);
                this.onMoveToEnd?.();
                this.x = x;
                y !== undefined && (this.y = y);
                this.z = z;
            }
            distOld = dist;
            y === undefined ? this.physicsMoveXZ() : this.physicsMove();
        }));
    }
}
applyMixins(SimpleObjectManager, [PositionedItem, PhysicsMixin]);
export default SimpleObjectManager;
//# sourceMappingURL=index.js.map