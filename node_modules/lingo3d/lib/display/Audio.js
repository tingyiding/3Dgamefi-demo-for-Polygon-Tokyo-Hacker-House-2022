import { createEffect } from "@lincode/reactivity";
import { AudioListener, PositionalAudio } from "three";
import PositionedItem from "../api/core/PositionedItem";
import mainCamera from "../engine/mainCamera";
import scene from "../engine/scene";
import { onSelectionTarget, emitSelectionTarget } from "../events/onSelectionTarget";
import { audioDefaults, audioSchema } from "../interface/IAudio";
import { getCameraRendered } from "../states/useCameraRendered";
import makeAudioSprite from "./core/utils/makeAudioSprite";
import loadAudio from "./utils/loaders/loadAudio";
const audioListener = new AudioListener();
createEffect(() => {
    const cam = getCameraRendered();
    cam.add(audioListener);
    return () => {
        cam.remove(audioListener);
    };
}, [getCameraRendered]);
export default class Audio extends PositionedItem {
    static componentName = "audio";
    static defaults = audioDefaults;
    static schema = audioSchema;
    sound;
    constructor() {
        const sound = new PositionalAudio(audioListener);
        super(sound);
        this.sound = sound;
        scene.add(sound);
        this.createEffect(() => {
            if (getCameraRendered() !== mainCamera)
                return;
            const sprite = makeAudioSprite();
            this.outerObject3d.add(sprite.outerObject3d);
            const handle = onSelectionTarget(({ target }) => {
                target === sprite && emitSelectionTarget(this);
            });
            return () => {
                sprite.dispose();
                handle.cancel();
            };
        }, [getCameraRendered]);
    }
    dispose() {
        if (this.done)
            return this;
        super.dispose();
        this.sound.disconnect();
        return this;
    }
    _src;
    srcCount = 0;
    get src() {
        return this._src;
    }
    set src(val) {
        if (this._src === val)
            return;
        this._src = val;
        const srcCount = ++this.srcCount;
        if (!val)
            return;
        loadAudio(val).then(buffer => {
            if (srcCount !== this.srcCount || this.done)
                return;
            this.sound.setBuffer(buffer);
        });
    }
    get autoplay() {
        return this.sound.autoplay;
    }
    set autoplay(val) {
        this.sound.autoplay = val;
        val && this.sound.play();
    }
    get loop() {
        return this.sound.loop;
    }
    set loop(val) {
        this.sound.loop = val;
    }
    get distance() {
        return this.sound.getRefDistance();
    }
    set distance(val) {
        this.sound.setRefDistance(val);
    }
    get distanceModel() {
        return this.sound.getDistanceModel();
    }
    set distanceModel(val) {
        this.sound.setDistanceModel(val);
    }
    get maxDistance() {
        return this.sound.getMaxDistance();
    }
    set maxDistance(val) {
        this.sound.setMaxDistance(val);
    }
    get rolloffFactor() {
        return this.sound.getRolloffFactor();
    }
    set rolloffFactor(val) {
        this.sound.setRolloffFactor(val);
    }
}
//# sourceMappingURL=Audio.js.map