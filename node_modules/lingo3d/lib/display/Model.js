import { Group } from "three";
import fit from "./utils/fit";
import Loaded from "./core/Loaded";
import AnimationManager from "./core/mixins/AnimationMixin/AnimationManager";
import { scaleDown } from "../engine/constants";
import { modelDefaults, modelSchema } from "../interface/IModel";
import { objectURLMapperPtr } from "./utils/loaders/setObjectURLMapper";
import { Resolvable } from "@lincode/promiselikes";
import { lazyLoadFBX, lazyLoadGLTF } from "./utils/loaders/lazyLoad";
export default class Model extends Loaded {
    static componentName = "model";
    static defaults = modelDefaults;
    static schema = modelSchema;
    loadedAnims;
    async loadAnimation(url, name = url) {
        (this.loadedAnims ??= {})[name] = url;
        const resolvable = new Resolvable();
        (this.loadingAnims ??= []).push(resolvable);
        let data;
        try {
            data = await this.load(url);
        }
        catch {
            resolvable.resolve();
            return;
        }
        const clip = data.animations[0];
        clip && (this.animations[name] = this.watch(new AnimationManager(clip, await this.loaded)));
        resolvable.resolve();
    }
    get animations() {
        return this.animationManagers ??= {};
    }
    set animations(val) {
        for (const [key, value] of Object.entries(val))
            if (typeof value === "string")
                this.loadAnimation(value, key);
            else
                this.animations[key] = value;
    }
    async load(url) {
        const resolvable = new Resolvable();
        (this.loadingAnims ??= []).push(resolvable);
        let result;
        try {
            if (objectURLMapperPtr[0](url).toLowerCase().endsWith(".fbx"))
                result = await (await lazyLoadFBX()).default(url, true);
            else
                result = await (await lazyLoadGLTF()).default(url, true);
        }
        catch {
            resolvable.resolve();
            return new Group();
        }
        resolvable.resolve();
        return result;
    }
    _loadedScale;
    get loadedScale() {
        return this._loadedScale;
    }
    set loadedScale(val) {
        this._loadedScale = val;
    }
    _loadedPos;
    _loadedX;
    get loadedX() {
        return this._loadedX;
    }
    set loadedX(val) {
        this._loadedX = val;
        this._loadedPos = true;
    }
    _loadedY;
    get loadedY() {
        return this._loadedY;
    }
    set loadedY(val) {
        this._loadedY = val;
        this._loadedPos = true;
    }
    _loadedZ;
    get loadedZ() {
        return this._loadedZ;
    }
    set loadedZ(val) {
        this._loadedZ = val;
        this._loadedPos = true;
    }
    resolveLoaded(loadedObject3d) {
        for (const clip of loadedObject3d.animations)
            this.animations[clip.name] = this.watch(new AnimationManager(clip, loadedObject3d));
        if (this._loadedScale)
            loadedObject3d.scale.multiplyScalar(this._loadedScale);
        else {
            const size = fit(loadedObject3d, this._src);
            !this.widthSet && (this.object3d.scale.x = size.x);
            !this.heightSet && (this.object3d.scale.y = size.y);
            !this.depthSet && (this.object3d.scale.z = size.z);
        }
        if (this._loadedPos) {
            let { x, y, z } = loadedObject3d.position;
            this._loadedX && (x = this._loadedX * scaleDown);
            this._loadedY && (y = this._loadedY * scaleDown);
            this._loadedZ && (z = this._loadedZ * scaleDown);
            loadedObject3d.position.set(x, y, z);
        }
        return loadedObject3d;
    }
    find(name, hiddenFromSceneGraph) {
        const child = super.find(name, hiddenFromSceneGraph);
        child && (child.model = this);
        return child;
    }
    findAll(name) {
        const children = super.findAll(name);
        for (const child of children)
            child.model = this;
        return children;
    }
}
//# sourceMappingURL=Model.js.map